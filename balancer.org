#+TITLE: Balancer

* tasks
** story
*** pfolio
 - в рамках пула ликвидности для токена пифолио необходимо чтобы быть обмен
 - ликвидность внутри, генерация сделок внутри, генерить комиссии и профит самим держателям пифолио. Чем больше торговой активности между инструментами тем больше комиссиий для пифолио холдеров - источник привлекательности токена и повышает количество ликвидности в пуле
 - чтобы ликвидность не кончалась. Когда токен растет в цене чтобы его не вымывали из пула. Необходимы какие-то слипаджи и защиты от имперманент лосс.
 - With market price there is no slippage or loss but liquidity is finite.
 - we want to constraint market price so that trades that deplete liquidity are discouraged.
 - dodo constraints market price by relation between staked and reserve balance, or regression target and current balance, it presumes that shortage in B accompanies overflow in B.
 - We cannot coinstrain market price like in dodo because with multiple assets both balances in a pair can have shortage and instead of keeping staked balance regression would further destabilize portfolio, with one shortage covered with another depleted balance.
 - instead, we want to motivate arbitrage from the highest surplus to the lowest shortage.
 - for that after calculating relation of staked to current you need to calculate relation between those fractions as well.
*** pools uniswap pool, balancer pool, dodo pool
 - PPool only three assets, from balancer
*** pricing BlnPaper vs DODOPaper vs UniPaper
 - since both tokens can get shortage from swapping for third, they can race for regression targets and one can become even more depleted and not useful until arbitraged
 - marginal price from dodo will have to be rewritten as you can no longer rely on either shortage, presume that other side would also lose overflow, instead you should compare shortages or even distance from regression target in either way and better price. in dodo always equilibrium, in balancer never equilibrium, shortage travels between assets?
 - without constant product we lose balancer trait that share of trade after trade doesn't change. instead, share changes with each trade
 - with constant product there is slippage and impermanent loss but infinite liquidity.
 - with dodo it would be more profitable to sell token in shortage, but it wouldbe equally profitable to swapit for another depleted asset and one with surplus. to support swapping base shortage with quote surplus we might compare shortages of base and quote, two quotes, or base with average deviation from regression targets in the pool.
 - PPricing only spot price from Dodo and mean from balancer
 - formulas for locational marginal price aka spot price
 - http://www2.econ.iastate.edu/tesfatsi/DerivationLMP.HLLTAC.pdf
 - PPool only AmountOut, take pmm from DODOPaper for each token, weights andmean from BlnPaper for pool
*** contracts $DODO anf $BLN
 - bpool vs dodopair vs UniPair
   - PPool only provide liquidity for all assets, token map and weights from bpool, + what dodo needs
 - lptokens BLNtoken vs dodotoken
 - bfactory vs dodoZoo vs UniFactory
   - PFactory from Bfactory
 - BMath vs DODOMath vs UniswapV2Library
 - PPool only amountOut, oracles from DODOMath, sum for tokens from bmath
*** governance
 - DODO governance & Balancer governance
   - P governance? g governance?
** slides
   - pfolio
   - pools
   - pricing
   - contracts
   - governance
** uml schemes
   - BPool uml & DODOpair
   - bfactory & dodozoo
   - PPool & PFactory
** code
* balancer docs
** Getting Started
** Core Concepts
**** Protocol
***** Background
Background

Automated Market Makers (AMMs) have been around in some form for as long as trades could be automated, starting in the traditional financial markets. AMMs are essentially automated agents, controlled by algorithms, that define rules for matching buyers and sellers to facilitate trades. Usually AMMs are continuously active in both directions of a trading pair. The liquidity provider's profit comes  from the spread between buy and sell prices.

Smart contract platforms like Ethereum have brought AMMs to a whole new level. They have, for the first time in history, combined the trading algorithms with custody of the underlying assets. This has led to interesting new features like atomic trading (sometimes incorporating flash loans), instant feedback loops for correcting prices offered by an AMM, and more.
AMMs in Ethereum

Alan Lu from Gnosis was the first in the Ethereum community to propose the simplest version of an AMM: a "pool," containing two tokens (let's call them A and B), in which the token prices are derived internally, using only the token balances, according to the simple invariant formula: balance(A) * balance(B) = (constant) k, most commonly written as x*y=k.

 Martin Köppelmann and Vitalik Buterin also promoted this idea, which Hayden Adams eventually implemented on Uniswap.
V. Buterin, "On Path Independence" (linked below)

The "price curve," which can be steeper or gentler based on the choice of constant, defines the price of B in terms of A as the slope of the curve at the point defined by their relative balances. At any given time, we can represent the pool's current composition as a point on that curve.

The pool assets also have external market prices, so we can plot this "point" on the curve as well. If the external market prices diverge from the "internal" prices in either direction, these points will start to "move" away from each other along the curve. In response, arbitrageurs will buy or sell from the pool, trading against the market, changing the relative balances (and therefore prices), until the points converge again and balance is restored.

Balancer is essentially a generalization of the constant product rule to pools containing two or more tokens. In addition, Balancer Pools assign relative weights to each token, to accommodate pools of tokens with significantly different valuations. The weights represent the proportion of each token in the total pool. This flexibility greatly expands the utility of these pools, and allows for many interesting strategies and use cases, as we shall see.
Further Reading

​Euler: The simplest exchange and currency​

​Decentralized Exchanges as Prediction Markets​

​Building a Decentralized Exchange in Ethereum (Gnosis / Alan Lu)

​On Path Independence (Vitalik Buterin)

​Uniswap AMM (Medium article)

​Improving front-running resistance of AMMs​

​Advanced AMMs / Practical AMMs (CMU academic papers)
***** Glossary
Glossary

    Core Pool: A BPool contract object - this is the "base" pool that actually holds the tokens

    Balance: The total token balance of a pool. Does not refer to any user balance.

    Denorm: Denormalized weight. Weights on a BPool, though often displayed as percentages, are configured and stored in their denormalized form. For instance, in a two-token pool with denormalized weights of A=38 and B=2, token A's percentage weight would be 38/(38+2), or 95%. Conversely, token B's proportion would be 2/(38+2), or 5%.

    Controller: The pool's "owner"; an address that can call CONTROL capabilities.

    Factory: The official BPool factory. Pools deployed from this factory appear on Balancer user interfaces (e.g., the Exchange and Pool Manager).

    Smart Pool: A contract that owns (i.e., is the controller), of a Core Pool. Much more about these later.
***** Pool Lifecycle
Pool Lifecycle

Any user can create a new pool by calling newBPool() on the BFactory contract. The caller is set as the controller or pool owner.

Pools can exist in one of two states: controlled or finalized. Pools start in a controlled state and the controller may choose to make the pool finalized by calling finalize(). Finalize is a one-way transition. While in a controlled state, outside actors cannot add liquidity. A controlled state allows the controller to set the pool's tokens and weights.
BPTs

All pools in Balancer are also ERC20 tokens known as BPTs (Balancer Pool Tokens), which represent proportional ownership in the pool's liquidity. When users add liquidity through joinPool or joinswap* they receive BPTs proportional to the amount of assets they are adding to the pool.
Notes

BPTs are an opinionated ERC20 token implementation, and have a few subtle differences. transferFrom from itself does not require a previous allowance.
***** Limitations
Limitations

Balancer is meant to be a flexible and agnostic DeFi primitive. Due to constraints such as gas and math approximations, there are some limitations built into the protocol.

ERC20 Tokens

ERC20 compliance: pool tokens have to be ERC20 compliant. Bronze does not support ERC20 tokens that do not return bools for transfer and transferFrom. There are no upgrade mechanisms in the contracts to allow for token upgrades. Any upgrade will need to be manually coordinated and moved into new pools.

Tokens that have internal transfer fees or other non-standard balance updates may create arbitrage opportunities. Ex: DGX has both a demurrage and a transfer fee that will change a pool's balance compared to the internal accounting balance

Minimum Bound Tokens - 2

A functional pool must contain at least two tokens. (If the pool creator can remove tokens, it is possible to remove them all and have one or zero, but of course no swaps are possible if there is only one token, and a 0-token pool cannot be restored.)

Maximum Bound Tokens - 8

The maximum number of tokens that can be in a given pool is 8.

Maximum Swap In Ratio - 1/2

A maximum swap in ratio of 0.50 means a user can only swap in less than 50% of the current balance of tokenIn for a given pool

Maximum Swap Out Ratio - 1/3

A maximum swap out ratio of 1/3 means a user can only swap out less than 33.33% of the current balance of tokenOut for a given pool

Minimum Swap Fee - 0.0001%

There is a minimum swap fee of 0.0001% (or a hundredth of a basis point) to counteract any unfavorable pool rounding.

Maximum Swap Fee - 10%

This is to prevent malicious pool controllers from setting predatory trading fees. (For instance, a pool controller could front-run a large trade and set the fee to 99%.) No one wants to be this guy.

Minimum Balance - (10^18) / (10^12)

The minimum balance of any token in a pool is 10^6 wei. Important: this is agnostic to token decimals and may cause issues for tokens with less than 6 decimals. Also note that this is only enforced on initial token binding. Future exits can potentially bring the pool below the minimum balance threshold and users should be aware of potential rounding errors.

Min/Max Initial BPT Supply - (100 / 1 Billion)

Core Balancer Pools have a fixed initial token supply of 100 (i.e., BPTs that represent shares of the pool's liquidity). Smart Pools allow the pool creator to specify an initial supply within these bounds.
***** Math
Math

The Balancer whitepaper describes a set of formulas derived from the value function for interacting with the protocol. The formulas in the Theory section are sufficient to describe the functional specification, but they are not straightforward to implement for the EVM, in part due to a lack of mature fixed-point math libraries.

Our implementation uses a combination of a few algebraic transformations, approximation functions, and numerical hacks to compute these formulas with bounded maximum error and reasonable gas cost.
Exponentiation Approximation
Spot Price
SPio=BiWiBoWoSP^o_i = \frac{ \frac{B_i}{W_i} }{ \frac{B_o}{W_o} }SPio​=Wo​Bo​​Wi​Bi​​​

Where:

    Bi is the balance of token i, the token being sold by the trader which is going into the pool.

    Bo is the balance of token o, the token being bought by the trader which is coming out of the pool.

    Wi is the weight of token i

    Wo is the weight of token o

When we consider swap fees, we do exactly the same calculations as without fees, but using Ai⋅(1−swapFee)A_i \cdot (1-swapFee)Ai​⋅(1−swapFee) instead of AiA_iAi​. This strategy is referred to as charging fees "on the way in." With the swap fee, the spot price increases. It then becomes:
SPio=BiWiBoWo⋅1(1−swapFee)SP^o_i = \frac{ \frac{B_i}{W_i} }{ \frac{B_o}{W_o} } \cdot \frac{1}{(1-swapFee)}SPio​=Wo​Bo​​Wi​Bi​​​⋅(1−swapFee)1​
**** Out-Given-In

In the Whitepaper, we derive the following formula to calculate the amount of tokens out –AoA_oAo​– a trader gets in return for a given amount of tokens in –AiA_iAi​, considering a Balancer pool without any swap fees:
Ao=Bo⋅(1−(BiBi+Ai)WiWo)A_{o} = B_{o} \cdot \left(1 - \left(\frac{B_{i}}{B_{i}+A_{i}}\right)^{\frac{W_{i}}{W_{o}}}\right)Ao​=Bo​⋅⎝⎛​1−(Bi​+Ai​Bi​​)Wo​Wi​​⎠⎞​

To take into account the swap fees charged by the Balancer pool, we replaceAiA_iAi​withAi⋅(1−swapFee)A_i \cdot (1-swapFee)Ai​⋅(1−swapFee). This is known as charging the fees "on the way in"
Ao=Bo⋅(1−(BiBi+Ai⋅(1−swapFee))WiWo)A_{o} = B_{o} \cdot \left(1 - \left(\frac{B_{i}}{B_{i}+A_{i} \cdot (1-swapFee)}\right)^{\frac{W_{i}}{W_{o}}}\right)Ao​=Bo​⋅⎝⎛​1−(Bi​+Ai​⋅(1−swapFee)Bi​​)Wo​Wi​​⎠⎞​
In-Given-Out

In the Whitepaper, we derive the following formula for the amount of tokens in –AiA_iAi​– a trader needs to swap to get a desired amountAoA_oAo​of tokens out in return, considering a Balancer pool without any swap fees:
Ai=Bi⋅((BoBo−Ao)WoWi−1)A_{i} = B_{i} \cdot \left(\left(\frac{B_{o}}{B_{o}-A_{o}}\right)^{\frac{W_{o}}{W_{i}}}-1\right)Ai​=Bi​⋅((Bo​−Ao​Bo​​)Wi​Wo​​−1)

Since AiA_iAi​ is the amount the user has to swap to get a desired amount out AoA_oAo​, all we have to do to include swap fees is divide the formula above by (1−swapFee)(1-swapFee)(1−swapFee). This is because we know the fee charged on the way in will multiply that amountAiA_iAi​ by (1−swapFee)(1-swapFee)(1−swapFee). This will cross out both terms (1−swapFee)(1-swapFee)(1−swapFee) and the amount out will be AoA_oAo​ as desired:
Ai=Bi⋅((BoBo−Ao)WoWi−1)⋅1(1−swapFee)A_{i} = B_{i} \cdot \left(\left(\frac{B_{o}}{B_{o}-A_{o}}\right)^{\frac{W_{o}}{W_{i}}}-1\right) \cdot \frac{1}{(1-swapFee)}Ai​=Bi​⋅((Bo​−Ao​Bo​​)Wi​Wo​​−1)⋅(1−swapFee)1​
All-Asset Deposit/Withdrawal

Anyone can be issued Balancer pool tokens (provided the pool is finalized) by depositing proportional amounts of each of the assets contained in the pool. So, for each token k in the pool, the amounts of token k –DkD_kDk​– that need to be deposited for someone to get PissuedP_{issued}Pissued​pool tokens are:
Dk=(Psupply+PissuedPsupply−1)⋅BkD_k = \left(\frac{P_{supply}+P_{issued}}{P_{supply}}-1\right) \cdot B_kDk​=(Psupply​Psupply​+Pissued​​−1)⋅Bk​

Conversely, if a user wants to redeem their pool tokens to get their proportional share of each of the underlying tokens in the pool, the amounts of token k –AkA_kAk​– a user gets for redeeming PredeemedP_{redeemed}Predeemed​pool tokens will be:
Ak=(1−Psupply−PredeemedPsupply)⋅BkA_k = \left(1-\frac{P_{supply}-P_{redeemed}}{P_{supply}}\right) \cdot B_kAk​=(1−Psupply​Psupply​−Predeemed​​)⋅Bk​

All Balancer Protocol smart contracts were coded supporting a protocol-level exit fee to be charged that goes to Balancer Labs for supporting the development of the protocol. However, after careful consideration the Balancer Labs team decided to launch the first version of Balancer without any protocol fees whatsoever. (For technical reasons, this is unlikely to change.)
Single-Asset Deposit / Withdrawal
Single-Asset Deposit

In the Whitepaper, we derive the following formula for the amount of pool tokens –PissuedP_{issued}Pissued​– a liquidity provider gets in return for depositing an amount AtA_tAt​of a single token t  present in the pool:
Pissued=Psupply⋅((1+AtBt)Wt−1)P_{issued} = P_{supply} \cdot \left(\left(1+\frac{A_t}{B_t}\right)^{W_t} -1\right) Pissued​=Psupply​⋅((1+Bt​At​​)Wt​−1)

Since Balancer allows for depositing and withdrawing liquidity to Balancer pools using only one of the tokens present in the pool, this could be used to do the equivalent of a swap: provide liquidity depositing token A, and immediately withdraw that liquidity in token B. Therefore a swap fee has to be charged, proportional to the tokens that would need to be swapped for an all-asset deposit.

Another justification for charging a swap fee when a liquidity provider does a single-asset deposit is that they are getting a share of a pool that contains a basket of different assets. So what they are really doing is trading one of the pool assets (the token t being deposited) for proportional shares of all the pool assets.

Since the pool already has a share of its value in token t, represented by the weightWtW_tWt​, it only makes sense to charge a swap fee for the remaining portion of the deposit At⋅(1−Wt)A_t \cdot(1 - W_t)At​⋅(1−Wt​)​

The formula then becomes:
Pissued=Psupply⋅((1+(At−At⋅(1−Wt)⋅swapFee)Bt)Wt−1)P_{issued} = P_{supply} \cdot \left(\left(1+\frac{\left(A_t-A_t\cdot(1 - W_t)\cdot swapFee\right)}{B_t}\right)^{W_t} -1\right) Pissued​=Psupply​⋅((1+Bt​(At​−At​⋅(1−Wt​)⋅swapFee)​)Wt​−1)

The formula above calculates the amount of pool tokens one receives in return for a deposit of a given amount of a single asset. We also allow for users to define a given amount of pool tokens they desire to get – PissuedP_{issued}Pissued​– and calculate what amount of tokens t is needed – AtA_tAt​:
At=Bt⋅((1+PissuedPsupply)1Wt−1)A_t = B_t \cdot \left(\left(1+\frac{P_{issued}}{P_{supply}}\right)^{\frac{1}{W_t}} -1\right) At​=Bt​⋅((1+Psupply​Pissued​​)Wt​1​−1)

Taking into account the swap fees, we have:
At=Bt⋅((1+PissuedPsupply)1Wt−1)(1−Wt)⋅swapFeeA_t = B_t \cdot \frac{\left(\left(1+\frac{P_{issued}}{P_{supply}}\right)^{\frac{1}{W_t}} -1\right)}{(1 - W_t)\cdot swapFee}At​=Bt​⋅(1−Wt​)⋅swapFee((1+Psupply​Pissued​​)Wt​1​−1)​
Single-Asset Withdrawal

Without considering swap fees, each withdrawal formula is simply the inverse of the corresponding deposit formula. In other words, if you deposit a given amount of token t  for pool tokens and then immediately redeem these pool tokens for token t, you should receive exactly what you started off with.

The formula without considering swap fees is then:
At=Bt⋅(1−(1−PredeemedPsupply)1Wt)A_t = B_t \cdot \left(1-\left(1-\frac{P_{redeemed}}{P_{supply}}\right)^\frac{1}{W_t}\right)At​=Bt​⋅(1−(1−Psupply​Predeemed​​)Wt​1​)

Where AtA_tAt​ is the amount of token t  one receives when redeeming PredeemedP_{redeemed}Predeemed​pool tokens.

Considering swap fees, we have the following:
At=Bt⋅(1−(1−PredeemedPsupply)1Wt)⋅(1−(1−Wt)⋅swapFee)A_t = B_t \cdot \left(1-\left(1-\frac{P_{redeemed}}{P_{supply}}\right)^\frac{1}{W_t}\right)\cdot \left(1-(1 - W_t)\cdot swapFee\right)At​=Bt​⋅(1−(1−Psupply​Predeemed​​)Wt​1​)⋅(1−(1−Wt​)⋅swapFee)

If there were an exit fee, it would be taken from the amount of tokens redeemed PredeemedP_{redeemed}Predeemed​but as mentioned above this fee is zero in the first version of Balancer.

Balancer also allows for a liquidity provider to choose a desired amount of token t, AtA_tAt​, they would like to withdraw from the pool, and calculates the necessary amount of pool tokens required for that,PredeemedP_{redeemed}Predeemed​. The formula without considering swap fees is:
Predeemed=Psupply⋅(1−(1−AtBt)Wt)P_{redeemed} = P_{supply} \cdot \left(1-\left(1-\frac{A_t}{B_t}\right)^{W_t} \right) Predeemed​=Psupply​⋅(1−(1−Bt​At​​)Wt​)

Where AtA_tAt​ is the amount of token t  one receives when redeeming PredeemedP_{redeemed}Predeemed​pool tokens.

Considering swap fees, we have the following:
Predeemed=Psupply⋅(1−(1−At(1−(1−Wt)⋅swapFee)Bt)Wt)P_{redeemed} = P_{supply} \cdot \left(1-\left(1-\frac{\frac{A_t}{\left(1-(1 - W_t)\cdot swapFee\right)}}{B_t}\right)^{W_t} \right) Predeemed​=Psupply​⋅⎝⎛​1−(1−Bt​(1−(1−Wt​)⋅swapFee)At​​​)Wt​⎠⎞​
***** Exponentiation
Exponentiation

The main formulas used in Balancer protocol make use of a form of exponentiation where both the base and exponent are fixed-point (non-integer) values. Take for example the swap functions, where the weights in both the exponent and the base are fractions:
Ao=(1−(BiBi+Ai)WiWo).Bo
Ao​=⎝⎛​1−(Bi​+Ai​Bi​​)Wo​Wi​​⎠⎞​.Bo​
Ai=⎛⎝(BoBo−Ao)WoWi−1⎞⎠.Bi

Since solidity does not have fixed point algebra or more complex functions like fractional power we use the following binomial approximation:
(1+x)α=1+αx+(α)(α−1)2!x2+(α)(α−1)(α−2)3!x3+⋯=∞∑k=0(αk)xk

which converges for ∣x∣<1

∣x∣<1.

When α>1
α>1 we split the calculation into two parts for increased accuracy, the first is the exponential with the integer part of αα (which we can calculate exactly) and the second is the exponential with the fractional part of α

α:
Ai=⎛⎝1−(BoBo−Ao)int(WoWi)(BoBo−Ao)WoWi%1⎞⎠.Bi
*** BAL Governance Token
BAL Governance Token

Since inception, our goal at Balancer Labs has been to decentralize and diversify governance of the Balancer Protocol. We have looked into several approaches and designs, and have landed on an approach we are proud to share: the Balancer Protocol Governance Token (BAL).

We believe alignment between token holders and protocol stakeholders is crucial for successful decentralized governance. More explicitly, we believe BAL tokens are the vehicle to drive alignment and participation in the protocol. BAL tokens are not an investment; BAL token holders should be people who interact with the protocol in some way, are committed to its future development, and want a seat at the governance table.
Balancer’s Most Important Stakeholders: Liquidity Providers

The Balancer protocol allows any Ethereum account to add liquidity in the form of tokens to existing Balancer pools, or even create their own pools.

Liquidity attracts traders, trading generates fees, and ultimately pool profitability attracts more liquidity. This is a flywheel effect that we are beginning to see happen within the Balancer protocol.

Regardless of the venue, early liquidity providers take on more risk and opportunity cost: including contract risk, low initial pool profitability, etc. We believe that these protocol users should get to participate early on in deciding how the protocol evolves. Toward this end, Balancer Labs proposed and implemented the concept of liquidity mining, where Balancer governance tokens (BALs) are distributed to liquidity providers. See below for further details.
Future Balancer Versions and the Governance Token

Balancer V1 launched without a native token, and confirmed our assumption that Balancer’s approach would resonate with the community. However, in order for the protocol to keep up with the fast evolving Ethereum and DeFi space, we are convinced that many new versions and continuous development of the protocol will be essential.

BALs are a key way of decentralizing the governance of the protocol such that it remains resilient over time, and protected from the failure of any single stakeholder. Our governance needs to be as resilient as our technology infrastructure.

We expect token holders to help guide the protocol to its fullest potential through experimentation and active participation. For example, implementing new functionality, deploying the protocol on additional smart contract blockchains beyond Ethereum, using layer 2 solutions for scaling, introducing a protocol level fee, etc. Anything contentious will certainly go to the BAL token holders for review.
Token Supply and Distribution

The total supply of BAL tokens will be capped at 100M. This does NOT mean that this cap will ever be reached. It will be up to governance (controlled by BAL token holders) to decide if the distribution should end before this cap is reached. 

25M BAL tokens were initially allocated to founders, stock options, advisors and investors, all subject to vesting periods.

5M were allocated for the Balancer Ecosystem Fund. This fund will be deployed to attract and incentivize strategic partners who will help the Balancer ecosystem grow and thrive. BAL holders will ultimately decide how this fund is used over the coming years.

5M were allocated for the Fundraising Fund. Balancer Labs raised a pre-seed and seed round. This fund will be used for future fundraising rounds to support Balancer Labs' operations and growth. BAL tokens will never be sold to retail investors.

The remaining 65M tokens are intended to be mostly distributed to liquidity providers in the coming years. 

Every week 145,000 BALs, or approximately 7.5M per year, are distributed to liquidity providers. This means that in the first year of BAL’s existence there would be 30% supply inflation from the initial supply of 25M tokens (here we are not considering the two funds, since they are not yet allocated). 

This high rate of supply inflation is meant to kickstart the distribution of governance rights of the protocol to those who earn it. At the the current rate of 145,000 BAL per week, it would take 8.666 years to distribute the whole 65M BAL remaining, before reaching the 100M cap.

The schedule of BAL distribution over the next few years - and whether it should stop before the 100M cap is reached - will be extensively discussed within the Balancer community, and will ultimately be decided by BAL holders.

For full transparency, the seed series price of one BAL token was $0.60.
*** Liquidity Mining
Liquidity Mining
BAL Distribution Proportional to Liquidity on Balancer

To make the token distribution as fair as possible, we distribute BAL tokens proportional to the amount of liquidity each address contributed, relative to the total liquidity on Balancer. Since there is liquidity in several different tokens, we use the USD value as the common measure.

Head over to https://claim.balancer.finance/ to claim your BAL from liquidity mining.

​This diagram details the different types of pool configurations that are possible, and which interventions are necessary to ensure correct BAL attribution. The CRP Tutorial describes the mechanics of redirection and redistribution, but in a nutshell:

    For private pools, BAL accrue to the pool controller

    For shared pools, BAL accrue to the LPs (pool token holders)

    For smart pools created through the standard factory, BAL accrue to smart pool token holders (LPs)

    For smart pools created by other means, register to "redistribute" if you want BAL assigned automatically to token holders, or "redirect" to handle the distribution yourself

     If smart pool tokens are held in a contract that cannot withdraw them (e.g., a staking contract), you can use redirect to assign their BAL to an account

In practice, every week Balancer Labs has to:

    Define the starting and ending block of the week. Both are chosen as the block with the closest timestamp to a fixed weekly time (e.g. Sunday 1:00pm UTC). For example, the starting block for a given week might be #10,100,000 and the ending block #10,140,000.

    Define snapshot blocks, every 256 blocks (roughly hourly) counting backwards from the ending block until the starting block. For the example above, the snapshot blocks would be #10,140,000, #10,139,744, #10,139,488, and so on.

    For each snapshot block, and for each Balancer pool, get the USD price of the tokens in the pool from CoinGecko, and calculate the total USD liquidity.

    Since liquidity in pools that have lower trading fees contribute more to protocol usage than liquidity in pools with higher fees, we multiply the USD pool liquidity by a feeFactor that down-weights pools according to their fee percentage:

The constant, k, was initially set to 0.5, but beginning in week 8 (July 20th 00:00 UTC), the community approved a proposal to to change k to 0.25 in order to ease the penalty for higher-fee pools. This creates the following bell-shaped curve for feeFactor, which means, for example, that a pool with a 0.5% fee has a feeFactor of ~0.98, a pool with a 1% fee has a feeFactor of ~0.94, and a pool with a 2% fee has a feeFactor of ~0.78:

    UPDATED for week 2 (starting June 8th 00:00 UTC), multiply the pool liquidity by a ratioFactor. Since pools that are imbalanced contribute less to trading volume (because the slippage is higher), the community approved a proposal to add a ratioFactor. This way highly imbalanced pools (such as those with 98%/2% weights) have a much lower weight in the final BAL distribution.

    UPDATED for week 3 (starting June 15th 00:00 UTC), multiply the pool liquidity by a wrapFactor. Since pools containing pairs of tokens that have a hard peg (e.g. DAI and cDAI) do not contribute much trading volume (because traders can wrap DAI for cDAI and vice-versa), the community approved a proposal to add a wrapFactor. This way, liquidity in such pairs (like cETH/ WETH) has a 0.1 wrapFactor (i.e. counts 10 times less than for other regular pairs), reducing the amount of BAL received by their liquidity providers. In week 8 (starting July 20th 00:00 UTC), the community approved a proposal to add a wrapFactor for soft pegged pairs. While for hard pegs, the factor is 0.1, for soft pegs it is 0.7 (much less harsh). A soft pegged pair is one in which the two assets are not directly convertible, but they do track the same underlying asset's price by design. Examples include a pair of USD stable coins (e.g. DAI and USDC) or a synthetic paired with its real-world asset (e.g. sETH and WETH).

    UPDATED for week 9 (starting June 29th 00:00 UTC), after the liquidity of all tokens is adjusted as usual by the currently active factors (ratio, wrap, fee), a capFactor has been proposed, which is calculated such that every capped token is limited to a maximum of $10M in adjusted liquidity. capFactor is then applied to the liquidity of each affected capped token, resulting in an adjusted liquidity for every pool containing those tokens.ETH, DAI, USDC, WBTC, BAL is the list of uncapped tokens. Please read the proposal linked above for further details and examples.

        UPDATED for week 12 (starting August 17th 00:00 UTC): capFactor is no longer fixed at $10M, but rather set on a per token basis.

    UPDATED for week 13 (starting August 23rd 00:00 UTC): Liquidity Staking - liquidity in pairs formed by BAL and an uncapped token is amplified by a stakingBoost:

        Calculate the sum of the adjusted liquidity of all pools (L1)

        Calculate a hypothetical sum of the adjusted liquidity of all pools (L2) if a stakingBoost of 3 were to be applied to liquidity in pairs formed by BAL and an uncapped token

        Compute the stakingBoost that would be required in order for 45k of the 145k BAL weekly mined to be awarded exclusively to liquidity providers in BAL+uncapped_tokens pairs.

            stakingBoost = 1 + 0.9 * L1 / (L2 - L1)

    Calculate the proportional, adjusted, and capped (see capFactor above) liquidity USD value that each liquidity provider has in the pool, including the final stakingBoostcomputed in the previous step. The table below shows an example for a pool that has 100$ worth of liquidity (already adjusted by all factors):

    Divide the weekly amount of BALs distributed by the number of snapshot blocks. Considering blocks lasting 15s, a week would have a total of 40,320 blocks (=7*24*60*60/15). Of these, there would be 158 snapshot blocks (=40,320/256). With 145,000 BAL distributed per week, the number of BAL distributed per snapshot block would be approximately 918 (=145,000/158).

    For each snapshot block, calculate the number of BAL tokens allocated to each address. This is calculated for each address proportional to the total liquidity of that account (considering all pools they've contributed to), divided by the total protocol liquidity. The table below shows an example of the final distribution for a snapshot block.

Address
	

% of the total adjusted liquidity
	

BAL mined

0xaaa
	

1%
	

9.18

0xbbb
	

2%
	

18.36

...
	

...
	

...

Total:
	

100%
	

918

All the calculations described above depend exclusively on on-chain data and historical token prices openly accessible on CoinGecko. This whole calculation process is fully auditable via an open source script.
Token Whitelist and Eligible Pools for Liquidity Mining

UPDATED for week 9 (starting June 29th 00:00 UTC): All tokens present in the whitelist created by the community (see whitelist proposal) are eligible for BAL liquidity mining. The most up to date list is maintained on Balancer's Github. All tokens listed under the "homestead" list in the json file linked are eligible. This list will evolve over time with input from the community.

Only Balancer pools containing two or more whitelisted tokens will be eligible for BAL liquidity mining.

Note that if you've created a Smart Pool eligible for BAL rewards - without going through our standard factory - you must apply to either redirect them to a regular account (e.g., for a single-LP, private pool), or redistribute the rewards directly to LPs. (See the CRP Tutorial for more details.)
**** Exchange and Reward Listing
Exchange and Reward Listing

Token listings are managed in this repository, with the following categories:

    eligible.json: assets eligible for BAL mining as per weekly proposals

    listed.json: assets listed on balancer.exchange

    ui-not-eligible.json: assets vetted by community members

    untrusted.json: assets that are incompatible with Balancer

There are two kinds of token "listings" on Balancer. The first is listing on the Exchange. Listed tokens appear on the main page as swapping options. It is possible to access unlisted pairs through a "deep link" with their addresses (balancer.exchange/#/swap/<address1>/<address2>), but it displays unlisted tokens as addresses, and with a warning.

There is no formal process for listing tokens on the Balancer exchange UI. That is up to the team's discretion and relies on internal factors around trading volume, usage, and legitimacy. (As noted above, it's always possible to trade tokens via contract address.)

The second kind of listing is eligibility for BAL rewards. New tokens are listed (and occasionally removed) through a weekly governance process There is a streamlined process for simply listing a new token - tokens that meet a set of technical criteria below can be approved without requiring community vote. Only increasing the cap, introducing "controversial" or non-conforming tokens, or adjusting the reward process or its parameters requires a vote.

To request approving your token for BAL rewards, just post to #token-requests on the Discord channel. Each weekly reward period begins at 00:00 UTC on Monday; any requests approved after then will take effect the following week.

The listing criteria below are taken from this accepted proposal. (We will endeavor to keep this up-to-date, but see the Balancer Forum for the very latest.)

    The token’s smart contract must be verified on Etherscan. Neglecting this small degree of transparency adds unnecessary friction to the process of vetting for the remaining criteria.

    The token must conform to the ERC-20 interface described in EIP-20. Namely, the functions transfer(), transferFrom(), and approve() must return booleans.

    The token’s transfer() and transferFrom() implementations must exhibit the expected behavior - namely, transferring N tokens from one address to another. Certain divergences from this behavior, such as transfer fees, can cause issues with Balancer pools, and these tokens will be rejected.

    The token’s approve() implementation must exhibit the expected behavior - namely, it must allow for infinite approval, or the token cannot be sold using the Balancer exchange proxy.

    The token must not be vulnerable to the so-called "gulp() attack," which is exposed when a pool’s token balance changes unbeknownst to the pool. For now, known cases include tokens that charge a transfer fee (as described in #3) and tokens that periodically rebase. A rebasing token utilizing an atomic rebase+gulp should be safe from such attacks, but none has yet been discovered. (Added note: Ampleforth released a pool with this behavior, though it was implemented through a Balancer Pool subclass, not the token contract.)

    The token must not possess any mechanisms which, when combined with a Balancer pool, result in material losses to the principal value of the pooled token. This criterion covers all value-loss edge cases which may be difficult to anticipate but can still preclude a token’s whitelisting. Examples will be added as they are discovered; the only currently known example is VBZRX, whose claim() mechanism entitles token holders to receive BZRX airdrops on each token transfer. In isolation, this mechanism is perfectly safe, but if a token is airdropped to a Balancer pool whose asset list does not contain said token, then the airdropped tokens are forever locked in the pool contract and cannot be recovered by anyone (including Balancer Labs).

    The token must have a price feed accessible via CoinGecko’s API, e.g. this example link for WETH. This is instrumental to calculating a pool’s eligibility for BAL rewards. If a token meets all of the remaining criteria but not this criterion, it can be added to the UI whitelist and reconsidered for the mining whitelist once the price feed becomes available.
*** Security
**** Audit
Audits
Audits of the balance-core smart contracts

Balancer has completed full audits with Consensys Diligence, Trail of Bits, and Open Zeppelin. Links to the audit reports can be found below.

    Trail of Bits

Trail of Bits Full Audit
Trail of Bits Full Audit.pdf - 2MB

     Consensys Diligence

Balancer Finance | ConsenSys Diligence
Executive Summary In April 2020, Balancer asked us to conduct a security assessment of Balancer Finance - Balancer core: an automated portfolio manager, liquidity provider, and price sensor. We performed this assessment from May 4 to May 15, 2020. The assessment primarily focused on the high-level logic of balancer-core: BPool. The engagement was conducted by Alexander Wade and Shayan Eskandari, the total effort spent was 4 person-weeks. Scope Our review focused on the commit hash 5d70da92b1bebaa515254d00a9e064ecac9bd18e.
diligence.consensys.net

​Open Zeppelin Full Audit​

    OpenZeppelin

Balancer Contracts Audit
Balancer is an automated portfolio manager. It allows anyone to create Balancer pools, each of which implements an automated market maker (AMM) that is a generalization of the constant-product AMM …
blog.openzeppelin.com
**** Bug Bounty
Bug Bounty
Overview

Balancer has completed smart contract audits with Trail of Bits and Open Zeppelin. We also will run a continuous bug bounty program for the bronze release of Balancer core.
Scope

The bug bounty covers any of the core smart contracts deployed on Mainnet. The code can be found at: https://github.com/balancer-labs/balancer-core​

Submissions should be based off commit hash: https://github.com/balancer-labs/balancer-core/tree/2d88257fb27ad3c84b5166304a342e66055a81b3​

Mainnet BFactory can be found at: https://etherscan.io/address/0x9424b1412450d0f8fc2255faf6046b98213b76bd​

Additional second layer contracts, such as the exchange proxy or individual smart pool contracts, may be added at a further date.
Rewards

The bounty program will pay out rewards according to the severity of a vulnerability. The final reward amount is at the sole discretion of Balancer Labs. See eligibility section below for more details.

Reward
	

Severity
	

Examples

$20,000 - $50,000
	

Critical
	

    Stealing assets from a pool

    Permanently freezing pool assets

$10,000 - $20,000
	

High
	

    Severe rounding errors where an attacker can steal significant funds in excess of any gas costs or swap fees

    Manipulating a finalized pool's assets / weights / fees

$2,000 - $5,000
	

Medium
	

    Minor rounding errors that allow an attacker to slowly manipulate funds to their advantage

$0 - $2,000
	

Low
	

    Informational and code quality based disclosures

Reporting / Disclosures

Please report any findings to security@balancer.finance, with full details about any vulnerability and steps / code to reproduce. Allow us time to review and remediate any findings before public disclosure.
Ineligible Findings

    Duplicate vulnerabilities. Only the first reporter will be rewarded.

    Findings already known as part of a formal audit.

    Findings related to non-standard ERC20 tokens might be ineligible as many vulnerabilities might be inserted in non-standard ERC20 tokens on purpose for applying for this bug bounty. 
** Smart Contracts
*** Exchange Proxy
Exchange Proxy
Summary

This contract includes swap forwarding proxy logic and on-chain smart order routing functionality.

batchSwap functions allows users to batch execute swaps recommended by off-chain SOR.

viewSplit functions query the On Chain Registry to provide best swap information using on-chain data.

smartSwap functions combine view and batch functionality to provide complete optimised on-chain swaps.
API
Batch Swap Functions
multihopBatchSwapExactIn

multihopBatchSwapExactIn(Swap[][] memory swapSequences, TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountIn, uint minTotalAmountOut) public payable

Execute multi-hop swaps returned from off-chain SOR for swapExactIn trade type.
multihopBatchSwapExactOut

multihopBatchSwapExactOut(Swap[][] memory swapSequences, TokenInterface tokenIn, TokenInterface tokenOut, uint maxTotalAmountIn) public payable

Execute multi-hop swaps returned from off-chain SOR for swapExactOut trade type.
batchSwapExactIn

batchSwapExactIn(Swap[] memory swaps, TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountIn, uint minTotalAmountOut) public payable

Execute single-hop swaps for swapExactIn trade type. Used for swaps returned from viewSplit function and legacy off-chain SOR.
batchSwapExactOut

batchSwapExactOut(Swap[] memory swaps, TokenInterface tokenIn, TokenInterface tokenOut, uint maxTotalAmountIn) public payable

Execute single-hop swaps for swapExactOut trade type. Used for swaps returned from viewSplit function and legacy off-chain SOR.
View Split Functions
viewSplitExactIn

viewSplitExactIn(address tokenIn, address tokenOut, uint swapAmount, uint nPools)

View function that calculates most optimal swaps (exactIn swap type) across a max of nPools. Returns an array of Swaps and the total amount out for swap.
viewSplitExactOut

viewSplitExactOut(address tokenIn, address tokenOut, uint swapAmount, uint nPools)

View function that calculates most optimal swaps (exactOut swap type) across a max of nPools. Returns an array of Swaps and the total amount in for swap. 
(! Please be aware the return parameter "totalOutput" in the contract is a misnomer and actually represents totalInput !)
Smart Swap Functions

smartSwapExactIn

smartSwapExactIn(TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountIn, uint minTotalAmountOut, uint nPools) public payable

Calculates and executes most optimal swaps across a max of nPools for tokenIn > tokenOut swap with an input token amount = totalAmountIn.
smartSwapExactOut

smartSwapExactOut(TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountOut, uint maxTotalAmountIn, uint nPools) public payable

Calculates and executes most optimal swaps across a max of nPools for tokenIn > tokenOut swap with a desired output token amount = totalAmountOut.
*** Smart Order Router
Smart Order Router
Overview

Smart Order Router, or SOR, is an off-chain linear optimization of routing orders across pools for best price execution. It takes as input a desired amount of any token to be traded for another token, and returns a list of pools/amounts that should be traded such that the amount of returned tokens is maximized. The sum of the amounts to be traded with each pool equals the desired amount given as input.

SOR exists in the Bronze release as a way to aggregate liquidity across all Balancer pools. Future releases of Balancer will accomplish this on-chain, and allow aggregate contract fillable liquidity.

Liquidity aggregators are free to use the SOR npm package or create their own order routing across pools.
Motivation

Since there might be many Balancer pools that contain a given pair, trading only with the most liquid pool is not ideal. The fact that after a single-pool trade arbitrageurs can profit by leveling all pool prices means that the single-pool trader left value on the table.

The ideal solution - in a world where there were no gas costs or gas limits - would be to trade with all pools available in the desired pair. The amount traded with each pool should move them all to the same new spot price. This would mean all pools would be in an arbitrage-free state, and no further value could be extracted by arbitrageurs (which always comes at the expense of the trader).

As there are incremental gas costs associated with interacting with additional Balancer pools, the SOR ensures that any additional interactions are profitable; i.e., the profit obtained through trading with each new pool exceeds the associated gas cost. This is an optimization problem that depends on the gas fees paid to the Ethereum network: higher gas prices may cause the SOR to select fewer trading pools.
How it works

The fundamental optimization problem is to find the path through a set of Balancer Pools with the highest net yield after gas costs. The algorithm continues to add pools to the trading set, until there are no pools left where the net gain from trading with the pool would exceed the gas cost.
Linearization

Even though the SOR runs totally off-chain, it has been designed to be EVM-tractable, since we intend to release an on-chain version in the future.

Since we know the price will increase after trading, due to slippage, and in order to make the SOR EVM-tractable, the function that calculates the spot price of a Balancer pool after a trade has been linearized. We refer to EP – the estimated price – as the spot price a pool will have after a trade, according to that linearized approximation. The figure below shows the real (non-linear) spot price after a given amount is traded versus the linearized approximation we use.
Prices of interest

Since we linearize the spot price functions of all Balancer pools, we can interpolate prices and amounts to make our optimization solution simpler. 

To help visualize what this means, imagine three Balancer pools containing the trade tokens. We define EPs of interest as sets of prices where either of the following conditions apply:

    There is a pool with exactly that initial spot price; or

    The spot prices of two pools "cross" at that price.

The figure below shows the six different EPs of interest for that case.
Solution example

To reduce clutter and simplify the visualization, we consider only pools 1 and 2 for the following walk through.

Let A be the amount of token in  (Ai) to be traded on pool 1 such that its price increases from EP1 (initial spot price of pool 1) to EP2 (initial spot price of pool 2). The SOR's solution for any amount of tokens lower than A is simply: "trade the entire amount with pool 1."

When the amount traded is greater than A, SOR will start including pool 2 in the solution, as not doing so would mean the trader is trading some amount (Ai - A) for a higher price than they could with pool 2.

The solution for trading an amount B + C can be found by interpolating the trades that result in EP2 and EP3. By trading C with pool 1 and B with pool 2, both pools end at the same price (Final Price) which means that the best solution was found. 
Development

Balancer labs have developed the SOR npm package, an easy to use implementation of the above concepts. For documentation for working with the package please see this page.

**** Development & Examples
Development & Examples

Documentation for working with the @balancer-labs/sor package. For a description of the SOR and math, see this page.

Please take caution as the SOR is under heavy development and may have breaking changes.

The SOR package includes a primary SOR object with an SOR.getSwaps function and several helper functions for retireving Balancer pool data.
SOR Object

When instantiating a new SOR object we must pass five parameters to the constructor:

const SOR = new sor.SOR(Provider: JsonRpcProvider, GasPrice: BigNumber, MaxPools: number, ChainId: number, PoolsUrl: string)

Where:

    Provider is an Ethereum network provider (ex: local node or Infura).

    GasPrice is used by the SOR as a factor to determine how many pools to swap against. i.e. higher cost means more costly to trade against lots of different pools. This value can be changed.

    MaxPools is the max number of pools to split the trade across. Limit to a reasonable number given gas costs.

    ChainId is the network chain ID (i.e. 1=mainnet, 42=Kovan)

    PoolsUrl is a URL used to retrieve a JSON list of Balancer Pools to be considered. Balancer labs currently keeps an updated list at:

        Mainnet: https://ipfs.fleek.co/ipns/balancer-team-bucket.storage.fleek.co/balancer-exchange/pools​

        Kovan: https://ipfs.fleek.co/ipns/balancer-team-bucket.storage.fleek.co/balancer-exchange-kovan/pools​

Fetching Pool Data

The SOR requires an up to date list of pool data when calculating swap information and retrieves on-chain token balances for each pool. There are two available methods:
 await SOR.fetchPools()

This will fetch all pools (using the URL in constructor) and on-chain balances. Returns true on success or false if there has been an error.
await SOR.fetchFilteredPairPools(TokenIn, TokenOut)

A subset of valid pools for token pair, TokenIn/TokenOut, is found and on-chain balances retrieved. Returns true on success or false if there has been an error. This can be a quicker alternative to using fetchPools but will need to be called for every token pair of interest.
Processing Swaps
async SOR.getSwaps(...)

The getSwaps function will use the pool data and the trade parameters to perform an optimization for the best price execution. It returns swap information and the total that can then be used to execute the swaps on-chain.

#+begin_src js
[swaps, total] = await SOR.getSwaps(
        tokenIn,
        tokenOut,
        swapType,
        swapAmount
    );
#+end_src

tokenIn - string: address of token in

tokenOut - string: address of token out

swapType - string: either swapExactIn or swapExactOut

swapAmount - BigNumber: amount to be traded, in Wei
async SOR.setCostOutputToken(tokenOut)

The cost of the output token in ETH multiplied by the gas cost to perform the swap. This is used to determine whether the lower price obtained through including an additional pool in the transaction outweigh the gas costs. This function can be called before getSwaps to retrieve and cache the cost which will then be used in any getSwap calls using that token. Defaults to 0 for a token if not previously set.

Notice that tokenOut is tokenOut if swapType == 'swapExactIn' and tokenIn if swapType == 'swapExactOut.
***** Example - Using SOR To Get List Of Swaps

Below is an example snippet that uses the SOR to return a final list of swaps and the expected output. The swaps returned can then be passed on to the exchange proxy or otherwise used to atomically execute the trades.


#+begin_src js

require('dotenv').config();
import { SOR } from '@balancer-labs/sor';
import { BigNumber } from 'bignumber.js';
import { JsonRpcProvider } from '@ethersproject/providers';
​
// MAINNET
const tokenIn = '0x6B175474E89094C44Da98b954EedeAC495271d0F'; // DAI
const tokenOut = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'; // WETH
​
​
(async function() {
    const provider = new JsonRpcProvider(
        `https://mainnet.infura.io/v3/${process.env.INFURA}`
    );
​
    const poolsUrl = `https://ipfs.fleek.co/ipns/balancer-team-bucket.storage.fleek.co/balancer-exchange/pools`;
​
    const gasPrice = new BigNumber('30000000000');
​
    const maxNoPools = 4;
​
    const chainId = 1;
​
    const sor = new SOR(provider, gasPrice, maxNoPools, chainId, poolsUrl);
​
    // isFetched will be true on success
    let isFetched = await sor.fetchPools();
​
    await sor.setCostOutputToken(tokenOut);
​
    const swapType = 'swapExactIn';
​
    const amountIn = new BigNumber('1000000000000000000');
​
    let [swaps, amountOut] = await sor.getSwaps(
        tokenIn,
        tokenOut,
        swapType,
        amountIn
    );
    console.log(`Total Return: ${amountOut.toString()}`);
    console.log(`Swaps: `);
    console.log(swaps);
})()
#+end_src
***** Example - SOR & ExchangeProxy

Balancer labs makes use of a ExchangeProxy contract that allows users to batch execute swaps recommended by the SOR. The following example shows how SOR and ExchangeProxy can be used together to execute on-chain trades.

#+begin_src js

require('dotenv').config();
import { SOR } from '@balancer-labs/sor';
import { BigNumber } from 'bignumber.js';
import { JsonRpcProvider } from '@ethersproject/providers';
import { Wallet } from '@ethersproject/wallet';
import { MaxUint256 } from '@ethersproject/constants';
import { Contract } from '@ethersproject/contracts';
​
async function makeSwap() {
    // If running this example make sure you have a .env file saved in root DIR with INFURA=your_key, KEY=pk_of_wallet_to_swap_with
    const isMainnet = true;
​
    let provider, WETH, USDC, DAI, chainId, poolsUrl, proxyAddr;
​
    const ETH = '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE';
    // gasPrice is used by SOR as a factor to determine how many pools to swap against.
    // i.e. higher cost means more costly to trade against lots of different pools.
    // Can be changed in future using SOR.gasPrice = newPrice
    const gasPrice = new BigNumber('25000000000');
    // This determines the max no of pools the SOR will use to swap.
    const maxNoPools = 4;
    const MAX_UINT = MaxUint256;
​
    if (isMainnet) {
        // Will use mainnet addresses - BE CAREFUL, SWAP WILL USE REAL FUNDS
        provider = new JsonRpcProvider(
            `https://mainnet.infura.io/v3/${process.env.INFURA}`
        );
        WETH = '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'; // Mainnet WETH
        USDC = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'; // Mainnet USDC
        DAI = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
        chainId = 1;
        poolsUrl = `https://ipfs.fleek.co/ipns/balancer-team-bucket.storage.fleek.co/balancer-exchange/pools`;
        proxyAddr = '0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21'; // Mainnet proxy
    } else {
        // Will use Kovan addresses
        provider = new JsonRpcProvider(
            `https://kovan.infura.io/v3/${process.env.INFURA}`
        );
        WETH = '0xd0A1E359811322d97991E03f863a0C30C2cF029C'; // Kovan WETH
        USDC = '0x2F375e94FC336Cdec2Dc0cCB5277FE59CBf1cAe5'; // Kovan USDC
        DAI = '0x1528F3FCc26d13F7079325Fb78D9442607781c8C'; // Kovan DAI
        chainId = 42;
        poolsUrl = `https://ipfs.fleek.co/ipns/balancer-team-bucket.storage.fleek.co/balancer-exchange-kovan/pools`;
        proxyAddr = '0x4e67bf5bD28Dd4b570FBAFe11D0633eCbA2754Ec'; // Kovan proxy
    }
​
    const sor = new SOR(provider, gasPrice, maxNoPools, chainId, poolsUrl);
​
    // This fetches all pools list from URL in constructor then onChain balances using Multicall
    console.log('Fetching pools...');
    await sor.fetchPools();
    console.log('Pools fetched, get swap info...');
​
    let tokenIn = WETH;
    let tokenOut = USDC;
    let swapType = 'swapExactIn';
    let amountIn = new BigNumber('1e16');
    // This calculates the cost to make a swap which is used as an input to sor to allow it to make gas efficient recommendations.
    // Can be set once and will be used for further swap calculations.
    // Defaults to 0 if not called or can be set manually using: await sor.setCostOutputToken(tokenOut, manualPriceBn)
    await sor.setCostOutputToken(tokenOut);
​
    let [swaps, amountOut] = await sor.getSwaps(
        tokenIn,
        tokenOut,
        swapType,
        amountIn
    );
​
    console.log(`Total Expected Out Of Token: ${amountOut.toString()}`);
​
    console.log('Exectuting Swap Using Exchange Proxy...');
​
    const wallet = new Wallet(process.env.KEY, provider);
    const proxyArtifact = require('./abi/ExchangeProxy.json');
    let proxyContract = new Contract(proxyAddr, proxyArtifact.abi, provider);
    proxyContract = proxyContract.connect(wallet);
​
    console.log(`Swapping using address: ${wallet.address}...`);
    /*
    This first swap is WETH>TOKEN.
    The ExchangeProxy can accept ETH in place of WETH and it will handle wrapping to Weth to make the swap.
    */
​
    let tx = await proxyContract.multihopBatchSwapExactIn(
        swaps,
        ETH, // Note TokenIn is ETH address and not WETH as we are sending ETH
        tokenOut,
        amountIn.toString(),
        amountOut.toString(), // This is the minimum amount out you will accept.
        {
            value: amountIn.toString(), // Here we send ETH in place of WETH
            gasPrice: gasPrice.toString(),
        }
    );
    console.log(`Tx Hash: ${tx.hash}`);
    await tx.wait();
​
    console.log('New Swap, ExactOut...');
    /*
    Now we swap TOKEN>TOKEN & use the swapExactOut swap type to set the exact amount out of tokenOut we want to receive.
    ExchangeProxy will pull required amount of tokenIn to make swap so tokenIn approval must be set correctly.
    */
    tokenIn = USDC;
    tokenOut = DAI;
    swapType = 'swapExactOut'; // New Swap Type.
    amountOut = new BigNumber(1e18); // This is the exact amount out of tokenOut we want to receive
​
    const tokenArtifact = require('./abi/ERC20.json');
    let tokenInContract = new Contract(tokenIn, tokenArtifact.abi, provider);
    tokenInContract = tokenInContract.connect(wallet);
    console.log('Approving proxy...');
    tx = await tokenInContract.approve(proxyAddr, MAX_UINT);
    await tx.wait();
    console.log('Approved.');
​
    await sor.setCostOutputToken(tokenOut);
​
    // We want to fetch pools again to make sure onchain balances are correct and we have most accurate swap info
    console.log('Update pool balances...');
    await sor.fetchPools();
    console.log('Pools fetched, get swap info...');
​
    [swaps, amountIn] = await sor.getSwaps(
        tokenIn,
        tokenOut,
        swapType,
        amountOut
    );
​
    console.log(`Required token input amount: ${amountIn.toString()}`);
​
    console.log('Exectuting Swap Using Exchange Proxy...');
​
    tx = await proxyContract.multihopBatchSwapExactOut(
        swaps,
        tokenIn,
        tokenOut,
        amountIn.toString(), // This is the max amount of tokenIn you will swap.
        {
            gasPrice: gasPrice.toString(),
        }
    );
    console.log(`Tx Hash: ${tx.hash}`);
    await tx.wait();
    console.log('Check Balances');
}
​
makeSwap();
#+end_src
*** Smart Pools
Smart Pools

One very powerful feature of Balancer is the concept of Smart Pools. A smart contract controlled pool can fully emulate a finalized pool, while also allowing complex logic to readjust balances, weights, and fees.

This section provides details for Balancers reference Smart Pool contract implementation, the Configurable Rights Pool (CRP).

For a step by step guide on developing with the CRP and details on possible Smart Pool use cases please also see:

    ​CRP Tutorial​

    ​Smart Pool Use Cases​

    ​The Bankless Ultimate Guide to Balancer Smart Pools​
**** Overview
Overview
Smart Contract Owned Controlled Pools ("Smart Pools")

One very powerful feature of Balancer is the concept of Smart Pools. A smart contract controlled pool can fully emulate a finalized pool, while also allowing complex logic to readjust balances, weights, and fees. Some examples include:

    ​An interest bearing stablecoin pool without impermanent loss​

    A pool that adjusts swap fees as a function of the volatility of the pool's assets

    A pool that updates weights to implement a particular market strategy (e.g., a Liquidity Bootstrapping Pool).

    More complex dynamic strategies for asset allocation

For clarity, here is a graphical representation of the process for creating both Core Pools and Smart Pools - it can be a little confusing keeping all the addresses straight!

In a nutshell, Balancer has deployed Factory contracts for creating pools. Users deploy new pool contracts by calling create methods on these factories. In both cases, the actual "pool" visible to traders on the public interfaces is a new BPool contract.

If you deploy a Core Pool directly, you are the controller of that pool. If you deploy a Smart Pool, you need to pass in the core BFactory address, since two contracts will be deployed. You are the controller of the Smart Pool - and the Smart Pool itself is the controller of the BPool.
Conceptual Capabilities

There are three categories of things you can do with pools.

    Trade - using the swap functions

    Provide liquidity - using the join/exit pool functions (both single- and multi-asset entry and exit are supported)

    Manage the pool - if you are the controller (e.g., change its parameters)

Core Pools can only be managed until "finalized," after which their parameters are immutable.

Smart Pools are managed according to the rights granted to the controller on creation. For instance, you can create a Smart Pool where the weights can be changed, but the swap fee and token composition are fixed.

    SWAP  (swap_*, joinswap_*, exitswap_*)

    JOIN (joinPool, joinswap_*)

    EXIT (exitPool, exitswap_*)

    CONTROL (bind, unbind, rebind, setSwapFee, finalize)

Notice that e.g. joinswap requires both JOIN and SWAP.
**** Configurable Rights Pool
Configurable Rights Pool

The Balancer Configurable Rights Pool is the reference implementation of a smart contract-controlled Balancer Pool. It is flexible enough to be used directly to create customizable Smart Pools. Like the Core Pool (BPool), it is created from a factory - and as the name implies, its functionality can be customized to meet the needs of your project.

It is also designed to be easily extensible, and we showcase examples of Configurable Rights Pool extensions in Smart Pool Templates. These are projects with specific needs and custom logic, which need to override and alter core functionality.

For example, the first template is Ampleforth's Elastic Supply Pool, which features a different mechanism for updating weights, consistent with its daily rebase operation. We will add more templates as we discover further interesting use cases! (If you have a suggestion, we'd love to hear from you on the smart-pool-dev channel on Discord.)

You will find the addresses for deployed contracts on all networks here.
How is a Smart Pool different from a Core Pool?

As explained in Core Concepts, a core Balancer Pool's parameters can be changed at will while in the "controlled" state - when only the pool creator can add liquidity. The only way to "open" the pool to outside investment is to "finalize" it - after which all pool parameters are fixed. This is great for security and trust minimization - but what if you want to do liquidity bootstrapping, dynamically adjust swap fees, handle a token with unique properties (such as AMPL), or implement a complex investment strategy? For that, you'll need to change parameters dynamically on "live" pools - and that requires a Smart Pool.

In summary, a Core Pool has "all rights" while controlled, and then "no rights" after finalization. A Configurable Rights Pool has whatever rights you give it, for all time. So what are these rights?

**** Component Libraries
Component Libraries

The Configurable Rights Pool uses several externally linked libraries to implement all its functionality, detailed below.

    BalancerConstants - constant state variables used throughout

    BalancerSafeMath - similar to Open Zeppelin SafeMath, but normalized so that "1" = 10^18, to allow fractional arithmetic (e.g., on weights)

    RightsManager - defines a struct of boolean values, corresponding to each right; the Configurable Rights Pool stores this struct in storage.

    SmartPoolManager - factors out computationally intensive functions, mainly to reduce the bytecode size of the Configurable Rights Pool, to keep it deployable

    SafeApprove - an internal library (adapted from PieDAO) to enable pools to contain ERC20 tokens that require approve calls to be made from a base of 0 (e.g., KNC)

The Configurable Rights Pool contains getter functions that return the addresses of these libraries; a bit of future-proofing, so that clients can implement versioning.
***** Rights Manager
Rights Manager

The Rights Manager library defines all the ways you can customize a Configurable Rights Pool. In general, granting more rights to a Smart Pool requires users to place greater trust in the smart pool creator.

The library is designed to be easily extensible (e.g., the method signatures don't change as more rights are added). Let's take a look at the current set of rights, and how they might be applied to real use cases.

    Pause Swapping: allows the controller to halt trading (swaps) on the underlying core pool. Like finalized core pools, Configurable Rights Pools are created with trading enabled. With pause swapping, the controller (or logic in the smart contract) can toggle trading on and off. For instance, the controller might want to "short-circuit" the contract in certain pathological cases, such as market crashes.

    Change Swap Fee: allows the controller to change the Swap Fee after contract deployment, within the bounds set by the underlying core pool (e.g., it cannot be zero, or greater than 10%). With this right, it would be possible to implement fee optimization strategies (e.g., maximize return, or minimize impermanent loss).

    Change Weights: the controller can call updateWeight (to directly update a single token's weight), or updateWeightsGradually (to linearly transform a set of weights over time). This enables liquidity bootstrapping, UMA-style perpetual synthetics, and many other strategies. Note that altering weights will change balances - which means transferring tokens - in order to leave prices unchanged. When updating weights gradually, the protocol enforces a minimum time between updates, and a minimum total time for the update. These parameters are set at create time, and are immutable thereafter.

    Add/Remove Tokens: allows the controller to change the composition of the pool. Needless to say, this requires a lot of trust in the smart pool owner, but enables powerful strategies, especially in combination with other rights. For example, a perpetual "rolling" synthetic. Adding a token is a two-step process meant to mitigate this risk and lower the trust required. The protocol emits an event when a token is "committed" (about to be added), and enforces a minimum wait time before the controller can "apply" (actually add) the token.

    Whitelist LPs: when this right is enabled, no one can add liquidity (including the controller, beyond initial creation of the pool), unless they are added to a whitelist by the creator. This enables things private investment clubs, exclusive token launches, etc.

    Change Cap: Inspired by PieDAO's capped pools, Configurable Rights Pools have a "cap" on the total supply of pool tokens that can be issued. This can be used for experimental/risky pools, to limit potential losses, or to halt further provision of liquidity at any time. When this right is not enabled, there is no cap. When it is enabled, the cap is set to the initial supply on creation - and can be changed later by the controller.
**** Smart Pool Templates
Smart Pool Templates

Balancer provides templates at two levels. At the contract level, templates are examples of how to extend the core Smart Pool contract for custom use cases (see below).

For most use cases, you can just use the Configurable Rights Pool directly, and need only to customize the settings. The Smart Pool Templates in the guides section show examples of how to configure smart pools for different expected use cases.

Smart Pool Template contracts are example subclasses of the Configurable Rights Pool, illustrating how particular use cases might be implemented. The first is the Ampleforth-inspired Elastic Supply Pool.

Updating weights in a regular Configurable Rights Pool transfers tokens (to keep prices stable). In the case of AMPL, a combination of "rebasing" (altering the token supply) and changing weights accomplishes this without transferring tokens. In Elastic Supply Pools, weights are "resynced" instead of "updated."

To disallow both kinds of updates in the same pool, the Elastic Supply Pool overrides and reverts the existing update functions, and implements the new resync() method.
**** Liquidity Bootstrapping FAQ
Liquidity Bootstrapping FAQ
How do I launch a Liquidity Bootstrapping Pool?

Decide on critical parameters, such as sale duration, starting and ending weights, and estimate the demand (i.e., expected sale rate), using the LBP simulator to adjust the settings until you are happy with the resulting price curve. (Best practice is to copy/download it, then customize to your own use case.)

Post on #token-requests to request eligibility for governance token rewards. (At least a week’s advance notice is recommended, and BAL rewards require an active CoinGecko price feed.)

If your pool is eligible for weekly BAL rewards, they will be distributed to your LPs automatically. However, to receive BAL rewards yourself, you must redirect them from the smart pool contract to a wallet that can receive them - otherwise they will be locked in the contract and lost. This is done through a pull request to update this file in the mining repository. 
How long should an LBP last?

This is a fully customizable parameter that is up to you, based on your objectives. However we can provide some general tips. It’s important to give your potential investors sufficient time to participate and for healthy price discovery to occur. We’ve seen this process work well over a span of 3 days, but as LBPs are a new innovation, we believe there are other lengths of time that could work as well or even better. 

Considering the fast pace and unpredictability of events happening regularly in DeFi, making your LBP too short could allow obstacles that are unrelated to your project (i.e., a spike in Ethereum network congestion or a new yield farming craze) to get in the way of a successful sale. We would recommend at least 3 days, but you are certainly free to make it shorter if you believe it would better serve your particular case.
Note that the default minimum duration is approximately 2 weeks (and 2 hours for the add token time lock); using a shorter period will require overriding that default when you create the pool. This mainly applies to those writing scripts; if you use the smart pool GUI, the defaults are very short (both 10 blocks).
How should I choose a starting price?

You can think of the starting price of your LBP as the ceiling you’d want to set for the token sale. This may seem counterintuitive, but since LBPs work differently than other token sales, your starting price should be set much higher than what you believe is the fair price. 

This does not mean you’re trying to sell the token above what it’s worth. Setting a high starting price allows the changing pool weights of your LBP to make their full impact, lowering the price progressively until a market equilibrium is reached. Unlike older token sale models such as bonding curves, LBP investors are disincentivized to buy early, and instead benefit from waiting for the price to decrease until it reaches a level they believe is fair.

For example, if you believe the fair price for your token is $2, you may want to consider an opening price that is up to $10.
What are the recommended starting and ending weight configurations for an LBP?

The general idea is to start with the pool weights skewed towards your token and end with the pool weights skewed towards the reserve asset(s). This configuration is designed to make it so that the majority of your tokens end up being exchanged for the reserve asset(s) you have chosen.

Be sure to think all the way through your intended sale, since there are some technical subtleties. For instance, if your weights are very close to the min/max weight boundaries, pokeWeights could fail in some edge cases where the total would temporarily be exceeded. Unless you need the maximum 98%/2% (49/1 denorm) weights, it's best to use weights that sum to a lower total number (e.g., 38/2), and put the project token first in the list when you create the pool, so that the weight decrease would be processed first. (We may be updating the GUI to avoid this issue by lowering the "resolution" in these cases - the max for a pool with canChangeWeights enabled would then be 96%/4%.)
How can I use an LBP to conduct a token sale with minimal seed capital?

The lower you set the weight(s) of the reserve asset(s) in your LBP, the less upfront capital you would need to seed your LBP. In a two-token LBP, the most skewed ratio you can set is 2:98, meaning that the pool composition will be 2% your reserve asset, and 98% the project token. 

However, since the value of your project’s tokens is proportional to the value of the reserve assets you provide for the sale, the amount of funds you can raise in the sale is limited by the total value of the reserve assets you provide to the LBP.

For example, with an LBP weight ratio of 2:98 (reserve asset:project token), if your upfront capital is 50K USDC, and your starting price is 10 USDC, the amount of tokens you can sell is [(50K / 0.02) / 10] = approx. 250K tokens.

In contrast, if your upfront capital is 1M USDC, you’d be able to sell around 5M tokens.
How can I calculate different scenarios for the amount of tokens to sell, based on the amount of seed capital and pool weights?

You can use our LBP simulator to plug in your variables and see the projected results. (Best practice is to copy it so you have your own version, or even download to Excel.)

There's a lot going on there, but a good place to start is the "ad hoc" simulator at the top right. There, you can type in balances, weights, and the swap fee, and see what the initial price would be. Then you can type your starting values into the main interface on the top left, and experiment with different ending weights and sale rates to come up with a reasonable price curve. It will also display the total proceeds and leftover tokens.

You'll see right away that it is very sensitive to the sale rate. The price is derived from two values - balances and weights. And you only control one of them! Your weight "flipping" schedule determines how the weights will change over time, but (unless you intervene with further issuance or buybacks), balances only change through trades: mostly people buying your token with the reserve currency.

If people buy while the weights are constant - or someone places a huge order - the token price may go up sharply. This is how a token sale can get "stuck" on a platform like Uniswap, where the prices are set by balances only. This may be optimal for retail liquidity, but is much less so for a token sale.

In an LBP, buyers suffering sticker shock need only wait for the weights to adjust and the price to start dropping. (If they are impatient, they can call the public pokeWeights function themselves to tell the contract to update weights to the proper values at the current block.)

In practice, we have seen that the market is efficient. Traders do indeed keep the price within a fairly narrow band around the discovered market value. That is one reason we believe this is the fairest token distribution method yet discovered. And as a bonus, this price curve tends to maximize total proceeds of the sale.

Note that it may not always be possible to sell all available tokens in the desired price range with the capital available. In this case, you could either split up the sale into multiple tranches (either re-using the same pool, or making new pools, using the proceeds of each to fund the next), or alter the supply or weight function during the sale in various ways, as described below.
How can I influence the token price while running an LBP?

Unless you deposit tokens yourself during the sale (e.g, by adding additional liquidity through joinPool), the only way to affect prices during an LBP is by setting the target pool weights. Changing the target pool weights influences price, such that increasing the weight of an asset increases its relative price, and vice versa. The change in price gradually incentivizes investors to buy your token in exchange for the reserve asset(s), which then changes the balances of assets in the pool.
How do I change the weights of my LBP while it’s live?

Use the updateWeightsGradually function to put the contract into a state where it will respond to the pokeWeights call by setting all the weights according to the point on the "weight curve" corresponding to the current block. pokeWeights can be called by you, or anyone, to update the weights according to your LBP’s configuration.

You can also call updateWeight (as long as a gradual update is not running) to set weights arbitrarily - but this will not affect the price. It will transfer tokens as required such that the new balances and weights maintain current prices.
What are the reserve assets I can sell my token for?

You can sell your token for any ERC-20 tokens. You can choose up to 7 other tokens to be used as reserve assets in your LBP token sale. Projects typically sell their tokens for highly liquid stablecoins such as DAI, USDC, or USDT; and/or for WETH.
How do I get my token listed by name and logo on the Balancer exchange UI?

The Balancer team regularly monitors the crypto landscape and adds new tokens to our listings based on internal requirements. Tokens do not need to request to be listed on the exchange, as it is done proactively.

If you are launching an LBP and want to make sure that your token is listed on the exchange before launch, please contact the team for assistance.
How do I get my token whitelisted for BAL mining earnings?

​This page describes the process.
After providing the initial seed capital needed to launch an LBP, do I need to deposit additional capital later?

No, you do not need any additional capital beyond the initial seed amount based on the starting weights you’ve selected for your pool. However, you do have the optional ability to deposit new capital into the pool as a buyback mechanism while the LBP is running.


If you use the LP whitelisting to disable public LPs, and wish to add liquidity yourself later, you will need to add your DSProxy address (if you're using the GUI) to the whitelist in order to do so. (On the smart pool GUI, this address can be found on the About page, under "smart pool controller".)
Can I deploy/control the LBP from a script?

Yes. Conversely, if you wrote your own script to deploy the pool (vs using the smart pool GUI), you can also manage it from the GUI. To do this, you would call setController (or use that feature on the Settings page, if you're starting from the GUI), and set it to the address you want to control the pool. You could deploy through the GUI, then setController to the account running the script (e.g., to set the swap fee dynamically based on an off-chain algorithm). To transfer it back, just call setController again from that script, setting it to your DSProxy address.

DSProxy contracts are "helper contracts" deployed per user account to make interacting with multiple pools easier and more gas-efficient. If you're starting from a script and don't have one, you can start to create a pool through the GUI, and it will prompt you to create a proxy as the first step.

The Pool Management GUI and Configurable Rights Pool are both open source. You can refer to the large test suite for many examples of how to interact with the CRP, and both the CRP suite and the Vue app contain helper functions for things like slippage and adding/removing liquidity. There are also many simulators available, linked at the bottom of the CRP Tutorial.

We've tried to make it as clear and straightforward as possible - but there are subtleties the GUI handles that you would need to hand-code in a script. For instance, balances for tokens with less than 18 must be "normalized." This includes many common tokens; e.g., USDC has 6, Compound cTokens all have 8, etc.

For instance, a balance of "10" in wei would be "10000000000000000000" for DAI (with 18 decimals), but "10000000" for USDC (with 6 decimals).

One final note - if you deploy a CRP through a script, we recommend using the standard CRPFactory (addresses here). If you deploy it "directly", it will still work, but will not be recognized by the BAL mining scripts, and you will need to do a redirect.
*** On Chain Registry
On Chain Registry
Summary

Stores a registry of Balancer Pool addresses for a given token address pair. Pools can be sorted in order of liquidity and queried via view functions. Used in combination with the Exchange Proxy swaps can be sourced and exectured entirely on-chain.
API
Adding Pools To Registry
addPoolPair

addPoolPair(address pool, address token1, address token2)

Adds a single pool address for token pair.
addPools

addPools(address[] calldata pools, address token1, address token2)

Adds an array of pool addresses for token pair.
Sorting Pools
sortPools

sortPools(address[] calldata tokens, uint256 lengthLimit)

Sorts pools in order of liquidity. lengthLimit can be used to limit the number of pools sorted.
sortPoolsWithPurge

sortPoolsWithPurge(address[] calldata tokens, uint256 lengthLimit)

Sorts pools in order of liquidity and removes any pools with <10% of total liquidity.
Retrieving Pools
getBestPools

getBestPools(address fromToken, address destToken)

Retrieve array of pool addresses for token pair. Ordered by liquidity if previously sorted. Max of 32 pools returned.
getBestPoolsWithLimit

getBestPoolsWithLimit(address fromToken, address destToken, uint256 limit)

Retrieve array of pool addresses for token pair. Ordered by liquidity if previously sorted. Max of n pools returned where n=limit.
getPoolsWithLimit

getPoolsWithLimit(address fromToken, address destToken, uint256 offset, uint256 limit)

Retrieve array of pool addresses using an offset starting position.
*** Interfaces
Interfaces

BFactory

#+begin_src solidity
interface BFactory {
​
    function isBPool(address b) external view returns (bool);
    function newBPool() external returns (BPool);
​
}
#+end_src

BPool

#+begin_src solidity
interface BPool {
​
    function isPublicSwap() external view returns (bool);
    function isFinalized() external view returns (bool);
    function isBound(address t) external view returns (bool);
    function getNumTokens() external view returns (uint);
    function getCurrentTokens() external view returns (address[] memory tokens);
    function getFinalTokens() external view returns (address[] memory tokens);
    function getDenormalizedWeight(address token) external view returns (uint);
    function getTotalDenormalizedWeight() external view returns (uint);
    function getNormalizedWeight(address token) external view returns (uint);
    function getBalance(address token) external view returns (uint);
    function getSwapFee() external view returns (uint);
    function getController() external view returns (address);
​
    function setSwapFee(uint swapFee) external;
    function setController(address manager) external;
    function setPublicSwap(bool public_) external;
    function finalize() external;
    function bind(address token, uint balance, uint denorm) external;
    function rebind(address token, uint balance, uint denorm) public;
    function unbind(address token) external;
    function gulp(address token) external;
​
    function getSpotPrice(address tokenIn, address tokenOut) external view returns (uint spotPrice);
    function getSpotPriceSansFee(address tokenIn, address tokenOut) external view returns (uint spotPrice);
​
    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external;   
    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external;
​
    function swapExactAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        address tokenOut,
        uint minAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountOut, uint spotPriceAfter);
​
    function swapExactAmountOut(
        address tokenIn,
        uint maxAmountIn,
        address tokenOut,
        uint tokenAmountOut,
        uint maxPrice
    ) external returns (uint tokenAmountIn, uint spotPriceAfter);
​
    function joinswapExternAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        uint minPoolAmountOut
    ) external returns (uint poolAmountOut);
​
    function joinswapPoolAmountOut(
        address tokenIn,
        uint poolAmountOut,
        uint maxAmountIn
    ) external returns (uint tokenAmountIn);
​
    function exitswapPoolAmountIn(
        address tokenOut,
        uint poolAmountIn,
        uint minAmountOut
    ) external returns (uint tokenAmountOut);
​
    function exitswapExternAmountOut(
        address tokenOut,
        uint tokenAmountOut,
        uint maxPoolAmountIn
    ) external returns (uint poolAmountIn);
​
    function totalSupply() external view returns (uint);
    function balanceOf(address whom) external view returns (uint);
    function allowance(address src, address dst) external view returns (uint);
​
    function approve(address dst, uint amt) external returns (bool);
    function transfer(address dst, uint amt) external returns (bool);
    function transferFrom(
        address src, address dst, uint amt
    ) external returns (bool);
​
    function calcSpotPrice(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint swapFee
    ) public pure returns (uint spotPrice);
​
    function calcOutGivenIn(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint tokenAmountIn,
        uint swapFee
    ) public pure returns (uint tokenAmountOut);
​
    function calcInGivenOut(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint tokenAmountOut,
        uint swapFee
    ) public pure returns (uint tokenAmountIn);
​
    function calcPoolOutGivenSingleIn(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint poolSupply,
        uint totalWeight,
        uint tokenAmountIn,
        uint swapFee
    ) public pure returns (uint poolAmountOut);
​
    function calcSingleInGivenPoolOut(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint poolSupply,
        uint totalWeight,
        uint poolAmountOut,
        uint swapFee
    ) public pure returns (uint tokenAmountIn)
​
    function calcSingleOutGivenPoolIn(
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint poolSupply,
        uint totalWeight,
        uint poolAmountIn,
        uint swapFee
    ) public pure returns (uint tokenAmountOut)
​
    function calcPoolInGivenSingleOut(
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint poolSupply,
        uint totalWeight,
        uint tokenAmountOut,
        uint swapFee
    ) public pure returns (uint poolAmountIn)
​
}

#+end_src

Exchange Proxy

#+begin_src solidity
interface ExchangeProxy {
​
    function batchSwapExactIn(
        Swap[] memory swaps,
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint totalAmountIn,
        uint minTotalAmountOut
    )
        public payable
        returns (uint totalAmountOut);
​
    function batchSwapExactOut(
        Swap[] memory swaps,
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint maxTotalAmountIn
    )
        public payable
        returns (uint totalAmountIn)
​
    function multihopBatchSwapExactIn(
        Swap[][] memory swapSequences,
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint totalAmountIn,
        uint minTotalAmountOut
    )
        public payable
        returns (uint totalAmountOut)
​
    function multihopBatchSwapExactOut(
        Swap[][] memory swapSequences,
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint maxTotalAmountIn
    )
        public payable
        returns (uint totalAmountIn)
​
    function smartSwapExactIn(
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint totalAmountIn,
        uint minTotalAmountOut,
        uint nPools
    )
        public payable
        returns (uint totalAmountOut)
​
    function smartSwapExactOut(
        TokenInterface tokenIn,
        TokenInterface tokenOut,
        uint totalAmountOut,
        uint maxTotalAmountIn,
        uint nPools
    )
        public payable
        returns (uint totalAmountIn)
​
    function viewSplitExactIn(
        address tokenIn,
        address tokenOut,
        uint swapAmount,
        uint nPools
    )
        public view
        returns (Swap[] memory swaps, uint totalOutput)
​
    function viewSplitExactOut(
        address tokenIn,
        address tokenOut,
        uint swapAmount,
        uint nPools
    )
        public view
        returns (Swap[] memory swaps, uint totalOutput)
}

#+end_src
​
*** Addresses

Addresses
Mainnet

    Core Pool Factory: 0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd

    BalancerSafeMath (library): 0xCfE28868F6E0A24b7333D22D8943279e76aC2cdc

    RightsManager (library): 0x0F811b1AF2B6B447B008eFF31eCceeE5A0b1d842

    SmartPoolManager (library): 0xA3F9145CB0B50D907930840BB2dcfF4146df8Ab4

    Smart Pool Factory (CRPFactory): 0xed52D8E202401645eDAD1c0AA21e872498ce47D0

    BActions: 0xde4A25A0b9589689945d842c5ba0CF4f0D4eB3ac

    Exchange Proxy: 0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21

    Onchain Registry: 0x7226DaaF09B3972320Db05f5aB81FF38417Dd687

    ​MerkleRedeem (BAL Distribution) 0x6d19b2bF3A36A61530909Ae65445a906D98A2Fa8

Kovan

    Core Pool Factory: 0x8f7F78080219d4066A8036ccD30D588B416a40DB

    BalancerSafeMath (library): 0x0fd81EFddb4f8b2948B164145FbbcC8084136DcB

    RightsManager (library): 0xFd069b1d2daC3d1C277BeFa8E51Aad77D9f9167B

    SmartPoolManager (library): 0x8DBB8C9bFEb7689f16772c85136993cDA0c05eA4

    Smart Pool Factory (CRPFactory): 0x53265f0e014995363AE54DAd7059c018BaDbcD74

    BActions: 0xeACBe91fE3F8eF6086027AEC0127De982205b1Aa

    Exchange Proxy: 0x4e67bf5bD28Dd4b570FBAFe11D0633eCbA2754Ec

    Onchain Registry: 0xC5570FC7C828A8400605e9843106aBD675006093

    ​MerkleRedeem (BAL Distribution) 0x3bc73D276EEE8cA9424Ecb922375A0357c1833B3

Rinkeby

    Core Pool Factory: 0x9C84391B443ea3a48788079a5f98e2EaD55c9309

    BActions: 0xA492414f528175f7F5D7881eC01434eF62779502

    Exchange Proxy: 0xeF5f222c49c89a231F3aBE30114c77EE904e1e44

    BalancerSafeMath (library): 0x0F811b1AF2B6B447B008eFF31eCceeE5A0b1d842

    RightsManager (library): 0x4aCB6685da2B5FcB29b1614E71825CE67464440b

    SmartPoolManager (library): 0xb3a3f6826281525dd57f7BA837235E4Fa71C6248

    Smart Pool Factory (CRPFactory): 0xA3F9145CB0B50D907930840BB2dcfF4146df8Ab4

Mumbai (Matic Testnet)

    Core Pool Factory: 0x39D7de7Cf0ad8fAAc56bbb7363f49695808efAf5

    BalancerSafeMath (library) 0x0F811b1AF2B6B447B008eFF31eCceeE5A0b1d842

    RightsManager (library): 0x4aCB6685da2B5FcB29b1614E71825CE67464440b

    SmartPoolManager (library): 0xb3a3f6826281525dd57f7BA837235E4Fa71C6248

    Smart Pool Factory (CRPFactory): 0xA3F9145CB0B50D907930840BB2dcfF4146df8Ab4

    BActions: 0x152b6b3770920be18Cdfe60C85D17C50aeC9Da39

    Exchange Proxy: 0x4d6BFc7463951BAC0e14b1B56A44055F784520CA
** API
*** Migration to Version 1.0
Migration to Version 1.0

The SOR Version 1.0.0-0 introduces breaking changes but should be fairly easy to update. Benefits of updating include - support for multihop swaps and an easier to use wrapper interface as well as more efficient/faster processing.
Overview Of Changes
SOR Library

The SOR is now instantiated as an object:
const SOR = new sor.SOR(Provider, GasPrice, MaxPools, ChainId, PoolsUrl)

    Find further details on parameters here.

SOR now has three main functions:
await SOR.setCostOutputToken(tokenOut)

    Calculates gas cost for swapping token on Balancer.

    The result is used to make more gas efficient swap recommendations.

    Result is cached for future use but can be updated by re-calling.

    Notice that outputToken is tokenOut if swapType == 'swapExactIn' and tokenIn if swapType == 'swapExactOut'

const isSuccess = await SOR.fetchPools()

    This fetches all Balancer pool information and on-chain balances.

    Retrieves pool information from static IPFS file rather than Subgraph.

    Retrieves on-chain balances using custom multicall contract.

    Returns true on success or false on error.

    Information is cached and used for all future processing, this results in fast processing of swaps, i.e. useful when changing swap amounts or types in a UI.

    Accurate/valid swaps rely on upM to date balance information so it is recommended this function is re-called to refresh as needed.

const [swaps, amount] = await SOR.getSwaps(tokenIn, tokenOut, swapType, swapAmount)

    Main function to process trade.

    Will return amount expected and a list of swaps that can be executed on-chain.

ExchangeProxy Contract

A new ExchangeProxy contract that supports multihop swaps has been deployed to the addresses below. For contract details please see Exchange Proxy.

    Mainnet: 0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21

    Kovant: 0x4e67bf5bD28Dd4b570FBAFe11D0633eCbA2754Ec

Further Information

    For more information on SOR functions and to see code examples (including using with ExchangeProxy) please see Development & Examples.

    For a full example demonstrating use of SOR wrapper please see here.

    There is also an example showing how the SOR functions can be used without the wrapper.
*** Events
Events
Events

LOG_CALL is an anonymous event which uses the function signature as the event signature. It is fired by all stateful functions. The following applies to Balancer Core pools. Smart Pools have similar events and modifiers.

#+begin_src solidity
event LOG_CALL(
    bytes4  indexed sig,
    address indexed caller,
    bytes           data
) anonymous;
#+end_src

LOG_SWAP is fired (along with LOG_CALL) for all swap variants.

#+begin_src solidity
event LOG_SWAP(
    address indexed caller,
    address indexed tokenIn,
    address indexed tokenOut,
    uint256         tokenAmountIn,
    uint256         tokenAmountOut
);
#+end_src

LOG_JOIN and LOG_EXIT are fired for each individual token join / exit

#+begin_src solidity
event LOG_JOIN(
    address indexed caller,
    address indexed tokenIn,
    uint256         tokenAmountIn
);
​
event LOG_EXIT(
    address indexed caller,
    address indexed tokenOut,
    uint256         tokenAmountOut
);
#+end_src

Mutex

All stateful functions use either a lock or viewlock function modifier. A mutex places a lock on contract state and prevents any sort of re-entrancy.

#+begin_src solidity
modifier _lock_() {
    require(!_mutex, "ERR_REENTRY");
    _mutex = true;
    _;
    _mutex = false;
}
​
modifier _viewlock_() {
    require(!_mutex, "ERR_REENTRY");
    _;
}
#+end_src
*** API Index
API Index

Function

​swapExactAmountIn(tokenIn, tokenAmountIn, tokenOut, minAmountOut, maxPrice)->(tokenAmountOut, spotPriceAfter)​

​swapExactAmountOut(tokenIn, maxAmountIn, tokenOut, tokenAmountOut, maxPrice)->(tokenAmountIn, spotPriceAfter)​

​joinPool(poolAmountOut, [maxAmountsIn])​

​exitPool(poolAmountIn, [minAMountsOut])​

​joinswapExternAmountIn(tokenIn, tokenAmountIn, minPoolAmountOut)->(poolAmountOut)​

​exitswapExternAmountOut(tokenOut, tokenAmountOut, maxPoolAmountIn)->(poolAmountIn)​

​joinswapPoolAmountOut(tokenIn, poolAmountOut, maxAmountIn)->(tokenAmountIn)​

​exitswapPoolAmountIn(tokenOut, poolAmountIn, minAmountOut)->(tokenAmountOut)​

-

​getSpotPrice(tokenIn,tokenOut)->(spotPrice)​

​getSpotPriceSansFee(tokenIn,tokenOut)->(spotPrice)​

​getSwapFee()->(swapFee)​

-

​bind(token, balance, denorm)​

​rebind(token, balance, denorm)​

​unbind(token)​

​setPublicSwap(bool)​

​setSwapFee(swapFee)​

​finalize()​

​gulp(token)​

-

​isFinalized()->bool​

​isBound()->bool​

​getBalance()->bool​

​getNormalizedWeight(token)->(normalizedWeight)​

​getDenormalizedWeight(token)->(denormWeight)​

​getTotalDenormalizedWeight()->(totalDenormWeight)​

​getNumTokens()->(N)​

​getCurrentTokens()->[Ts]​

​getFinalTokens->[Ts]​

​getController()->address​

-
Functions
Controller and View Functions
isBound

isBound(address T) -> (bool)

A bound token has a valid balance and weight. A token cannot be bound without valid parameters which will enable e.g. getSpotPrice in terms of other tokens. However, disabling isSwapPublic will disable any interaction with this token in practice (assuming there are no existing tokens in the pool, which can always exitPool).
getNumTokens

getNumTokens() -> (uint)

How many tokens are bound to this pool.
getNormalizedWeight

getNormalizedWeight(address token) -> (uint)

The normalized weight of a token. The combined normalized weights of all tokens will sum up to 1. (Note: the actual sum may be 1 plus or minus a few wei due to division precision loss)
getController

getController() -> (address)

Get the "controller" address, which can call CONTROL functions like rebind, setSwapFee, or finalize.
bind

bind(address token, uint balance, uint denorm)

Binds the token with address token. Tokens will be pushed/pulled from caller to adjust match new balance. Token must not already be bound. balance must be a valid balance and denorm must be a valid denormalized weight. bind creates the token record and then calls rebind for updating pool weights and token transfers.

Possible errors:

    ERR_NOT_CONTROLLER -- caller is not the controller

    ERR_IS_BOUND -- T is already bound

    ERR_IS_FINALIZED -- isFinalized() is true

    ERR_ERC20_FALSE -- ERC20 token returned false

    ERR_MAX_TOKENS -- Only 8 tokens are allowed per pool

    unspecified error thrown by token

rebind

rebind(address token, uint balance, uint denorm)

Changes the parameters of an already-bound token. Performs the same validation on the parameters.
unbind

unbind(address token)

Unbinds a token, clearing all of its parameters. Exit fee is charged and the remaining balance is sent to caller.
setPublicSwap

setPublicSwap(bool isPublic)

Makes isPublicSwap return _publicSwap Requires caller to be controller and pool not to be finalized. Finalized pools always have public swap.
finalize

finalize()

This makes the pool finalized. This is a one-way transition. bind, rebind, unbind, setSwapFee and setPublicSwap will all throw ERR_IS_FINALIZED after pool is finalized. This also switches isSwapPublic to true.
gulp

gulp(address token)

This syncs the internal balance of token within a pool with the actual balance registered on the ERC20 contract. This is useful to account for airdropped tokens or any tokens sent to the pool without using the join or joinSwap methods.

As an example, pools that contain COMP tokens can have the COMP balance updated with the rewards sent by Compound protocol. In order for any airdrop balance to be gulped, the token must be bound to the pool. So if a shared pool (which is immutable) does not have a given token, any airdrops in that token will be locked in the pool forever.
setSwapFee

setSwapFee(uint swapFee)

Caller must be controller. Pool must NOT be finalized.
isFinalized

isFinalized() -> (bool)

The finalized state lets users know that the weights, balances, and fees of this pool are immutable. In the finalized state, SWAP, JOIN, and EXIT are public. CONTROL capabilities are disabled.
Trading and Liquidity Functions
swapExactAmountIn

swapExactAmountIn(
    address tokenIn,
    uint tokenAmountIn,
    address tokenOut,
    uint minAmountOut,
    uint maxPrice
)
    returns (uint tokenAmountOut, uint spotPriceAfter)

Trades an exact tokenAmountIn of tokenIn taken from the caller by the pool, in exchange for at least minAmountOut of tokenOut given to the caller from the pool, with a maximum marginal price of maxPrice.

Returns (tokenAmountOut, spotPriceAfter), where tokenAmountOut is the amount of token that came out of the pool, and spotPriceAfter is the new marginal spot price, ie, the result of getSpotPrice after the call. (These values are what are limited by the arguments; you are guaranteed tokenAmountOut >= minAmountOut and spotPriceAfter <= maxPrice).
swapExactAmountOut

swapExactAmountOut(
    address tokenIn,
    uint maxAmountIn,
    address tokenOut,
    uint tokenAmountOut,
    uint maxPrice
)
    returns (uint tokenAmountIn, uint spotPriceAfter)

joinPool

joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)

Join the pool, getting poolAmountOut pool tokens. This will pull some of each of the currently trading tokens in the pool, meaning you must have called approve for each token for this pool. These values are limited by the array of maxAmountsIn in the order of the pool tokens.

If the balances you are adding are 10% of the current pool balances, then you should set poolAmountOut as 10% of the current poolSupply. Bear in mind that the proportions of the different underlying token balances might change until your transaction gets mined: therefore you should have a buffer to avoid the transaction being reverted. We usually suggest 1% if you use high gas prices for fast confirmation. So calculate poolAmountOut as described above with 99% of the maxAmountsIn.
exitPool

exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)

Exit the pool, paying poolAmountIn pool tokens and getting some of each of the currently trading tokens in return. These values are limited by the array of minAmountsOut in the order of the pool tokens.

To define minAmountsOut, consider the percentage of the pool liquidity you are withdrawing, which is poolAmountIn/poolSupply and multiply that percentage by each of the underlying pool token balances. If you expect to receive say 10 units of each of the underlying tokens in the pool, consider setting minAmountsOut as 9.9 to allow for variations in the balances proportions that may happen before your transaction gets mined.
joinswapExternAmountIn

joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut) -> (uint poolAmountOut)

Pay tokenAmountIn of token tokenIn to join the pool, getting poolAmountOut of the pool shares.
exitswapExternAmountOut

exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn) -> (uint poolAmountIn)

Specify tokenAmountOut of token tokenOut that you want to get out of the pool. This costs poolAmountIn pool shares (these went into the pool).
joinswapPoolAmountOut

joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn) -> (uint tokenAmountIn)

Specify poolAmountOut pool shares that you want to get, and a token tokenIn to pay with. This costs tokenAmountIn tokens (these went into the pool).
exitswapPoolAmountIn

exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut) -> (uint tokenAmountOut)

Pay poolAmountIn pool shares into the pool, getting tokenAmountOut of the given token tokenOut out of the pool.
*** UML Docs
UML Docs

    ​BPool​ https://drive.google.com/file/d/1qta1KBLRq_8GZJ_dTL0zo2HYPD_dYUrH/view?usp=sharing

    ​CRPFactory​ https://drive.google.com/file/d/1Aj8N-oE0iQ4Zyv1fWqglC5GIenrvq2EP/view?usp=sharing

    ​BadToken (used for CRP token vetting) https://drive.google.com/file/d/1y9QqRrk2lms_tcBlhynMaZJk7iFNyz_8/view?usp=sharing
** Guides
*** Interact via Etherscan
Interact via Etherscan

Our UI allows for any liquidity provider to withdraw liquidity by clicking on the button "Remove Liquidity" on the detailed pool view page. This article though focus on how to withdraw liquidity without our UI (in case it is down or inaccessible). To do that we'll be using Etherscan.io.

If a pool is still private (i.e. not finalized), you can withdraw liquidity by simply unbinding each of its tokens:

In case we’re dealing with a shared pool, things look a bit different. Once a pool is finalized, a BPT (Balancer Pool Token) associated with that pool is created with an initial supply of 100 units (always with 18 decimals). From that point on, ownership of the pool is tracked by BPT: holders are pro-rata owners of the pool’s liquidity.

Just to illustrate, this is how a BPT distribution looks like for the more popular “75-MKR / 25-WETH” pool:

​https://etherscan.io/token/tokenholderchart/0x987D7Cc04652710b74Fff380403f5c02f82e290a​

This means account 0x821a...46 owns about 25% of all the MKR and WETH held by the pool, and they may withdraw those tokens from the pool at any moment.

The simpler way to remove liquidity (either fully or partially) from a shared pool is of course to navigate to the pool’s page and click “Remove Liquidity”:

​https://pools.balancer.exchange/#/pool/0x987D7Cc04652710b74Fff380403f5c02f82e290a​
Bonus Points: Removing Liquidity from a Shared Pool via Etherscan

If you don’t want to depend on Balancer’s website being always operational; you may choose to run it locally (it’s open-source).

But maybe you want to understand a bit better what happens under the hood during a withdrawal.

So let’s use Etherscan to explore our BTC++/DAI/USDC pool.

The function we’re looking for is called exitPool. The parameters expected are:

    the amount of BPT (in base units, so 1 is actually 10^18) you’re giving back to the pool in exchange for the underlying tokens; and

    the minimum amount of each underlying token (also in base units, separated by commas) you expect to receive (transaction fails if any minimum isn’t met).

To withdraw all your liquidity in one transaction, simply give back to the pool your full BPT balance (in our case it’s a bit over 1184.12 BPT). Remember all BPTs have 18 decimals. To accept any amount of underlying tokens, just set all minimum amounts to zero. Since we have 3 underlying tokens, minAmountsOut has 3 zeros: "0,0,0".

And what is the point of getting to know the actual function being called and its parameters?

One use case that comes to mind is to keep handy (e.g. saved on a mobile phone) a pre-signed transaction withdrawing all your funds from a pool. This would be useful in an emergency: you could immediately broadcast your transaction, from any device (that doesn’t hold the private key to that account).


After clicking “Write” at the figure above, you can copy the DATA field shown in Metamask, and use it to craft an offline transaction using MyEtherWallet.
*** Using the SOR
#+ATTR_ORG: :width 500
[[https://gblobscdn.gitbook.com/assets%2F-LtMQYB90ZuO38aKDyto%2F-LwEaomQK1lFvmBPZd1v%2F-LwEe7bS34ZPRiQL01NN%2Fsor_diagram.jpg]]
*** Creating a Shared Balancer Pool
Creating a Shared Balancer Pool
Setting up a proxy

All the interactions to add liquidity or to create Balancer pools on our UIs happen through a proxy. This way our UI can simplify the UX by avoiding token approvals on every new pool the user interacts with.

You'll be asked to setup a proxy when your address is interacting with our UI for the first time. For example, when you click on "Create Pool" on our pool management interface:

After clicking on "Create Pool," you'll see the setup button:

The proxy setup waits for 10 confirmations to be extra safe.

An interesting observation: we use the same DSProxy smart contracts as MakerDAO, so if you have an MCD vault already you won't need to create another proxy!
Shared Pool Creation

At the moment you can only create shared pools on our UI. There will be soon the option to create and manage private pools. As a reminder:

    shared pools are open to anyone to join by adding liquidity and getting BPTs (Balancer Pool Tokens) in return, but all the pool parameters are immutable

    private pools only allow the owner to add liquidity to the pool, but all its parameters are flexible. So the owner of the private pool can change the swap fees, pause trades, add/remove tokens, change token weights, etc.

A Balancer pool allows up to 8 tokens and the weights have to be between 2% and 98%. The swap fee can be between 0.0001% and 10%.

If the token you want to add is not listed on the token picker panel, you can add any custom token by pasting its address in the search field.

IMPORTANT: make sure that the custom token you are adding complies with the ERC20 standard. For example it has to allow 0 value transfers and the transfer function must return a boolean. You can check if the token you are adding is on any of these two lists that gather many tokens that are not ERC20-compliant:
Missing return value bug — At least 130 tokens affected
tl;dr There is a critical bug in a lot of ERC20 token contracts that surfaced due to a recent Solidity update.
medium.com
sec-bit/awesome-buggy-erc20-tokens
A Collection of Vulnerabilities in ERC20 Smart Contracts With Tokens Affected - sec-bit/awesome-buggy-erc20-tokens
github.com

These lists though are NOT exhaustive, so make sure you check your token is compatible before creating a pool with it to avoid losing your tokens forever.
*** CRP Tutorial
CRP Tutorial

Similar to Core Pools, Configurable Rights Pools are created from a public factory. Refer to Addresses to find the contract on your network of choice.

To deploy a new Configurable Rights Pool, call newCRP on the CRPFactory. This function takes three parameters (cheating a bit, since two of them are big structs):

function newCrp(
    address factoryAddress,
    ConfigurableRightsPool.PoolParams calldata poolParams,
    RightsManager.Rights calldata rights
)
    external
    returns (ConfigurableRightsPool)

The factoryAddress is that of the BFactory (see Core Concepts). The Configurable Rights Pool is the Smart Pool "wrapper" around the underlying Core Pool (BPool). You (caller of newCRP) are the controller of the Smart Pool. The Smart Pool is the controller of the Core Pool. So the Smart Pool needs to deploy a Core Pool - and requires the BFactory to do that.

The next argument is PoolParams - this is where you define the structure and basic parameters of the pool, such as the tokens it will hold, their initial weights and balances, and the swap fee.

struct PoolParams {
    // Balancer Pool Token (representing shares of the pool)
    string poolTokenSymbol;
    string poolTokenName;
    // Tokens inside the Pool
    address[] constituentTokens;
    uint[] tokenBalances;
    uint[] tokenWeights;
    uint swapFee;
}

Since the Balancer Pool Tokens are themselves ERC20 tokens, they have symbols and names. You can set both when creating your pool.

The tokens must be addresses of conforming ERC20 tokens. Balances and weights are expressed in Wei - and the weights are denormalized, not percentages. Valid denormalized weights range from 1 to 49, since the maximum total denormalized weight is 50. (This corresponds to a percentage range from 2% to 98%: 1/(1+49) = 2%; 49/(1+49) = 98%)

Note that balances must be "normalized" for the number of decimals in the token. For instance, USDC has 6 decimals, so "10" is "10000000" - not "10000000000000000000"!

Note that if you're going to be doing gradual weight updates, using denorm totals near the maximum 50 can be problematic! It is possible for pokeWeightsto fail if the weights are 45/5, since the contract will never allow the total to go over 50 - even temporarily during an intermediate step. Unless you truly need the full range, best practice is to use a lower total, like 40; e.g.; for 90/10, use 36/4. (If you need to use extreme weights, put tokens whose weights should go down first in the array; that way the weight reductions will be processed before the increases.)

The swap fee is also expressed in Wei, as a percentage. For instance, toWei("0.01") means a 1% fee.

Finally, the Rights struct defines the permissions.

struct Rights {
    bool canPauseSwapping;
    bool canChangeSwapFee;
    bool canChangeWeights;
    bool canAddRemoveTokens;
    bool canWhitelistLPs;
    bool canChangeCap;
}

Note that if you are whitelisting LPs, and intend for the whitelisted users to Add Liquidity through the Balancer GUI, you will need to whitelist their DSProxy addresses - not their wallet address. (The DSProxy address can be found at the bottom of the wallet page. New users will need to create a DSProxy before adding liquidity.)

At this point (after calling newCRP), we have a deployed Configurable Rights Object with all its permissions and parameters defined. But we can't do much with it - mainly because there is no Core Pool yet. We need to deploy a new Core Pool, with our Smart Pool as the controller, by calling createPool(initialSupply). (There is also an overloaded version of createPool; more on that later.)

We've already defined the tokens and balances we want the pool to hold. When we call createPool with a value for initialSupply, it will mint initialSupply Balancer Pool Tokens (BPTs) and transfer them to the caller, simultaneously pulling the correct amount of collateral tokens into the contract. (They end up in the Core Pool, passed through the CRP.)

To accomplish this, we need to allow the CRP to spend our collateral tokens, before calling createPool. For an example three-token pool, we might write:

const MAX = web3.utils.toTwosComplement(-1);
​
// crpPool was returned from CRPFactory.newCRP()

await weth.approve(crpPool.address, MAX);
await dai.approve(crpPool.address, MAX);
await xyz.approve(crpPool.address, MAX);
​
// consume the collateral; mint and xfer 100 BPTs to caller
await crpPool.createPool(toWei('100'));

Now we're in business! The pool will already be set up for public swapping, and depending on the permissions settings, possibly public liquidity provision as well. The Core Pool will show up on the Exchange GUI.

Refer to Exchange and Reward Listing for instructions on adding any new tokens you might be introducing to the Exchange GUI, and making them eligible for BAL governance tokens. Earnings are distributed weekly, and are not applied retroactively, so you'll need to have the token approved by 00:00 UTC the Monday before you launch your pool.

If your smart pool is eligible for BAL, earnings will be redirected to LPs - as long as you create the pool through our standard factory. If you create a new pool using a different factory, or deploy a pool contract directly, you will need to apply for a redirect or redistribution. (You will also need a redirect if your CRP controller is a contract that holds BPTs, and doesn't have a way to withdraw them.)

The process for the redirect is to make a pull request to update this file in our script repository with the CRP and your wallet address, along with proof that you own the pool (e.g., the CRP deployment transaction hash). Here's an example request. Similarly, if you have a CRP and want to handle the redistribution differently, you can make a pull request to update this file.

Here is a diagram detailing how we compute BAL mining earnings.

On a related note, while it is possible to send tokens directly to a core pool contract - as long as they are in the pool, you they can be recovered with gulp() - this is not the case for smart pools! Any tokens sent directly to the CRP contract will be unrecoverable. (This can happen in some circumstances even without a direct transfer, such as airdrops to token holders.)

Note that there is also an overloaded version of createPool, where you can specify additional parameters related to updateWeightsGradually.

function createPool(
    uint initialSupply,
    uint minimumWeightChangeBlockPeriod,
    uint addTokenTimeLockInBlocks
)

If the pool you're creating doesn't have permission to change weights, or you accept the default values of the time parameters, you can just use the single-argument version.

initialSupply can be set to a value of your choice - within min/max limits (currently 100 - 1 billion, in ether units).

minimumWeightChangeBlockPeriod enforces a minimum time between the start and end blocks of a gradual update. addTokenTimeLockInBlocks is used when adding a token (if you have the AddRemoveTokens permission), as the minimum wait time between committing a new token, and applying it (i.e., actually adding it to the pool). There is one additional constraint: minimumWeightChangeBlockPeriod >= addTokenTimeLockInBlocks.

These parameters have default values, and can only be changed by overriding them in this version of createPool. The addTokenTimeLock defaults to 500 blocks (~ 2 hours), and the blockPeriod defaults to 90,000 (~ 2 weeks). If you want to use different minimum values, be sure to set them in createPool, since they are immutable thereafter!

Also note that these only apply to gradual updates. The controller can call updateWeight directly at any time, as long as no gradual update is in progress.

You can use this simulator to explore how weight changes and updates work, estimate slippage and impermanent loss, etc. There is also a demo video illustrating the simulator functionality.

Complex functionality = lots of simulators! This one helps you calculate single- and multi-asset entry and exit.
**** Liquidity Bootstrapping Example
Liquidity Bootstrapping Example

Let's walk through a complete example, using the Liquidity Bootstrapping use case.

First, we give the token a symbol and name, set the basic pool parameters, and determine the permissions. All we really need to be able to do is change the weights, so we can set all the other permissions false.

As noted earlier, setting the permissions as strict as possible minimizes the trust investors need to place in the pool creator. Liquidity providers for this pool can rest assured that the fee can never be changed, no tokens can be added or removed, and they cannot be prevented from adding liquidity (e.g., by being removed from the whitelist, or having the cap lowered).

Note that balances must be "normalized" for the number of decimals in the token. For instance, USDC has 6 decimals, so "10" is "10000000" - not "10000000000000000000"!

// XYZ and DAI are addresses
// XYZ is the "project token" we're launching
​
const poolParams = {
    tokenSymbol: 'LBT',
    tokenName: 'Liquidity Bootstrapping Token',
    tokens: [XYZ, DAI],
    startBalances: [toWei('4000'), toWei('1000')],
    startWeights: [toWei('32'), toWei('8')],
    swapFee: toWei('0.005'), // 0.5%
}
​
const permissions = {
    canPauseSwapping: false,
    canChangeSwapFee: false,
    canChangeWeights: true,
    canAddRemoveTokens: false,
    canWhitelistLPs: false,
    canChangeCap: false
};

Next, we use these structs to deploy a new Configurable Rights Pool (and the underlying Core Pool).

// If deploying locally; otherwise use the published addresses
// This is the factory for the underlying Core BPool
bFactory = await BFactory.deployed();
​
// This is the Smart Pool factory
crpFactory = await CRPFactory.deployed();
​
// Static call to get the return value
const crpContract = await crpFactory.newCrp.call(
    bFactory.address,
    poolParams,
    permissions,
);
​
// Transaction that actually deploys the CRP
await crpFactory.newCrp(
    bFactory.address,
    poolParams,
    permissions,
);
​
// Wait for it to get mined
const crp = await ConfigurableRightsPool.at(crpContract);
​
// Creating the pool transfers collateral tokens
// Must allow the contract to spend them
await dai.approve(crp.address, MAX);
await xyz.approve(crp.address, MAX);
​
// Create the underlying pool
// Mint 1,000 LBT pool tokens; pull collateral into BPool
// Override with fast block wait times for testing purposes
//   (Defaults are 2 hours min delay / 2 weeks min duration)
await crp.createPool(toWei('1000'), 10, 10);

At this point we have an initialized pool. The admin account has 1,000 LPTs, and the underlying BPool is holding the tokens. The pool is enabled for public trading and adding liquidity.

To facilitate the token launch - with low slippage, low initial capital, and stable prices over time, per the paper referenced above - we want to gradually "flip" the weights over time. We start with the project token at a high weight (32/(32+8), or 80%, and collateral DAI at 20%. At the end of the launch, we want XYZ at 20%, and DAI at 80%. We accomplish this by calling updateWeightsGradually; we're allowed to do this because the canChangeWeights permission was set to true.

// Start changing the weights in 100 blocks
const block = await web3.eth.getBlock('latest');
const startBlock = block.number + 100;
const blockRange = 10000;
​
// "Flip" the weights linearly, over 10,000 blocks
const endBlock = startBlock + blockRange;
​
// Set the endWeights to the reverse of the startWeights
const endWeights = [toWei('8'), toWei('32')];
​
// Kick off the weight curve
await crp.updateWeightsGradually(endWeights, startBlock, endBlock);

Of course, smart contracts can't change state by themselves. What updateWeightsGradually actually does is put the contract into a state where it will respond to the pokeWeights call by setting all the weights according to the point on the "weight curve" corresponding to the current block. (It will revert before the start block, and set the weights to their final values if called after the end block.)

// Sample code to print the current weights,
// Then call pokeWeights to update them
​
for (i = 0; i < blockRange; i++) {
    weightXYZ = await controller.getDenormalizedWeight(XYZ);
    weightDAI = await controller.getDenormalizedWeight(DAI);
    block = await web3.eth.getBlock("latest");
    console.log('Block: ' + block.number + '. Weights -> XYZ: ' +
        (fromWei(weightXYZ)*2.5).toFixed(4) + '%\tDAI: ' +
        (fromWei(weightDAI)*2.5).toFixed(4) + '%');
​
    // Actually cause the weights to change
    await crp.pokeWeights();
}

There are many subtleties; for instance, you could implement a non-linear bootstrapping weight curve by calculating the weights off-chain and setting them directly. For a comprehensive set of tests that demonstrate all features of the Configurable Rights Pool, see our GitHub.
*** Smart Pool Use Cases
Smart Pool Use Cases

Here we detail several applications of the core Configurable Rights Pool, and show how you would configure your custom pool (on creation from the factory), to accommodate each use case. (Eventually we will have a GUI wizard to guide you through this process.)

The use cases we cover here are:

    ​Liquidity Bootstrapping (token launch)

    ​Swing Trading Pool (Index fund)

    ​Smart Treasury (Buyback & Make)

    ​Perpetual Synthetic Pool​

    ​Investors' Club (KYC)

    ​Experimental (Capped)

For each type of pool, we will provide a typical configuration appropriate for the use case, enabling enough flexibility to accomplish all the required interventions, while minimizing the trust required of the pool operator.
**** Liquidity Bootstrapping Pool
Liquidity Bootstrapping Pool

Here again is the article describing this common case - basically a sustainable 2020 reboot of the 2017 "ICO" - minus the worst of the legal and regulatory issues. (The latest term seems to be IDO - Initial DEX Offering.)

The idea is to launch a token with low capital requirements, by setting up a two-token pool with a project and a collateral token. The weights are initially set heavily in favor of the project token, then gradually "flip" to favor the collateral coin by the end of the sale. The sale can be calibrated to keep the price more or less steady (maximizing revenue), or declining to a desired minimum (e.g., the initial offering price).

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

Pausing swapping is an optional feature here. You might want to halt trading for various reasons (e.g., stronger than expected demand is driving up the price, and people are selling tokens back to the pool for profit instead of buying them). There isn't much of a trust issue here - the purpose is to sell tokens, so the pool operator has an incentive to leave swapping enabled.

In a token sale, you want to keep fees low to encourage trading; there's really no reason to change it. So best practice would be set it to the minimum on creation and don't enable changing it. You want to enable as few rights as possible. More rights = more possible manipulation from the pool operator = more trust required.

Since the core of the strategy is changing weights, you absolutely need to enable that right.

The add/remove tokens right depends on your future intentions, since there are two ways to remove your liquidity at the conclusion of the sale. If this is a one-off auction, you can enable the right, and redeem through two "removeToken" calls. This is simple, but destroys the pool.

If you want to re-use the pool (e.g., there are "phases" or multiple releases), you can leave this right disabled, and retrieve the proceeds through repeated calls to exitPool. You cannot remove 100% of the liquidity through exitPool, since token balances cannot go to zero, and single asset exit is limited to 1/3 of the total balance per transaction. To add more project tokens, you would need to add yourself to the whitelist, and joinPool.

In a token sale (vs an investment pool), you don't want anyone else providing liquidity. Only the pool creator should be issued pool tokens, and only they should be able to redeem the proceeds at the end. This is most easily accomplished by using the whitelist. If you enable this right and don't add anyone to the whitelist, no one can "join" the pool.

You could also prevent others from adding liquidity through the cap right. If you enable it, the cap will be set to the initial supply, which has the same effect as the whitelist. However, you will need to be careful when you redeem the pool tokens at the end of the sale, since any token redemption would reduce the supply below the cap and present a window for others to join the pool. To prevent this, you could set the cap to 0 before withdrawing the proceeds.

Watch out for some subtleties here! Some LBP owners might want to allow public LPs; Uniswap does, after all. If you don't have the whitelist right or the cap right, anyone can add liquidity. This means the LBP controller is not the sole "owner" of the pool, since others also have pool tokens. Consequently, if the controller tries to destroy the pool after the sale with calls to removeToken -- it won't work, because they won't have enough pool tokens. This makes sense - otherwise, pool owners could "drain the pool" just by calling removeToken!

Depending on the balances, removing one of the tokens "might" work. For instance, say you're at the end of the sale, so you have a small balance of your project token, and a large balance of DAI. You would probably have enough pool tokens to remove the project token. At that point, you would have a 1-token pool of DAI, and -- unless all the other LPs exit the pool - you would not be able to call removeToken on DAI. You could only exitPool with whatever pool tokens you had - and the remaining DAI balance would represent the amount of liquidity added by the other LPs.

So the upshot of all this is if you intend to allow public LPs on your LBP, maybe you don't need the add/remove token right. (This would make your pool more trustless.)

It could also happen that you don't have enough to call removeToken on either. For instance, if a purchaser sold a large amount of your project token back into the pool, or someone added a large amount of liquidity. If you need to call removeToken to reuse the pool, remember you can always "buy out" the other LPs. If you're 250 pool tokens short of what you need to remove the project token, you can join with 250 pool tokens' worth of DAI, after which removeToken will succeed. All the other LPs wishing to withdraw their liquidity would get their proceeds entirely in DAI.

This is something to keep in mind when investing in Balancer Pools in general - when you withdraw liquidity, you will get the token(s) in whatever proportion they are in at the time of withdrawal. If the pool controller has the add/remove token right, they might not even be the same tokens. (This would surely be the case for "perpetual synthetic" pools that add and remove synthetics as they are minted and expire.)

One other important consideration is the "block time" settings - the minimum time between weight updates, and the minimum duration of each gradual update. These times default to 2 hours and 2 weeks, meaning the weights cannot change faster than every 2 hours, and once you start a gradual update, you cannot add a token or do a manual update for 2 weeks.

You can make these periods arbitrarily short (even zero), but then the pool operators have greater control, and more trust is required.

Also keep in mind that contracts cannot change state by themselves - weights only change when someone calls pokeWeights. A common mechanism is for the pool operator to set up something like a cron job to call it automatically, though it is a public function that anyone can call.

Note that pokeWeights changes weights, but not balances - therefore, it can change the price (albeit only along the trajectory set by the last call the updateWeightsGradually).

The controller function updateWeight changes weights directly - but not the price. This means it must also adjust the balances at the same time (i.e., transfer tokens). So the controller can set weights arbitrarily -- but not while an updateWeightsGradually is running. And they must have the tokens available to do it.

Though most LBPs are two-token pools (e.g., a project token and a single reserve currency, usually a stable coin), it is possible to have three tokens, or more. For instance, a stable coin and WETH, in addition to the project token. One project was recently launched that way. There is a simulator available for this case.

​
**** Swing Trading Pool
Swing Trading Pool

Recall the basic design of investment pools: traders profit through arbitrage opportunities, created when "internal" prices diverge from token market values, and pay fees for the privilege, which accrue to the liquidity providers.

There is a natural trade-off here. Low fees and high trade volume leads to impermanent loss for liquidity providers; the arbers extract more value than they're adding in fees. On the other hand, high fees discourage trading altogether, so lower rates might actually generate more total revenue.

One strategy to limit impermanent loss and maximize return is to create a pool that acts more like an index fund in traditional finance. You want something immune to day-to-day price fluctuations - so during "quiet" periods is equivalent to HODLing, since the balances don't change without trading. However, when the external market shifts significantly, the portfolio should "rebalance" through arbitrage in a manner favorable to both liquidity providers and traders. Here's a paper describing the concept.

Say you have a volatile asset (e.g., a basket of different types of wrapped BTC), which can swing 4-5% on a boring day at the office, but makes big 10%+ moves relatively rarely. If you created a pool of such tokens with a swap fee above the "froth" (e.g., 7%, 8%, even the maximum 10%), it would be static most of the time. Yet on really big moves, the pool would be guaranteed to sell high and buy low - outperforming HODLing.

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

You could implement this pool with no rights enabled at all (= no trust required). In which case you could just use a traditional BPool, and don't need a Smart Pool at all. However, you might want to change the swap fee to adjust to volatility (e.g., if volatility increases to where daily fluctuations are triggering lots of trades), you might want to raise the fee. Conversely, if volatility is lower than expected, you might want to lower it.

You might create an off-chain monitor that would update the fee dynamically in response to a volatility measure. Or the fee could be controlled through a DAO or less formal community voting mechanism.
**** Smart Treasury
Smart Treasury

This is an emerging use case, based in large part on this article by Placeholder (see image below, from that article, and the related simulator.)
Automatic buyback machine, token issuance pool, and liquidity provider (9/17/20; Joel Monegro)

Here we have a network of producers and consumers, where users pay for services with a fee token, and that income is used to pay producers in project tokens. Since the treasury is a Smart Pool, excess ETH would raise the price and cause the market to swap in project tokens for ETH until it the treasury is rebalanced - effectively an automatic buyback.

The treasury can also buyback on a schedule by adding liquidity (e.g., depositing reserve currency income), and replenishes the market supply through issuance to producers. Maintaining the treasury as a Balancer pool means the market has guaranteed liquidity through the protocol itself.

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

The Smart Pool Treasury is by definition the only liquidity provider, so the only right you really need is whitelisting (only the controller would be on the whitelist, enabling buybacks). Change swap fee could be used to modulate trading to some degree if necessary. If you want to be able to prevent trading against the pool altogether, you could enable pause swapping (though since this is the mechanism of automatic buyback, it should be used sparingly).
**** Perpetual Synthetic Pool
Perpetual Synthetic Pool

Synthetic tokens, through the efforts of UMA and others, are coming into their own, grabbing the spotlight and bringing a type of derivative familiar from the traditional financial markets to crypto.

There are already balancer pools featuring synthetics (I would link to one, but it would be out-of-date in a month.) One UMA synthetic token current as of this writing is yUSD-OCT20.

Note that when UMA supports perpetual synthetics natively - tokens with no expiration date - this gets easier. At that point, you would not need to add or remove tokens monthly, and could simply hold them in a pool, perhaps rebalancing periodically.

Current priceless synthetics have an expiration date, and the most common implementations expire monthly. It is now common practice to create a standard BPool with a synthetic expiring a month or two in the future, and a collateral token like USDC. When the synthetic expires, people generally withdraw liquidity from the current month's pool, and add it to the next month. One of the issues with this is the gas costs incurred by all these rollovers. Your investment would need to be big enough to still profit, after fees.

One solution would be a "rolling synthetic" Smart Pool. There are many possible implementations. One is a 2-token pool with the current synthetic and a collateral coin. Near the end of the month, the pool operator would add the next month's token, and then, some time after expiration, remove the previous token.

Note that the pool creator would need to have enough pool tokens to be able to call removeToken (which burns pool tokens). The bigger the total supply, they more they need, so if a lot of other LPs joined, the creator might need to deposit more liquidity in order to swap out synthetics.

Alternatively, a pool operator could create a pool with two synthetics - the current and next month's tokens. Initially the weights would favor the current month, but over the course of the month (tracking "implied volatility"), the weights would "flip," so that the situation was reversed near the end of the month, with next month's token weighted highly, and the current month's heavily discounted.

These could even be combined, adding the future month's synthetic a bit in advance, and removing the expired month's synthetic after a redemption period.

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

You need to change weights, and probably also add/remove tokens, unless you make a new pool each month. If you're adding and removing tokens, you would probably want to be able to pause swapping during these operations, or during redemption periods.
**** Investors' Club
Investors' Club

With Smart Pools, it is possible to restrict liquidity providers to a defined group. For instance, accredited investors, or those who have complied with a KYC process (e.g., for STOs). However, the privileged addresses could be determined by anything - holders of certain tokens, those who participated in community building or voting, winners of a "lottery" for investment slots, etc.

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

The mechanism for this is the LP whitelist, which has to be enabled. The controller can add or remove addresses from this list, and only those addresses are permitted to join pools. (NB: the pool controller cannot prevent swaps - other than by using the pauseSwapping right, which halts it altogether for everyone. Also, the pool tokens are ERC-20 conforming, so do not prevent transfers. It's the LP's responsibility to keep track of their tokens, and not transfer them to unauthorized parties.)

Depending on the use case, the pool operator might need to pause swapping (e.g., during a signup or redemption period). If it is an STO, there might also be hard- or soft caps on the value of the pool. If this is the case, the cap right would also need to be enabled. See Experimental.

**** Experimental
Experimental

If you've been in the crypto space since 2017, you'll remember well the ICO hype. People were throwing money at every new token with a website. (If you're just a bit older, you'll remember the .com boom of '99 as well - when it was every company with a website.)
.COM -> ICO -> DeFi

We are now seeing the same phenomenon in DeFi. Cross out "token," insert "protocol." A high school student at a hackathon can deploy a contract written over a sleepless weekend - and by Monday there's $7 million dollars locked in it!

This is dangerous, to say the least. Even worse, with everything public and open source, even if you don't intend to release something - literally anyone can copy and deploy it for you.

Capped pools are a way to - if not completely eliminate the danger - at least limit the potential damage. Furthermore, it is flexible enough to allow the pool controller to halt and resume the influx of new capital at any time, for any reason.

Legend: required; not required; optional

Rights configuration:

    canPauseSwapping

    canChangeSwapFee

    canChangeWeights

    canAddRemoveTokens

    canWhitelistLPs

    canChangeCap

Change cap is required, of course. You might also want to be able to control (or at least influence) trading through pausing or setting fees, but that is optional.

The "cap" refers to the total supply of pool tokens. Recall that pool tokens are themselves ERC-20s, so this corresponds to the totalSupply().

The cap is always there, but if the right is not enabled, it is always set to MAX (i.e., unlimited). If the right is enabled, the cap is set to the initial supply on createPool(). Immediately after creating the pool, no one can add liquidity (including the controller).

To allow others to join the pool, the controller can set the cap higher - for instance, to a supply corresponding to a given total underlying asset value. At any point, they can raise or lower the cap - including to 0 (to "freeze" all new investment), or unlimited (if confidence is high and it's party time).
*** Testing on Kovan
Testing on Kovan
Overview

This guide will walk through the process of interacting with Balancer on Kovan directly with the smart contracts along with additional tooling such as the subgraph and SOR.
Setup

This guide will use seth - a tool built by Dapphub to interact directly with smart contracts. To install, run the below command. Note: the Dapp Tools suite installs Nix OS.

curl https://dapp.tools/install | sh

If this doesn't work, you might need to install nix manually first:
curl -L https://nixos.org/nix/install | sh

Nix is broken on MacOS Catalina. To fix, follow the steps at: https://github.com/NixOS/nix/issues/2925#issuecomment-539570232​

Follow the remaining steps at: https://github.com/dapphub/dapptools/tree/master/src/seth#example-sethrc-file in order to select the SETH_CHAIN and address / key.

Run the below lines in your terminal to setup environment variables that will be used later in the guide.

export BFACTORY=0x8f7F78080219d4066A8036ccD30D588B416a40DB
export FAUCET=0xb48Cc42C45d262534e46d5965a9Ac496F1B7a830
export WETH=0xd0A1E359811322d97991E03f863a0C30C2cF029C
export DAI=0x1528F3FCc26d13F7079325Fb78D9442607781c8C
export MKR=0xef13C0c8abcaf5767160018d268f9697aE4f5375
export USDC=0x2F375e94FC336Cdec2Dc0cCB5277FE59CBf1cAe5
export REP=0x8c9e6c40d3402480ACE624730524fACC5482798c
export WBTC=0xe0C9275E44Ea80eF17579d33c55136b7DA269aEb
export BAT=0x1f1f156E0317167c11Aa412E3d1435ea29Dc3cCE
export SNX=0x86436BcE20258a6DcfE48C9512d4d49A30C4d8c4
export ANT=0x37f03a12241E9FD3658ad6777d289c3fb8512Bc9
export ZRX=0xccb0F4Cf5D3F97f4a55bb5f5cA321C3ED033f244

Acquire Test Funds

All pools use wrapped ETH. In order to get WETH, either use the faucet at https://faucet.kovan.network and then deposit() into the WETH contract. Or the faucet below may have some available WETH.

For all other tokens, Balancer has deployed a set of test tokens and a faucet on Kovan. The guide below will use DAI & MKR, but feel free to use any of the available tokens. An user can call drip once per day per token.

Token


Address


Drip Amount

WETH


​0xd0a1e359811322d97991e03f863a0c30c2cf029c​


0.25 WETH

DAI


​0x1528F3FCc26d13F7079325Fb78D9442607781c8C​


100 DAI

MKR


​0xef13C0c8abcaf5767160018d268f9697aE4f5375​


0.5 MKR

USDC


​0x2F375e94FC336Cdec2Dc0cCB5277FE59CBf1cAe5​


100 USDC

REP


​0x8c9e6c40d3402480ACE624730524fACC5482798c​


10 REP

WBTC


​0xe0C9275E44Ea80eF17579d33c55136b7DA269aEb​


0.02 WBTC

BAT


​0x1f1f156E0317167c11Aa412E3d1435ea29Dc3cCE​


500 BAT

SNX


​0x86436BcE20258a6DcfE48C9512d4d49A30C4d8c4​


85 SNX

ANT


​0x37f03a12241E9FD3658ad6777d289c3fb8512Bc9​


200 ANT

ZRX


​0xccb0F4Cf5D3F97f4a55bb5f5cA321C3ED033f244​


400 ZRX

Call drip on the faucet specifying a token address:

seth send $FAUCET "drip(address)" $DAI

Confirm that you received test tokens:

seth --from-wei $(seth --to-dec $(seth call $DAI "balanceOf(address)" $ETH_FROM))

Repeat the above steps for any additional tokens you would like to interact with on the Balancer test deployment.
Pool Creation

Next we're going to create a new pool. This guide will create a 50% WETH, 25% DAI, 25% MKR pool. Feel free to use any of the tokens

Some tokens do not use the standard 18 decimals. Be aware of balance calculations and weights when using tokens with different decimals.

USDC - 6
WBTC - 8
Any Compound token - 8

seth send --gas 5000000 $BFACTORY "newBPool()"

Make note of the created contract address and set the below BPool variable to the address returned. This can be found on etherscan by looking at the internal txs of the tx hash.

export BPOOL=0x... (address returned from previous step)

BPOOL=0x... (address returned from previous step)

Token approvals are needed for any tokens you plan on adding to the pool. Approvals per pool is only required when interacting with the contracts directly. The frontend interfaces will all use a proxy so there will only be 1 time approvals to interact with all pools in the Balancer ecosystem.

amount=$(seth --to-uint256 $(seth --to-wei 1000000 ether))
seth send $WETH "approve(address,uint256)" $BPOOL $amount
seth send $DAI "approve(address,uint256)" $BPOOL $amount
seth send $MKR "approve(address,uint256)" $BPOOL $amount

After all approvals are confirmed, tokens are bound to a specific pool by calling ``bind(address token, uint balance, uint denorm)```

denorm is the denormalized weight for the token being added. Weights are stored in this fashion to prevent unnecessary gas costs of recalculating weights every time a new token is added. In our example, since we want 50% WETH, 25% DAI, and 25% MKR we can use the following denormalized weights: 10, 5, 5. (Note: the denorm weights are scaled to Wei; i.e., "1" = 10^18, to allow for non-integer weights.)

Valid denorm values range from 1 to 50 - and the total sum must be <= 50. In practice, to ensure the math always works, best practice is to use a smaller range, such as 2 - 40.

# Bind 1 WETH with a denormalized weight of 10
amount=$(seth --to-uint256 $(seth --to-wei 1 ether))
weight=$(seth --to-uint256 $(seth --to-wei 10 ether))
seth send $BPOOL "bind(address, uint256, uint256)" $WETH $amount $weight

Since we also want to bind DAI and MKR, and we know the desired weights, we have to calculate a balance for each token such that the internal token prices calculated by the protocol - based only on the weights and balances - match the external market prices of the tokens. (Otherwise, there would be immediate, unintended arbitrage opportunities as soon as you created the pool.) This example will assume the following asset prices: ETH - $200, MKR - $400, DAI - $1.

Since we bound 1 WETH at a price of $200 and we want that to be 50% of the pool, we want to bind $100 of both DAI and MKR.

# Bind 100 DAI with a denormalized weight of 5
amount=$(seth --to-uint256 $(seth --to-wei 100 ether))
weight=$(seth --to-uint256 $(seth --to-wei 5 ether))
seth send $BPOOL "bind(address, uint256, uint256)" $DAI $amount $weight
​
# Bind 0.25 MKR with a denormalized weight of 5
amount=$(seth --to-uint256 $(seth --to-wei 0.25 ether))
weight=$(seth --to-uint256 $(seth --to-wei 5 ether))
seth send $BPOOL "bind(address, uint256, uint256)" $MKR $amount $weight

Let's confirm that all the tokens were added by using some view functions. This will get a token's normalized weight, or percentage of the pool, to make sure our original math was correct.

seth call $BPOOL "getNumTokens()"
​
seth --from-wei $(seth --to-dec $(seth call $BPOOL "getNormalizedWeight(address)" $WETH))
​
seth --from-wei $(seth --to-dec $(seth call $BPOOL "getNormalizedWeight(address)" $DAI))
​
seth --from-wei $(seth --to-dec $(seth call $BPOOL "getNormalizedWeight(address)" $MKR))

Now that we're finished adding tokens, we need to set a swap fee for our pool. Otherwise we wouldn't earn anything on our assets and be more exposed to impermanent loss. In this example, we will set a swap fee of 0.3%:

fee=$(seth --to-uint256 $(seth --to-wei 0.003 ether))
seth send $BPOOL "setSwapFee(uint256)" $fee

We have a valid pool with 3 bound tokens and a swap fee of 0.3%. At this point, a decision has to be made whether to finalize the pool. A pool can either be private or shared. A private pool allows the owner to continually adjust tokens, balances, weights, and fees. But prevents anyone else from adding or removing liquidity to that pool - it wouldn't be fair if the owner changed weights if other users have contributed liquidity! A shared pool is created when the finalize function is called and is a one-way transition. This locks all of the tokens, balances, weights, and opens the ability for outside users to add and remove liquidity.

A private pool allows the owner to continually adjust tokens, balances, weights, and fees - but prevents anyone else from adding or removing liquidity to that pool. After all, it wouldn't be fair if the owner changed weights after other users contributed liquidity! A shared pool is created when the finalize function is called - and this is a one-way transition. This locks all of the tokens, balances, weights, and opens the pool to outside users to add and remove liquidity.

For our example, we want other users to be able to add liquidity, so let's finalize it. 100 Balancer Pool Tokens will be minted as part of the pool finalization regardless of the bound token balances. Balancer Pool Tokens, or BPTs, represent proportional ownership of a pools liquidity. Any future joins or exits are calculated based on the relative liquidity being added.

seth send $BPOOL "finalize()"

All done, now anyone can add liquidity and swap against the assets in the pool!

Let's confirm that we received BPTs by calling balanceOf directly on the pool address (since the pools themselves are ERC20 tokens)

seth --from-wei $(seth --to-dec $(seth call $BPOOL "balanceOf(address)" $ETH_FROM))
*** Hackathons
Hackathons

This section provides resources and info for everyone who is hacking and building on Balancer - the potentail is huge and we're excited to see what you create!
Getting To Know Balancer Protocol

For an introduction and overview we recommend taking the time to read through the earlier sections of this documentation. You can find more technical information covering Smart Contracts and libraries in the later sections. Included below are some links to helpful info:

    ​Understanding Balancer​

    ​Balancer Website​

    ​White Paper​

    ​Balancer Blog​

    ​Building On Balancer Video Intro​

    ​Building a Balancer app with Create Eth App​

    ​Github​

    ​Twitter​

    ​FAQ​

    ​Our Discord​
**** Hacking & Testing
Hacking & Testing
Some useful specifics to get you started

The contracts are opensource and everything is deployed on Kovan as well as Mainnet.

We use the Subgraph to make it easy to query data (Repo: balancer-subgraph).

There are also apps for Pool Management and Token Exchanges. The source code for these are also available (Exchange, Pool Management).
Kovan

​Exchange App​

​Pool Management App​

​Subgraph​

​Guide for testing on Kovan. Includes contract addresses and test faucet details.
Mainnet

​Exchange App​

​Pool Management App​

​Subgraph​

​Guide - Create Your Own Pool​

Deployed BFactory Address: 0x9424B1412450D0f8Fc2255FAf6046b98213B76Bd
**** Judging
Judging
Some things we like to see (i.e. help yourself to win)

    Novel and innovative uses of Balancer are great to see.

    Provide a short presentation or video that explains your idea, how it uses Balancer and where the project could go next.

    Your code should be available on Github with a Readme describing how to run it.

    Bonus for good documentation!

    A deployed and publicly available UI allows us to interact and get a feel for your project.

    If your project involved creating Solidity contracts make use of a testnet to deploy, test and hook up your UI.

    Have fun!
**** Ideas
Ideas

We’re excited to see what you could build and to get you started here’s some ideas:

    ​Smart pool ideas​

    UI template for liquidity bootstrapping pools (inspiration from Perp)

    Liquidity bootstrapping pool template with configurable curve

    Trading between a BPT and one of its underlying tokens (e.g. BTC++/WBTC)

    Smart pool with incentivized bonding curve "Loyalty Pools":

        early LPs get more BPT per liquidity

        LPs who withdraw later get more tokens per BPT.

    Other smart pools that use Balancer’s customizable weights and fees in interesting ways

    Balancer Pool DAO - BPT holders can vote on changing fees, etc

    Arbitrage using flashloans
* balancer whitepaper

Whitepaper

A non-custodial portfolio manager, liquidity provider, and price sensor.

by:
Fernando Martinelli
Nikolai Mushegian

v2019-09-19

contact@balancer.finance
** Introduction

A Balancer Pool is an automated market maker with certain key properties that cause it to function as a self-balancing weighted portfolio and price sensor.

Balancer turns the concept of an index fund on its head: instead of paying fees to portfolio managers to rebalance your portfolio, you collect fees from traders, who rebalance your portfolio by following arbitrage opportunities.

Balancer is based on a particular N-dimensional surface which defines a cost function for the exchange of any pair of tokens held in a Balancer Pool. This approach was first described by V. Buterin[0], generalized by Alan Lu[1], and proven viable for market making by the popular Uniswap[2] dapp.

We independently arrived at the same surface definition by starting with the requirement that any trade must maintain a constant proportion of value in each asset of the portfolio. We applied an invariant-based modeling approach described by Zargham et al[3] to construct this solution. We will prove that these constant-value market makers have this property.
** Table of Contents
***    Introduction
***    Table of Contents
***    Present Work
***    Theory
****        Value Function
****        Spot Price
****        Effective Price
****        Spot Price Proof
****        Constant Value Distribution Proof
****        Trading Formulas
*****            In-Given-Out
*****            Out-Given-In
*****            In-Given-Price
****        Liquidity Providing Formulas
*****            All-Asset Deposit/Withdrawal
*****            Single-Asset Deposit
*****            Single-Asset Withdrawal
***    Implementation
****        License
****        Releases
****        Numerical Algorithms
****        Controlled vs Finalized Pools
****        Swap and Exit Fees
***    References

** Present Work

Index funds are a common financial instrument. The first index fund became effective in 1972. Ever since, investors rely heavily on different portfolio strategies to hedge risk and achieve diversification. Index funds guarantee investors a constant and controlled exposure to a portfolio. If one of its assets out- or under-performs, it is respectively sold or bought to keep its value share of the total portfolio constant.

Both in the conventional financial system as well as in the blockchain context, index funds and other types of investment portfolios charge investors fees for managing and holding their funds. These fees are necessary to pay for the costs of actively rebalancing the index funds, be it by manual traders or automatic bots.

There are many centralized solutions for portfolio management and for investing in index funds. These all share some form of custodial risk.

We are aware of one decentralized (read: non-custodial) solution that shares all the fundamental characteristics Balancer was designed to have: Uniswap. This approach was first described by V. Buterin and generalized by Alan Lu.

We independently arrived at the same surface definition by starting with the requirement that any trade must maintain a constant proportion of value in each asset of the portfolio. We applied an invariant-based modeling approach described by Zargham et al to construct this solution. We will prove that these constant-value market makers have this property.
** Theory

Throughout this paper, we use the term “token” to refer to a generic asset because our first implementation is a contract system that manipulates ERC20 tokens on the Ethereum network. However, there is nothing fundamental about the Ethereum execution context that enables this market-making algorithm, which could be offered by a traditional financial institution as a centralized (custodial) product.
*** Value Function

The bedrock of Balancer’s exchange functions is a surface defined by constraining a value function V

— a function of the pool’s weights and balances — to a constant. We will prove that this surface implies a spot price at each point such that, no matter what exchanges are carried out, the share of value of each token in the pool remains constant.

The value function V

is defined as:

V=∏tBWtt(1)

Where

    t

ranges over the tokens in the pool;
Bt
is the balance of the token in the pool;
Wt

    is the normalized weight of the token, such that the sum of all normalized weights is 1.

By making V

constant we can define an invariant-value surface as illustrated in Fig.0.
*** Spot Price

Each pair of tokens in a pool has a spot price defined entirely by the weights and balances of just that pair of tokens. The spot price between any two tokens, SpotPriceoi
, or in short SPoi

, is the the ratio of the token balances normalized by their weights:

SPoi=BiWiBoWo(2)

Where:

    Bi

is the balance of token i, the token being sold by the trader which is going into the pool.
Bo
is the balance of token o, the token being bought by the trader which is going out of the pool.
Wi
is the weight of token i
Wo

    is the weight of token o

From this definition it is easy to see that if weights are held constant, the spot prices offered by Balancer Pools only change with changing token balances. If the pool owner does not add or remove tokens to/from the pool, token balances can only change through trades. The constant surface causes the price of tokens being bought by the trader (token o
) to increase and price of tokens being sold by the trader (token i

) to decrease. One can prove that whenever external market prices are different from those offered by a Balancer Pool, an arbitrageur will make the most profit by trading with that pool until its prices equal those on the external market. When this happens there is no more arbitrage opportunity. These arbitrage opportunities guarantee that, in a rational market, prices offered by any Balancer Pool move in lockstep with the rest of the market.
*** Effective Price

It is important to bear in mind that SPoi
is the spot price, which is the theoretical price for infinitesimal trades, which would incur no slippage. In reality, the effective price for any trade depends on the amount being traded, which always causes a price change. If we define Ao as the amount of token o being bought by the trader and Ai as the amount of token i

being sold by the trader, then we can define the Effective Price as:

EPoi=AiAo(3)

And as mentioned above, EP
tends to SP

when traded amounts tend to 0:

SPoi=limAo,Ai→0EPoi(4)

*** Spot Price Proof

Let’s now prove that this choice of V

entails Eq.2.

First of all, we know that what the trader buys, Ao
, is subtracted from the contract’s balance. Therefore Ao=−ΔBo. Likewise, what the trader sells, Ai, is added to the contract’s balance. Therefore Ai=ΔBi

.

Substituting in Eq.2 and Eq.3 we get:

SPoi=limAo,Ai→0EPoi=limΔBo,ΔBi→0ΔBi−ΔBo(5)

This limit is, by definition, minus the partial derivative of Bi
in function of Bo

:

SPoi=−∂Bi∂Bo(6)

From the value function definition in Eq.1 we can isolate Bi

:

BWii=V(∏k≠i,oBWkk).BWoo

Bi=⎛⎜⎝V(∏k≠i,oBWkk).BWoo⎞⎟⎠1Wi(7)

Now we use Eq.7 to expand the partial derivative in Eq.6:
SPoi=−∂Bi∂Bo=−∂∂Bo⎛⎜
⎜
⎜⎝⎛⎜⎝V(∏k≠i,o(Bk)Wk)⋅(Bo)Wo⎞⎟⎠1Wi⎞⎟
⎟
⎟⎠=−(V∏k≠i,o(Bk)Wk)1Wi⋅∂∂Bo(B−WoWio)=−(V∏k≠i,o(Bk)Wk)1Wi⋅−WoWi⋅B−WoWi−1o=(V∏k(Bk)Wk)1Wi⋅BWoWio⋅Bi⋅WoWi⋅B−WoWi−1o=(VV)1Wi⋅BWoWio⋅B−WoWio⋅BiWi⋅WoBo=BiWiBoWo

which concludes our proof.
*** Constant Value Distribution Proof

We will now prove that:

    Balancer Pools maintain a constant share of value across all tokens in the pool and;
    These shares of value are equal to the weights associated to each token.

Let’s calculate Vt
, the total pool value in terms of an arbitrary token t from the pool. Since we already know that the pool has Bt tokens t, let’s calculate how many tokens t all the other remaining tokens are worth. It does not make sense to use their Effective Price relative to token t since we are not going to do any actual trade. Instead, to calculate the theoretical value we use their Spot Price relative to token t

.

From Eq.2 we can calculate Vtn
, i.e how many tokens t the balance of each token n

is worth:

Vtn=BnSPtn=Bn⋅BtWtBnWn=Bt⋅WnWt(8)

We know that the total pool value in terms of tokens t
is the sum of the values of each token in terms of tokens t

:

Vt=∑kVtk=Bt+∑k≠tVtk=Bt+BtWt⋅∑k≠tWn=BtWt⋅(Wt+∑k≠tWn)=BtWt(9)

Now to calculate Sn
, the share of value each token n represents in the pool, all we have to do is divide the value of each token n, Vtn, by the total pool value, Vt

:

Sn=VtnVt=Wn(10)

which proves both that the share each token represents of the total pool value is constant and also that it is equal to the weight of that token.
*** Trading Formulas

Calculating the trade outcomes for any given Balancer Pool is easy if we consider that the Value Function must remain invariant, i.e. V
must have the same value before and after any trade.
In reality, V

will increase as a result of trading fees applied after a trade state transition.
For more details on fees, see Implementation: Swap and Exit Fees
**** Out-Given-In

When a user sends tokens i
to get tokens o, all other token balances remain the same. Therefore, if we define Ai and Ao as the amount of tokens i and o exchanged, we can calculate the amount Ao a users gets when sending Ai

. Knowing the value function after the trade should be the same as before the trade, we can write:

∏k≠i,o(Bk)Wk⋅(Bo−Ao)Wo⋅(Bi+Ai)Wi=∏k(Bk)Wk (11)

∏k≠i,o(Bk)Wk⋅(Bo−Ao)Wo⋅(Bi+Ai)Wi=∏k≠i,o(Bk)Wk⋅BWoo⋅BWii (12)
(Bo−Ao)Wo⋅(Bi+Ai)Wi=BWoo⋅BWii (13)
Bo−Ao=BWiWoi⋅Bo(Bi+Ai)WiWo (14)
Ao=Bo⋅⎛⎝1–(BiBi+Ai)WiWo⎞⎠(15)

**** In-Given-Out

It is also very useful for traders to know how much they need to send of the input token Ai
to get a desired amount of output token Ao. We can calculate the amount Ai as a function of Ao

similarly as follows:

∏k≠i,o(Bk)Wk⋅(Bo−Ao)Wo⋅(Bi+Ai)Wi=∏k(Bk)Wk (16)

∏k≠i,o(Bk)Wk⋅(Bo−Ao)Wo⋅(Bi+Ai)Wi=∏k≠i,o(Bk)Wk⋅BWoo⋅BWii (17)
(Bo−Ao)Wo⋅(Bi+Ai)Wi=BWoo⋅BWii (18)
Bi+Ai=BWoWio⋅Bi(Bo−Ao)WoWi (19)

Ai=Bi⋅⎛⎝(BoBo−Ao)WoWi−1⎞⎠(20)

Notice that Ao
as defined by Eq.11 tends to SPoi⋅Ai when Ai<<Bi

, as expected. This can be proved by using L’Hopital’s rule, but this proof is out of the scope of this paper.
**** In-Given-Price

For practical purposes, traders intending to use our contract for arbitrage will like to know what amount of tokens i
– Ai – they will have to send to the contract to change the current spot price SPoi to another desired one SP′oi

. The desired spot price will usually be the external market price and, so long as the contract spot price differs from that of the external market, any arbitrageur can profit by trading with the contract and bringing the contract price closer to that of the external market.

The highest profit possible by an arbitrageur is when they bring the contract spot price exactly to that of the external market. As already mentioned, this is the main reason why our design is successful in keeping track of the market prices. This makes it a reliable on-chain price sensor when implemented on a blockchain.

It can be proven that the amount of tokens i
– Ai – a user needs to trade against tokens o so that the pool’s spot price changes from SPoi to SP′oi

is:

Ai=Bi⋅⎛⎜⎝(SP′oiSPoi)(WoWo+Wi)–1⎞⎟⎠(21)

*** Liquidity Providing Formulas
Pool Tokens

Pools can aggregate the liquidity provided by several different users. In order for them to be able to freely deposit and withdraw assets from the pool, Balancer Protocol has the concept of pool tokens. Pool tokens represent ownership of the assets contained in the pool. The outstanding supply of pool tokens is directly proportional to the Value Function of the pool. If a deposit of assets increases the pool Value Function by 10%, then the outstanding supply of pool tokens also increases by 10%. This happens because the depositor is issued 10% of new pool tokens in return for the deposit.

There are two ways in which one can deposit assets to the pool in return for pool tokens or redeem pool tokens in return for pool assets:

    Weighted-asset deposit/withdrawal
    Single-asset deposit/withdrawal

**** All-Asset Deposit/Withdrawal

An “all-asset” deposit has to follow the distribution of existing assets in the pool. If the deposit contains 10% of each of the assets already in the pool, then the Value Function will increase by 10% and the depositor will be minted 10% of the current outstanding pool token supply. So to receive Pissued
pool tokens given an existing total supply of Psupply, one needs to deposit Dk

tokens k for each of the tokens in the pool:

Dk=(Psupply+PissuedPsupply−1)⋅Bk(22)

Where Bk

is the token balance of token k before the deposit.

Similarly, a weighted-asset withdrawal is the reverse operation where a pool token holder redeems their pool tokens in return for a proportional share of each of the assets held by the pool. By redeeming Predeemed
pool tokens given an existing total supply of Psupply, one withdraws from the pool an amount Ak

of token k for each of the tokens in the pool:

Ak=(1−Psupply−PredeemedPsupply)⋅Bk(23)

Where Bk

is the token balance of token k before the withdrawal.
**** Single-Asset Deposit/Withdrawal

When a user wants to provide liquidity to a pool because they find its distribution of assets interesting, they may likely not have all of the assets in the right proportions required for a weighted-asset deposit.

Balancer allows anyone to get pool tokens from a shared pool by depositing a single asset to it, provided that the pool contains that asset.
Depositing a single asset A to a shared pool is equivalent to depositing all pool assets proportionally and then selling more of asset A to get back all the other tokens deposited. This way a depositor would end up spending only asset A, since the amounts of the other tokens deposited would be returned through the trades.

The amount of pool tokens one gets for depositing a single asset to a shared pool can be derived from the Value Function described above.
***** Single-Asset Deposit

The increase in the pool token supply proportional to the increase in the Value Function. If we define Pissued

as the amount of pool tokens issued in return for the deposit, then:

V′V=P′supplyPsupply=Psupply+PissuedPsupply

Pissued=Psupply⋅(V′V−1)(24)

Where V′
is the Value Function after the deposit and V is the Value Function before the deposit. Considering also B′k the balance of asset k after the deposit and Bk

its balance before the deposit, we have:
V′V=∏k(B′k)Wk∏k(Bk)Wk

Let’s say the single-asset deposit was done in asset t

, then the balances of all other tokens do not change after the deposit. We can then write:
V′V=∏k(B′k)Wk∏k(Bk)Wk=(B′t)Wt(Bt)Wt=(B′tBt)Wt

If we define At
as the amount deposited in asset t, then the new pool balance of asset t is $$B’t = B_t + A_t$$. We can then substitute and get the final formula for the amount of new pool tokens issued $P{issued}inreturnforasinge−assetdeposit

I_t$:

Pissued=Psupply⋅((1+AtBt)Wt−1)(25)

***** Single-Asset Withdrawal

When a pool token holder wants to redeem their pool tokens Predeemed
in return for a single asset t, the amount withdrawn in asset t, At

, is:

At=Bt⋅(1−(1−PredeemedPsupply)1Wt)(26)

Where Bt
is the pool balance of asset t

before the withdrawal.

Indeed, using the formulas of deposit and withdrawal defined above, not considering any fees, if one deposits At
asset t for Pissued pool tokens and then redeems that same amount of pool tokens for asset t, they will get the same initial At

back.
Trading Fees for Single-Asset Deposit Withdrawal

Depositing or withdrawing to/from a shared pool in a single asset t
is equivalent to trading (1−Wt) of the amount deposited for all the other assets in the pool. Wt of the amount deposited is held by the pool already in the form of asset t

, so charging a trading fee on that share would be unfair.

Indeed, if we disregard any possible pool exit fees, depositing only asset i
and instantly withdrawing asset o will incur in the same trading fees as doing the trade from i to o

using the trade function the pool offers.
** Implementation

There are a few initial notes regarding the first release of Balancer. We will release a much more detailed explanation of the system at the same time that the source code is released.
Free Software on Ethereum

Balancer is implemented as a GPL3-licensed Ethereum smart contract system.
*** Releases

The 🍂Bronze Release🍂 is the first of 3 planned releases of the Balancer Protocol. Bronze emphasizes code clarity for audit and verification, and does not go to great lengths to optimize for gas.

The ❄️Silver Release❄️ will bring many gas optimizations and architecture changes that will reduce transaction overhead and enable more flexibility for controlled pools.

The ☀️Golden Release☀️ will introduce several new features to tie the whole system together.
*** Numerical Algorithms

The formulas in the Theory section are sufficient to describe the functional specification, but they are not straightforward to implement for the EVM, in part due to a lack of mature fixed-point math libraries.

Our implementation uses a combination of a few algebraic transformations, approximation functions, and numerical hacks to compute these formulas with bounded maximum error and reasonable gas cost.

The rest of this section will be released at the same time as the Bronze release source code.
*** Controlled vs Finalized Pools

The 🍂Bronze Release🍂 allows two basic tiers of trust with respect to pools:

    Controlled pools are configurable by a “controller” address. Only this address can add or remove liquidity to the pool (call join or exit). This type of pool allows the change of pool assets types and their weights. Note that since the controller is an address, this could in principle implement arbitrary logic, like managing public deposits in a manner similar to a finalized pool. The key difference is that official tooling will not recognize it as a “trustless” pool. Controlled pools with increased trust requirements will be possible with the ❄️Silver Release❄️.
    Finalized pools have fixed pool asset types, weights, and fees. Crucially, this enables join and exit to be publicly accessible in a safe, trustless manner while keeping a minimal implementation.

*** Swaps and Exit Fees

The 🍂Bronze Release🍂 charges fees in two situations: When traders exchange tokens (via swap and its variants), and when liquidity providers remove their liquidity from the pool (via exit and its variants).

Both of these fees are configurable by the controller, but they are also fixed when the pool becomes finalized.

100% of the swap fee goes to the liquidity providers — the amount of the underlying token that can be redeemed by each pool token increases.

Most of the exit fee is returned to the liquidity providers who remain in the pool.
This is similar in spirit to a swap fee charged for exchanging pool tokens with underlying tokens.

The rest of the exit fee is transferred to an account controlled by Balancer Labs, Inc, for the development of ❄️Future Releases☀️.
** References

[0] Vitalik Buterin: Let’s run on-chain decentralized exchanges the way we run prediction markets

[1] Alan Wu: Building a Decentralized Exchange in Ethereum

[2] https://uniswap.io/

[3] Zargham, M., Zhang, Z., Preciado, V.: A State-Space Modeling Framework for Engineering Blockchain-Enabled Economic Systems. New England Complex Systems Institute (2018)

© Balancer Labs

* balancer contracts
** BColor 
#+begin_src solidity
pragma solidity 0.5.12;

contract BColor {
    function getColor()
        external view
        returns (bytes32);
}

contract BBronze is BColor {
    function getColor()
        external view
        returns (bytes32) {
            return bytes32("BRONZE");
        }
}

#+end_src
** BConst
#+begin_src solidity
pragma solidity 0.5.12;

import "./BColor.sol";

contract BConst is BBronze {
    uint public constant BONE              = 10**18;

    uint public constant MIN_BOUND_TOKENS  = 2;
    uint public constant MAX_BOUND_TOKENS  = 8;

    uint public constant MIN_FEE           = BONE / 10**6;
    uint public constant MAX_FEE           = BONE / 10;
    uint public constant EXIT_FEE          = 0;

    uint public constant MIN_WEIGHT        = BONE;
    uint public constant MAX_WEIGHT        = BONE * 50;
    uint public constant MAX_TOTAL_WEIGHT  = BONE * 50;
    uint public constant MIN_BALANCE       = BONE / 10**12;

    uint public constant INIT_POOL_SUPPLY  = BONE * 100;

    uint public constant MIN_BPOW_BASE     = 1 wei;
    uint public constant MAX_BPOW_BASE     = (2 * BONE) - 1 wei;
    uint public constant BPOW_PRECISION    = BONE / 10**10;

    uint public constant MAX_IN_RATIO      = BONE / 2;
    uint public constant MAX_OUT_RATIO     = (BONE / 3) + 1 wei;
}


#+end_src
** BFactory
#+begin_src solidity
pragma solidity 0.5.12;

// Builds new BPools, logging their addresses and providing `isBPool(address) -> (bool)`

import "./BPool.sol";

contract BFactory is BBronze {
    event LOG_NEW_POOL(
        address indexed caller,
        address indexed pool
    );

    event LOG_BLABS(
        address indexed caller,
        address indexed blabs
    );

    mapping(address=>bool) private _isBPool;

    function isBPool(address b)
        external view returns (bool)
    {
        return _isBPool[b];
    }

    function newBPool()
        external
        returns (BPool)
    {
        BPool bpool = new BPool();
        _isBPool[address(bpool)] = true;
        emit LOG_NEW_POOL(msg.sender, address(bpool));
        bpool.setController(msg.sender);
        return bpool;
    }

    address private _blabs;

    constructor() public {
        _blabs = msg.sender;
    }

    function getBLabs()
        external view
        returns (address)
    {
        return _blabs;
    }

    function setBLabs(address b)
        external
    {
        require(msg.sender == _blabs, "ERR_NOT_BLABS");
        emit LOG_BLABS(msg.sender, b);
        _blabs = b;
    }

    function collect(BPool pool)
        external 
    {
        require(msg.sender == _blabs, "ERR_NOT_BLABS");
        uint collected = IERC20(pool).balanceOf(address(this));
        bool xfer = pool.transfer(_blabs, collected);
        require(xfer, "ERR_ERC20_FAILED");
    }
}


#+end_src
** BMath
#+begin_src solidity
pragma solidity 0.5.12;

import "./BNum.sol";

contract BMath is BBronze, BConst, BNum {
    /**********************************************************************************************
    // calcSpotPrice                                                                             //
    // sP = spotPrice                                                                            //
    // bI = tokenBalanceIn                ( bI / wI )         1                                  //
    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //
    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //
    // wO = tokenWeightOut                                                                       //
    // sF = swapFee                                                                              //
    **********************************************************************************************/
    function calcSpotPrice(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint swapFee
    )
        public pure
        returns (uint spotPrice)
    {
        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);
        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);
        uint ratio = bdiv(numer, denom);
        uint scale = bdiv(BONE, bsub(BONE, swapFee));
        return  (spotPrice = bmul(ratio, scale));
    }

    /**********************************************************************************************
    // calcOutGivenIn                                                                            //
    // aO = tokenAmountOut                                                                       //
    // bO = tokenBalanceOut                                                                      //
    // bI = tokenBalanceIn              /      /            bI             \    (wI / wO) \      //
    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //
    // wI = tokenWeightIn               \      \ ( bI + ( aI * ( 1 - sF )) /              /      //
    // wO = tokenWeightOut                                                                       //
    // sF = swapFee                                                                              //
    **********************************************************************************************/
    function calcOutGivenIn(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint tokenAmountIn,
        uint swapFee
    )
        public pure
        returns (uint tokenAmountOut)
    {
        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);
        uint adjustedIn = bsub(BONE, swapFee);
        adjustedIn = bmul(tokenAmountIn, adjustedIn);
        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));
        uint foo = bpow(y, weightRatio);
        uint bar = bsub(BONE, foo);
        tokenAmountOut = bmul(tokenBalanceOut, bar);
        return tokenAmountOut;
    }

    /**********************************************************************************************
    // calcInGivenOut                                                                            //
    // aI = tokenAmountIn                                                                        //
    // bO = tokenBalanceOut               /  /     bO      \    (wO / wI)      \                 //
    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //
    // aO = tokenAmountOut    aI =        \  \ ( bO - aO ) /                   /                 //
    // wI = tokenWeightIn           --------------------------------------------                 //
    // wO = tokenWeightOut                          ( 1 - sF )                                   //
    // sF = swapFee                                                                              //
    **********************************************************************************************/
    function calcInGivenOut(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint tokenAmountOut,
        uint swapFee
    )
        public pure
        returns (uint tokenAmountIn)
    {
        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);
        uint diff = bsub(tokenBalanceOut, tokenAmountOut);
        uint y = bdiv(tokenBalanceOut, diff);
        uint foo = bpow(y, weightRatio);
        foo = bsub(foo, BONE);
        tokenAmountIn = bsub(BONE, swapFee);
        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);
        return tokenAmountIn;
    }

    /**********************************************************************************************
    // calcPoolOutGivenSingleIn                                                                  //
    // pAo = poolAmountOut         /                                              \              //
    // tAi = tokenAmountIn        ///      /     //    wI \      \\       \     wI \             //
    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \    --  \            //
    // tW = totalWeight     pAo=||  \      \     \\    tW /      //         | ^ tW   | * pS - pS //
    // tBi = tokenBalanceIn      \\  ------------------------------------- /        /            //
    // pS = poolSupply            \\                    tBi               /        /             //
    // sF = swapFee                \                                              /              //
    **********************************************************************************************/
    function calcPoolOutGivenSingleIn(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint poolSupply,
        uint totalWeight,
        uint tokenAmountIn,
        uint swapFee
    )
        public pure
        returns (uint poolAmountOut)
    {
        // Charge the trading fee for the proportion of tokenAi
        ///  which is implicitly traded to the other pool tokens.
        // That proportion is (1- weightTokenIn)
        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);
        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);
        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); 
        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));

        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);
        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);

        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;
        uint poolRatio = bpow(tokenInRatio, normalizedWeight);
        uint newPoolSupply = bmul(poolRatio, poolSupply);
        poolAmountOut = bsub(newPoolSupply, poolSupply);
        return poolAmountOut;
    }

    /**********************************************************************************************
    // calcSingleInGivenPoolOut                                                                  //
    // tAi = tokenAmountIn              //(pS + pAo)\     /    1    \\                           //
    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //
    // pAo = poolAmountOut              \\    pS    /     \(wI / tW)//                           //
    // bI = balanceIn          tAi =  --------------------------------------------               //
    // wI = weightIn                              /      wI  \                                   //
    // tW = totalWeight                          |  1 - ----  |  * sF                            //
    // sF = swapFee                               \      tW  /                                   //
    **********************************************************************************************/
    function calcSingleInGivenPoolOut(
        uint tokenBalanceIn,
        uint tokenWeightIn,
        uint poolSupply,
        uint totalWeight,
        uint poolAmountOut,
        uint swapFee
    )
        public pure
        returns (uint tokenAmountIn)
    {
        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);
        uint newPoolSupply = badd(poolSupply, poolAmountOut);
        uint poolRatio = bdiv(newPoolSupply, poolSupply);
      
        //uint newBalTi = poolRatio^(1/weightTi) * balTi;
        uint boo = bdiv(BONE, normalizedWeight); 
        uint tokenInRatio = bpow(poolRatio, boo);
        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);
        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);
        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way 
        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```
        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;
        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);
        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));
        return tokenAmountIn;
    }

    /**********************************************************************************************
    // calcSingleOutGivenPoolIn                                                                  //
    // tAo = tokenAmountOut            /      /                                             \\   //
    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \     /    1    \      \\  //
    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //
    // ps = poolSupply                \      \\          pS           /     \(wO / tW)/      //  //
    // wI = tokenWeightIn      tAo =   \      \                                             //   //
    // tW = totalWeight                    /     /      wO \       \                             //
    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //
    // eF = exitFee                        \     \      tW /       /                             //
    **********************************************************************************************/
    function calcSingleOutGivenPoolIn(
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint poolSupply,
        uint totalWeight,
        uint poolAmountIn,
        uint swapFee
    )
        public pure
        returns (uint tokenAmountOut)
    {
        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);
        // charge exit fee on the pool token side
        // pAiAfterExitFee = pAi*(1-exitFee)
        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, EXIT_FEE));
        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);
        uint poolRatio = bdiv(newPoolSupply, poolSupply);
     
        // newBalTo = poolRatio^(1/weightTo) * balTo;
        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));
        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);

        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);

        // charge swap fee on the output token side 
        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)
        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); 
        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));
        return tokenAmountOut;
    }

    /**********************************************************************************************
    // calcPoolInGivenSingleOut                                                                  //
    // pAi = poolAmountIn               // /               tAo             \\     / wO \     \   //
    // bO = tokenBalanceOut            // | bO - -------------------------- |\   | ---- |     \  //
    // tAo = tokenAmountOut      pS - ||   \     1 - ((1 - (tO / tW)) * sF)/  | ^ \ tW /  * pS | //
    // ps = poolSupply                 \\ -----------------------------------/                /  //
    // wO = tokenWeightOut  pAi =       \\               bO                 /                /   //
    // tW = totalWeight           -------------------------------------------------------------  //
    // sF = swapFee                                        ( 1 - eF )                            //
    // eF = exitFee                                                                              //
    **********************************************************************************************/
    function calcPoolInGivenSingleOut(
        uint tokenBalanceOut,
        uint tokenWeightOut,
        uint poolSupply,
        uint totalWeight,
        uint tokenAmountOut,
        uint swapFee
    )
        public pure
        returns (uint poolAmountIn)
    {

        // charge swap fee on the output token side 
        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);
        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;
        uint zoo = bsub(BONE, normalizedWeight);
        uint zar = bmul(zoo, swapFee); 
        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));

        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);
        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);

        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;
        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);
        uint newPoolSupply = bmul(poolRatio, poolSupply);
        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);

        // charge exit fee on the pool token side
        // pAi = pAiAfterExitFee/(1-exitFee)
        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, EXIT_FEE));
        return poolAmountIn;
    }


}


#+end_src
** BNum
#+begin_src solidity
pragma solidity 0.5.12;

import "./BConst.sol";

contract BNum is BConst {

    function btoi(uint a)
        internal pure 
        returns (uint)
    {
        return a / BONE;
    }

    function bfloor(uint a)
        internal pure
        returns (uint)
    {
        return btoi(a) * BONE;
    }

    function badd(uint a, uint b)
        internal pure
        returns (uint)
    {
        uint c = a + b;
        require(c >= a, "ERR_ADD_OVERFLOW");
        return c;
    }

    function bsub(uint a, uint b)
        internal pure
        returns (uint)
    {
        (uint c, bool flag) = bsubSign(a, b);
        require(!flag, "ERR_SUB_UNDERFLOW");
        return c;
    }

    function bsubSign(uint a, uint b)
        internal pure
        returns (uint, bool)
    {
        if (a >= b) {
            return (a - b, false);
        } else {
            return (b - a, true);
        }
    }

    function bmul(uint a, uint b)
        internal pure
        returns (uint)
    {
        uint c0 = a * b;
        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");
        uint c1 = c0 + (BONE / 2);
        require(c1 >= c0, "ERR_MUL_OVERFLOW");
        uint c2 = c1 / BONE;
        return c2;
    }

    function bdiv(uint a, uint b)
        internal pure
        returns (uint)
    {
        require(b != 0, "ERR_DIV_ZERO");
        uint c0 = a * BONE;
        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow
        uint c1 = c0 + (b / 2);
        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require
        uint c2 = c1 / b;
        return c2;
    }

    // DSMath.wpow
    function bpowi(uint a, uint n)
        internal pure
        returns (uint)
    {
        uint z = n % 2 != 0 ? a : BONE;

        for (n /= 2; n != 0; n /= 2) {
            a = bmul(a, a);

            if (n % 2 != 0) {
                z = bmul(z, a);
            }
        }
        return z;
    }

    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).
    // Use `bpowi` for `b^e` and `bpowK` for k iterations
    // of approximation of b^0.w
    function bpow(uint base, uint exp)
        internal pure
        returns (uint)
    {
        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");
        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");

        uint whole  = bfloor(exp);   
        uint remain = bsub(exp, whole);

        uint wholePow = bpowi(base, btoi(whole));

        if (remain == 0) {
            return wholePow;
        }

        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);
        return bmul(wholePow, partialResult);
    }

    function bpowApprox(uint base, uint exp, uint precision)
        internal pure
        returns (uint)
    {
        // term 0:
        uint a     = exp;
        (uint x, bool xneg)  = bsubSign(base, BONE);
        uint term = BONE;
        uint sum   = term;
        bool negative = false;


        // term(k) = numer / denom 
        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)
        // each iteration, multiply previous term by (a-(k-1)) * x / k
        // continue until term is less than precision
        for (uint i = 1; term >= precision; i++) {
            uint bigK = i * BONE;
            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));
            term = bmul(term, bmul(c, x));
            term = bdiv(term, bigK);
            if (term == 0) break;

            if (xneg) negative = !negative;
            if (cneg) negative = !negative;
            if (negative) {
                sum = bsub(sum, term);
            } else {
                sum = badd(sum, term);
            }
        }

        return sum;
    }

}


#+end_src
** BPool
#+begin_src solidity
pragma solidity 0.5.12;

import "./BToken.sol";
import "./BMath.sol";

contract BPool is BBronze, BToken, BMath {

    struct Record {
        bool bound;   // is token bound to pool
        uint index;   // private
        uint denorm;  // denormalized weight
        uint balance;
    }

    event LOG_SWAP(
        address indexed caller,
        address indexed tokenIn,
        address indexed tokenOut,
        uint256         tokenAmountIn,
        uint256         tokenAmountOut
    );

    event LOG_JOIN(
        address indexed caller,
        address indexed tokenIn,
        uint256         tokenAmountIn
    );

    event LOG_EXIT(
        address indexed caller,
        address indexed tokenOut,
        uint256         tokenAmountOut
    );

    event LOG_CALL(
        bytes4  indexed sig,
        address indexed caller,
        bytes           data
    ) anonymous;

    modifier _logs_() {
        emit LOG_CALL(msg.sig, msg.sender, msg.data);
        _;
    }

    modifier _lock_() {
        require(!_mutex, "ERR_REENTRY");
        _mutex = true;
        _;
        _mutex = false;
    }

    modifier _viewlock_() {
        require(!_mutex, "ERR_REENTRY");
        _;
    }

    bool private _mutex;

    address private _factory;    // BFactory address to push token exitFee to
    address private _controller; // has CONTROL role
    bool private _publicSwap; // true if PUBLIC can call SWAP functions

    // `setSwapFee` and `finalize` require CONTROL
    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`
    uint private _swapFee;
    bool private _finalized;

    address[] private _tokens;
    
    mapping(address=>Record) private  _records;
    
    uint private _totalWeight;

    constructor() public {
        _controller = msg.sender;
        _factory = msg.sender;
        _swapFee = MIN_FEE;
        _publicSwap = false;
        _finalized = false;
    }

    function isPublicSwap()
        external view
        returns (bool)
    {
        return _publicSwap;
    }

    function isFinalized()
        external view
        returns (bool)
    {
        return _finalized;
    }

    function isBound(address t)
        external view
        returns (bool)
    {
        return _records[t].bound;
    }

    function getNumTokens()
        external view
        returns (uint) 
    {
        return _tokens.length;
    }

    function getCurrentTokens()
        external view _viewlock_
        returns (address[] memory tokens)
    {
        return _tokens;
    }

    function getFinalTokens()
        external view
        _viewlock_
        returns (address[] memory tokens)
    {
        require(_finalized, "ERR_NOT_FINALIZED");
        return _tokens;
    }

    function getDenormalizedWeight(address token)
        external view
        _viewlock_
        returns (uint)
    {

        require(_records[token].bound, "ERR_NOT_BOUND");
        return _records[token].denorm;
    }

    function getTotalDenormalizedWeight()
        external view
        _viewlock_
        returns (uint)
    {
        return _totalWeight;
    }

    function getNormalizedWeight(address token)
        external view
        _viewlock_
        returns (uint)
    {

        require(_records[token].bound, "ERR_NOT_BOUND");
        uint denorm = _records[token].denorm;
        return bdiv(denorm, _totalWeight);
    }

    function getBalance(address token)
        external view
        _viewlock_
        returns (uint)
    {

        require(_records[token].bound, "ERR_NOT_BOUND");
        return _records[token].balance;
    }

    function getSwapFee()
        external view
        _viewlock_
        returns (uint)
    {
        return _swapFee;
    }

    function getController()
        external view
        _viewlock_
        returns (address)
    {
        return _controller;
    }

    function setSwapFee(uint swapFee)
        external
        _logs_
        _lock_
    { 
        require(!_finalized, "ERR_IS_FINALIZED");
        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        require(swapFee >= MIN_FEE, "ERR_MIN_FEE");
        require(swapFee <= MAX_FEE, "ERR_MAX_FEE");
        _swapFee = swapFee;
    }

    function setController(address manager)
        external
        _logs_
        _lock_
    {
        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        _controller = manager;
    }

    function setPublicSwap(bool public_)
        external
        _logs_
        _lock_
    {
        require(!_finalized, "ERR_IS_FINALIZED");
        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        _publicSwap = public_;
    }

    function finalize()
        external
        _logs_
        _lock_
    {
        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        require(!_finalized, "ERR_IS_FINALIZED");
        require(_tokens.length >= MIN_BOUND_TOKENS, "ERR_MIN_TOKENS");

        _finalized = true;
        _publicSwap = true;

        _mintPoolShare(INIT_POOL_SUPPLY);
        _pushPoolShare(msg.sender, INIT_POOL_SUPPLY);
    }


    function bind(address token, uint balance, uint denorm)
        external
        _logs_
        // _lock_  Bind does not lock because it jumps to `rebind`, which does
    {
        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        require(!_records[token].bound, "ERR_IS_BOUND");
        require(!_finalized, "ERR_IS_FINALIZED");

        require(_tokens.length < MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");

        _records[token] = Record({
            bound: true,
            index: _tokens.length,
            denorm: 0,    // balance and denorm will be validated
            balance: 0   // and set by `rebind`
        });
        _tokens.push(token);
        rebind(token, balance, denorm);
    }

    function rebind(address token, uint balance, uint denorm)
        public
        _logs_
        _lock_
    {

        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        require(_records[token].bound, "ERR_NOT_BOUND");
        require(!_finalized, "ERR_IS_FINALIZED");

        require(denorm >= MIN_WEIGHT, "ERR_MIN_WEIGHT");
        require(denorm <= MAX_WEIGHT, "ERR_MAX_WEIGHT");
        require(balance >= MIN_BALANCE, "ERR_MIN_BALANCE");

        // Adjust the denorm and totalWeight
        uint oldWeight = _records[token].denorm;
        if (denorm > oldWeight) {
            _totalWeight = badd(_totalWeight, bsub(denorm, oldWeight));
            require(_totalWeight <= MAX_TOTAL_WEIGHT, "ERR_MAX_TOTAL_WEIGHT");
        } else if (denorm < oldWeight) {
            _totalWeight = bsub(_totalWeight, bsub(oldWeight, denorm));
        }        
        _records[token].denorm = denorm;

        // Adjust the balance record and actual token balance
        uint oldBalance = _records[token].balance;
        _records[token].balance = balance;
        if (balance > oldBalance) {
            _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));
        } else if (balance < oldBalance) {
            // In this case liquidity is being withdrawn, so charge EXIT_FEE
            uint tokenBalanceWithdrawn = bsub(oldBalance, balance);
            uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);
            _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));
            _pushUnderlying(token, _factory, tokenExitFee);
        }
    }

    function unbind(address token)
        external
        _logs_
        _lock_
    {

        require(msg.sender == _controller, "ERR_NOT_CONTROLLER");
        require(_records[token].bound, "ERR_NOT_BOUND");
        require(!_finalized, "ERR_IS_FINALIZED");

        uint tokenBalance = _records[token].balance;
        uint tokenExitFee = bmul(tokenBalance, EXIT_FEE);

        _totalWeight = bsub(_totalWeight, _records[token].denorm);

        // Swap the token-to-unbind with the last token,
        // then delete the last token
        uint index = _records[token].index;
        uint last = _tokens.length - 1;
        _tokens[index] = _tokens[last];
        _records[_tokens[index]].index = index;
        _tokens.pop();
        _records[token] = Record({
            bound: false,
            index: 0,
            denorm: 0,
            balance: 0
        });

        _pushUnderlying(token, msg.sender, bsub(tokenBalance, tokenExitFee));
        _pushUnderlying(token, _factory, tokenExitFee);
    }

    // Absorb any tokens that have been sent to this contract into the pool
    function gulp(address token)
        external
        _logs_
        _lock_
    {
        require(_records[token].bound, "ERR_NOT_BOUND");
        _records[token].balance = IERC20(token).balanceOf(address(this));
    }

    function getSpotPrice(address tokenIn, address tokenOut)
        external view
        _viewlock_
        returns (uint spotPrice)
    {
        require(_records[tokenIn].bound, "ERR_NOT_BOUND");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");
        Record storage inRecord = _records[tokenIn];
        Record storage outRecord = _records[tokenOut];
        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);
    }

    function getSpotPriceSansFee(address tokenIn, address tokenOut)
        external view
        _viewlock_
        returns (uint spotPrice)
    {
        require(_records[tokenIn].bound, "ERR_NOT_BOUND");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");
        Record storage inRecord = _records[tokenIn];
        Record storage outRecord = _records[tokenOut];
        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);
    }

    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn)
        external
        _logs_
        _lock_
    {
        require(_finalized, "ERR_NOT_FINALIZED");

        uint poolTotal = totalSupply();
        uint ratio = bdiv(poolAmountOut, poolTotal);
        require(ratio != 0, "ERR_MATH_APPROX");

        for (uint i = 0; i < _tokens.length; i++) {
            address t = _tokens[i];
            uint bal = _records[t].balance;
            uint tokenAmountIn = bmul(ratio, bal);
            require(tokenAmountIn != 0, "ERR_MATH_APPROX");
            require(tokenAmountIn <= maxAmountsIn[i], "ERR_LIMIT_IN");
            _records[t].balance = badd(_records[t].balance, tokenAmountIn);
            emit LOG_JOIN(msg.sender, t, tokenAmountIn);
            _pullUnderlying(t, msg.sender, tokenAmountIn);
        }
        _mintPoolShare(poolAmountOut);
        _pushPoolShare(msg.sender, poolAmountOut);
    }

    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut)
        external
        _logs_
        _lock_
    {
        require(_finalized, "ERR_NOT_FINALIZED");

        uint poolTotal = totalSupply();
        uint exitFee = bmul(poolAmountIn, EXIT_FEE);
        uint pAiAfterExitFee = bsub(poolAmountIn, exitFee);
        uint ratio = bdiv(pAiAfterExitFee, poolTotal);
        require(ratio != 0, "ERR_MATH_APPROX");

        _pullPoolShare(msg.sender, poolAmountIn);
        _pushPoolShare(_factory, exitFee);
        _burnPoolShare(pAiAfterExitFee);

        for (uint i = 0; i < _tokens.length; i++) {
            address t = _tokens[i];
            uint bal = _records[t].balance;
            uint tokenAmountOut = bmul(ratio, bal);
            require(tokenAmountOut != 0, "ERR_MATH_APPROX");
            require(tokenAmountOut >= minAmountsOut[i], "ERR_LIMIT_OUT");
            _records[t].balance = bsub(_records[t].balance, tokenAmountOut);
            emit LOG_EXIT(msg.sender, t, tokenAmountOut);
            _pushUnderlying(t, msg.sender, tokenAmountOut);
        }

    }


    function swapExactAmountIn(
        address tokenIn,
        uint tokenAmountIn,
        address tokenOut,
        uint minAmountOut,
        uint maxPrice
    )
        external
        _logs_
        _lock_
        returns (uint tokenAmountOut, uint spotPriceAfter)
    {

        require(_records[tokenIn].bound, "ERR_NOT_BOUND");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");
        require(_publicSwap, "ERR_SWAP_NOT_PUBLIC");

        Record storage inRecord = _records[address(tokenIn)];
        Record storage outRecord = _records[address(tokenOut)];

        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");

        uint spotPriceBefore = calcSpotPrice(
                                    inRecord.balance,
                                    inRecord.denorm,
                                    outRecord.balance,
                                    outRecord.denorm,
                                    _swapFee
                                );
        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");

        tokenAmountOut = calcOutGivenIn(
                            inRecord.balance,
                            inRecord.denorm,
                            outRecord.balance,
                            outRecord.denorm,
                            tokenAmountIn,
                            _swapFee
                        );
        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");

        inRecord.balance = badd(inRecord.balance, tokenAmountIn);
        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);

        spotPriceAfter = calcSpotPrice(
                                inRecord.balance,
                                inRecord.denorm,
                                outRecord.balance,
                                outRecord.denorm,
                                _swapFee
                            );
        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");     
        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");
        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");

        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);

        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);
        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);

        return (tokenAmountOut, spotPriceAfter);
    }

    function swapExactAmountOut(
        address tokenIn,
        uint maxAmountIn,
        address tokenOut,
        uint tokenAmountOut,
        uint maxPrice
    )
        external
        _logs_
        _lock_ 
        returns (uint tokenAmountIn, uint spotPriceAfter)
    {
        require(_records[tokenIn].bound, "ERR_NOT_BOUND");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");
        require(_publicSwap, "ERR_SWAP_NOT_PUBLIC");

        Record storage inRecord = _records[address(tokenIn)];
        Record storage outRecord = _records[address(tokenOut)];

        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), "ERR_MAX_OUT_RATIO");

        uint spotPriceBefore = calcSpotPrice(
                                    inRecord.balance,
                                    inRecord.denorm,
                                    outRecord.balance,
                                    outRecord.denorm,
                                    _swapFee
                                );
        require(spotPriceBefore <= maxPrice, "ERR_BAD_LIMIT_PRICE");

        tokenAmountIn = calcInGivenOut(
                            inRecord.balance,
                            inRecord.denorm,
                            outRecord.balance,
                            outRecord.denorm,
                            tokenAmountOut,
                            _swapFee
                        );
        require(tokenAmountIn <= maxAmountIn, "ERR_LIMIT_IN");

        inRecord.balance = badd(inRecord.balance, tokenAmountIn);
        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);

        spotPriceAfter = calcSpotPrice(
                                inRecord.balance,
                                inRecord.denorm,
                                outRecord.balance,
                                outRecord.denorm,
                                _swapFee
                            );
        require(spotPriceAfter >= spotPriceBefore, "ERR_MATH_APPROX");
        require(spotPriceAfter <= maxPrice, "ERR_LIMIT_PRICE");
        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), "ERR_MATH_APPROX");

        emit LOG_SWAP(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);

        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);
        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);

        return (tokenAmountIn, spotPriceAfter);
    }


    function joinswapExternAmountIn(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)
        external
        _logs_
        _lock_
        returns (uint poolAmountOut)

    {        
        require(_finalized, "ERR_NOT_FINALIZED");
        require(_records[tokenIn].bound, "ERR_NOT_BOUND");
        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");

        Record storage inRecord = _records[tokenIn];

        poolAmountOut = calcPoolOutGivenSingleIn(
                            inRecord.balance,
                            inRecord.denorm,
                            _totalSupply,
                            _totalWeight,
                            tokenAmountIn,
                            _swapFee
                        );

        require(poolAmountOut >= minPoolAmountOut, "ERR_LIMIT_OUT");

        inRecord.balance = badd(inRecord.balance, tokenAmountIn);

        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);

        _mintPoolShare(poolAmountOut);
        _pushPoolShare(msg.sender, poolAmountOut);
        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);

        return poolAmountOut;
    }

    function joinswapPoolAmountOut(address tokenIn, uint poolAmountOut, uint maxAmountIn)
        external
        _logs_
        _lock_
        returns (uint tokenAmountIn)
    {
        require(_finalized, "ERR_NOT_FINALIZED");
        require(_records[tokenIn].bound, "ERR_NOT_BOUND");

        Record storage inRecord = _records[tokenIn];

        tokenAmountIn = calcSingleInGivenPoolOut(
                            inRecord.balance,
                            inRecord.denorm,
                            _totalSupply,
                            _totalWeight,
                            poolAmountOut,
                            _swapFee
                        );

        require(tokenAmountIn != 0, "ERR_MATH_APPROX");
        require(tokenAmountIn <= maxAmountIn, "ERR_LIMIT_IN");
        
        require(tokenAmountIn <= bmul(_records[tokenIn].balance, MAX_IN_RATIO), "ERR_MAX_IN_RATIO");

        inRecord.balance = badd(inRecord.balance, tokenAmountIn);

        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);

        _mintPoolShare(poolAmountOut);
        _pushPoolShare(msg.sender, poolAmountOut);
        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);

        return tokenAmountIn;
    }

    function exitswapPoolAmountIn(address tokenOut, uint poolAmountIn, uint minAmountOut)
        external
        _logs_
        _lock_
        returns (uint tokenAmountOut)
    {
        require(_finalized, "ERR_NOT_FINALIZED");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");

        Record storage outRecord = _records[tokenOut];

        tokenAmountOut = calcSingleOutGivenPoolIn(
                            outRecord.balance,
                            outRecord.denorm,
                            _totalSupply,
                            _totalWeight,
                            poolAmountIn,
                            _swapFee
                        );

        require(tokenAmountOut >= minAmountOut, "ERR_LIMIT_OUT");
        
        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), "ERR_MAX_OUT_RATIO");

        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);

        uint exitFee = bmul(poolAmountIn, EXIT_FEE);

        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);

        _pullPoolShare(msg.sender, poolAmountIn);
        _burnPoolShare(bsub(poolAmountIn, exitFee));
        _pushPoolShare(_factory, exitFee);
        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);

        return tokenAmountOut;
    }

    function exitswapExternAmountOut(address tokenOut, uint tokenAmountOut, uint maxPoolAmountIn)
        external
        _logs_
        _lock_
        returns (uint poolAmountIn)
    {
        require(_finalized, "ERR_NOT_FINALIZED");
        require(_records[tokenOut].bound, "ERR_NOT_BOUND");
        require(tokenAmountOut <= bmul(_records[tokenOut].balance, MAX_OUT_RATIO), "ERR_MAX_OUT_RATIO");

        Record storage outRecord = _records[tokenOut];

        poolAmountIn = calcPoolInGivenSingleOut(
                            outRecord.balance,
                            outRecord.denorm,
                            _totalSupply,
                            _totalWeight,
                            tokenAmountOut,
                            _swapFee
                        );

        require(poolAmountIn != 0, "ERR_MATH_APPROX");
        require(poolAmountIn <= maxPoolAmountIn, "ERR_LIMIT_IN");

        outRecord.balance = bsub(outRecord.balance, tokenAmountOut);

        uint exitFee = bmul(poolAmountIn, EXIT_FEE);

        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);

        _pullPoolShare(msg.sender, poolAmountIn);
        _burnPoolShare(bsub(poolAmountIn, exitFee));
        _pushPoolShare(_factory, exitFee);
        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);        

        return poolAmountIn;
    }


    // ==
    // 'Underlying' token-manipulation functions make external calls but are NOT locked
    // You must `_lock_` or otherwise ensure reentry-safety

    function _pullUnderlying(address erc20, address from, uint amount)
        internal
    {
        bool xfer = IERC20(erc20).transferFrom(from, address(this), amount);
        require(xfer, "ERR_ERC20_FALSE");
    }

    function _pushUnderlying(address erc20, address to, uint amount)
        internal
    {
        bool xfer = IERC20(erc20).transfer(to, amount);
        require(xfer, "ERR_ERC20_FALSE");
    }

    function _pullPoolShare(address from, uint amount)
        internal
    {
        _pull(from, amount);
    }

    function _pushPoolShare(address to, uint amount)
        internal
    {
        _push(to, amount);
    }

    function _mintPoolShare(uint amount)
        internal
    {
        _mint(amount);
    }

    function _burnPoolShare(uint amount)
        internal
    {
        _burn(amount);
    }

}


#+end_src
** BToken
#+begin_src solidity

pragma solidity 0.5.12;

import "./BNum.sol";

// Highly opinionated token implementation

interface IERC20 {
    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    function totalSupply() external view returns (uint);
    function balanceOf(address whom) external view returns (uint);
    function allowance(address src, address dst) external view returns (uint);

    function approve(address dst, uint amt) external returns (bool);
    function transfer(address dst, uint amt) external returns (bool);
    function transferFrom(
        address src, address dst, uint amt
    ) external returns (bool);
}

contract BTokenBase is BNum {

    mapping(address => uint)                   internal _balance;
    mapping(address => mapping(address=>uint)) internal _allowance;
    uint internal _totalSupply;

    event Approval(address indexed src, address indexed dst, uint amt);
    event Transfer(address indexed src, address indexed dst, uint amt);

    function _mint(uint amt) internal {
        _balance[address(this)] = badd(_balance[address(this)], amt);
        _totalSupply = badd(_totalSupply, amt);
        emit Transfer(address(0), address(this), amt);
    }

    function _burn(uint amt) internal {
        require(_balance[address(this)] >= amt, "ERR_INSUFFICIENT_BAL");
        _balance[address(this)] = bsub(_balance[address(this)], amt);
        _totalSupply = bsub(_totalSupply, amt);
        emit Transfer(address(this), address(0), amt);
    }

    function _move(address src, address dst, uint amt) internal {
        require(_balance[src] >= amt, "ERR_INSUFFICIENT_BAL");
        _balance[src] = bsub(_balance[src], amt);
        _balance[dst] = badd(_balance[dst], amt);
        emit Transfer(src, dst, amt);
    }

    function _push(address to, uint amt) internal {
        _move(address(this), to, amt);
    }

    function _pull(address from, uint amt) internal {
        _move(from, address(this), amt);
    }
}

contract BToken is BTokenBase, IERC20 {

    string  private _name     = "Balancer Pool Token";
    string  private _symbol   = "BPT";
    uint8   private _decimals = 18;

    function name() public view returns (string memory) {
        return _name;
    }

    function symbol() public view returns (string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }

    function allowance(address src, address dst) external view returns (uint) {
        return _allowance[src][dst];
    }

    function balanceOf(address whom) external view returns (uint) {
        return _balance[whom];
    }

    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    function approve(address dst, uint amt) external returns (bool) {
        _allowance[msg.sender][dst] = amt;
        emit Approval(msg.sender, dst, amt);
        return true;
    }

    function increaseApproval(address dst, uint amt) external returns (bool) {
        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);
        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);
        return true;
    }

    function decreaseApproval(address dst, uint amt) external returns (bool) {
        uint oldValue = _allowance[msg.sender][dst];
        if (amt > oldValue) {
            _allowance[msg.sender][dst] = 0;
        } else {
            _allowance[msg.sender][dst] = bsub(oldValue, amt);
        }
        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);
        return true;
    }

    function transfer(address dst, uint amt) external returns (bool) {
        _move(msg.sender, dst, amt);
        return true;
    }

    function transferFrom(address src, address dst, uint amt) external returns (bool) {
        require(msg.sender == src || amt <= _allowance[src][msg.sender], "ERR_BTOKEN_BAD_CALLER");
        _move(src, dst, amt);
        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {
            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);
            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);
        }
        return true;
    }
}
#+end_src
** Migrations
#+begin_src solidity
pragma solidity 0.5.12;

contract Migrations {
    address public owner;
    uint public lastCompletedMigration;

    constructor() public {
        owner = msg.sender;
    }

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function setCompleted(uint completed) external restricted {
        lastCompletedMigration = completed;
    }

    function upgrade(address new_address) external restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(lastCompletedMigration);
    }
}


#+end_src
* balancer reports

#+begin_src solidity

function calcSpotPrice

function calcOutGivenIn

function calcInGivenOut

function calcPoolOutGivenSingleIn

function calcSingleInGivenPoolOut

function calcSingleOutGivenPoolIn

function calcPoolInGivenSingleOut

#+end_src
