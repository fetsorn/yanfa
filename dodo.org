#+TITLE: Dodo

* dodo questions
how lp deposit, one or two?
  - one
pmm equlibrium in amount or value?
  - amount
why quotes are always stablecoins?
  - because market prices is pegged to usd
why roi on base and quote tokens are different?
  - because commisions are paid in tokens that are received, and only one type of xacts will be prevalent in a market
  - because roi is paid in tokens with different volatility, different value
how a deposit or a withdrawal influnces a regression target
  - a deposit adds to a regression target
* dodo docs
** Start
*** Introduction to DODO
**** What is DODO#

DODO is a next-generation on-chain liquidity provider, which leverages the Proactive Market Maker algorithm (PMM) to provide pure on-chain and contract-fillable liquidity for everyone.
**** How does DODO work#

DODO accepts liquidity providers’ assets. It gathers funds near market prices to provide sufficient liquidity. In order to minimize counterparty risks for LPs, DODO dynamically adjusts market prices to encourage arbitrageurs to step in and stabilize LPs' portfolios.
**** Why DODO#
 - Low slippage
 - Single risk exposure
 - No impermanent loss
**** What can I do with DODO#
***** As a trader#
 - Each and every trader enjoys sufficient liquidity similar to that of centralized exchanges
 - Arbitrageurs can profit from price discrepancies between DODO and other exchanges
 - Smart contracts can natively use DODO liquidity to complete on-chain transactions, such as liquidation and auctions
***** As a LP#
 - There are no minimal deposit requirements and restrictions on asset types
 - DODO charges a fee for each transaction and eventually distributes it to LPs as rewards
 - LPs can create trading pairs with their own tokens
 - LPs can obtain liquidity by depositing their tokens they already own, without taking on price risk
** Protocol
*** The DODO Advantage
**** Overview#

DODO is powered by a ground-breaking algorithm called Proactive Market Maker (PMM). PMM leverages price oracles to retrieve accurate market prices of assets as input. It then aims to provide sufficient liquidity near the market price for every asset. The result is that liquidity decreases rapidly when far away from the market price. The following graphs compare the price curves of DODO (PMM) and Uniswap (AMM).

With everything else fixed, it is clear that the PMM curve is significantly flatter than the AMM curve near the market price, indicating higher fund utilization and lower slippage. Prices provided by PMM are more favorable than AMM.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_curve.jpeg]]

As the market price changes, AMM passively relies on arbitrage trading to change prices. On the other hand, PMM proactively shifts the price curve in the same direction to ensure that the section in the vicinity of the market price remains flat. This ensures the constant provision of sufficient liquidity.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_curve_move.jpeg]]

PMM outperforms AMM solutions in several important aspects.
**** High Fund Utilization#

As seen in the above graphs, PMM, like AMMs, provides liquidity in the price range of zero to positive infinity, but the PMM price curve is significantly flatter in the area near the oracle (market) price. That is, most of the funds are gathered near the market price, which allows for more active, frequent trading, increasing fund utilization.
**** Single Risk Exposure#

In the price curves above, each price curve consists of two parts: the bidding side to the left and the asking side to the right. These two parts may have different depth, or liquidity, resulting in what is known as the bid-ask spread.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_segment.jpeg]]

In PMM, the asking liquidity is solely determined by the amount of base token in the pool, and the bidding liquidity is solely determined by the amount of quote tokens in the pool. It allows the base and quote pools to have different sizes, and thus allows liquidity providers to deposit any amount of either quote or base tokens, rather than both (like Uniswap). DODO Liquidity providers deposit what they already have, nothing more.

#+begin_quote
note
The design is intuitive, because when you take an asking order, you take liquidity providers’ base tokens and the quote tokens are irrelevant.
#+end_quote

**** No Impermanent Loss#

But what about impermanent loss, i.e. how does PMM ensure that liquidity providers get what they deposited when they withdraw their tokens? The answer is by encouraging arbitrage trading. When individual traders buy base tokens, PMM slightly increases the price to make it more profitable for arbitrageurs to sell base tokens. In PMM, arbitrage trading makes sure that the number of tokens in the pool is always roughly equal to the number of tokens deposited by liquidity providers. This scheme effectively mitigates impermanent loss for liquidity providers, making liquidity provision on DODO a low-risk affair.
**** Next Generation of Liquidity Provision#

Liquidity is the most important resource in the DeFi world, because it is the foundational element in all DeFi projects. There are two major proven approaches to decentralized liquidity provision today:

 - Algorithmic market makers (e.g. Uniswap)
 - Orderbook-based order matching (e.g. dYdX)

However, they are both flawed.

 - Compared to centralized exchanges, algorithmic market makers cannot provide sufficient liquidity for mainstream assets. In addition, for niche, long-tail assets, AMM can only provide very basic liquidity support
 - Orderbook-based order matching relies on human market makers to mirroring centralized exchanges liquidity. Effective market makers are expensive, and very few DEX teams can afford them. In addition, this kind of liquidity is difficult to be filled by smart contracts due to the human elements involved, significantly limiting the number of use cases for DeFi practitioners

PMM is also an algorithmic market maker algorithm, but it fundamentally differs from other approaches by mitigating and eliminating their disadvantages and amplifying their advantages. PMM provides sufficient and contract-fillable liquidity on-chain for all assets, empowering DeFi users to take advantage of composability.
*** Core Concepts
**** Base & Quote Tokens#

Base and quote are two concepts that will be mentioned frequently. Two easy ways to distinguish between them are:

 - In a trading pair, the base is always the token before the hyphen, and quote after
 - In transactions, price refers to how many quote tokens are needed in exchange for one base token

For example, in the ETH-USDC trading pair, ETH is the base token and USDC is the quote token
**** PMM Parameters#

The funding pool of PMM is described by four parameters:

 - B₀: base token regression target - total number of base tokens deposited by liquidity providers
 - Q₀: quote token regression target - total number of quote tokens deposited by liquidity providers
 - B: base token balance - number of base tokens currently in the pool
 - Q: quote token balance - number of quote tokens currently in the pool

**** PMM Pricing Formula#

The PMM price curve is plotted by the following pricing formula:

Pmargin=iR

Where R is defined to be the piecewise function below:

if B<B₀, R = 1 − k + (B₀/B)^2 * k
if Q<Q₀, R = 1 / (1 − k + (Q₀/Q)^2 * k)
else R=1

Pmargin=iR

if B<B₀, R = 1 + (B₀/B)^2
if Q<Q₀, R = 1 / (1 + (Q₀/Q)^2)
else R=1

if B<B₀, R = 0.5 + (B₀/B)^2 * 0.5
if Q<Q₀, R = 1 / (0.5 + (Q₀/Q)^2 * 0.5)
else R=1

p=Ri
R=0.5+x
p=i*(0.5+x)=0.5i + 0.5i

i is the market price provided by an oracle, and k is a parameter in the range (0, 1).
**** The Three Possible States in PMM#

At any given time, PMM is in one of three possible states: equilibrium, base token shortage, and quote token shortage.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_mode_switch.jpeg]]

Initially, i.e. prior to any transaction, the capital pool is in equilibrium, and both base tokens and quote token are at their regression targets. That is, B=B0​ and Q=Q0​.

When a trader sells base tokens, the base token balance of the capital pool is higher than the base token regression target; conversely, the quote token balance is now lower than the quote token regression target. In this state, PMM will try to sell the excess base tokens, lowering the base token balance and increasing the quote token balance, in order to move this state back to the state of equilibrium.

When a trader buys base tokens, the quote token balance of the capital pool is higher than the quote token regression target; conversely, the base token balance is now lower than the base token regression target. In this state, PMM will try to sell the excess quote tokens, lowering the quote token balance and increasing the base token balance, in order to move this state back to the state of equilibrium.

The parameter R in the pricing formula above assumes a critical role in facilitating this regression process. The more the capital pool deviates from the equilibrium state, the more R deviates from 1. When the price given by the PMM algorithm deviates from the market price, arbitrageurs step in to help bring the capital pool back to the equilibrium state.
**** Liquidity Provider Fee#

A small amount of transaction fee will be charged on every trade. This fee is called the liquidity provider fee and will be distributed to every liquidity provider based on their proportional stake in the capital pool.

More specifically, liquidity provider fees are collected from what buyers received and distributed to liquidity providers who supplied this kind of asset to the capital pool. In other words, liquidity providers are rewarded in the same asset denomination.

For example, when traders buy ETH tokens with USDC tokens, liquidity provider fees will be charged in the form of ETH tokens, and distributed to liquidity providers who deposited ETH tokens into the capital pool.

When traders sell ETH tokens for USDC tokens, liquidity provider fees will be charged in the form of USDC tokens, and distributed to liquidity providers who deposited USDC tokens into the capital pool.
#+begin_quote
note
Base and quote tokens have different returns on investments (ROI) in PMM's funding pool.
#+end_quote
**** Maintainer fee#

A maintainer fee is also collected from what buyers received, and will be directly transferred to the maintainer. The maintainer may be a development team, a foundation, or a staking decentralized autonomous organization (DAO).

Currently, the maintenance fee on DODO is 0.
**** Withdrawal Fee#

A withdrawal will change the PMM price curve and may harm the interests of other liquidity providers. DODO charges a withdrawal fee from liquidity providers who withdraw their assets and distribute it to all remaining liquidity providers.
#+begin_quote
important
Normally, the withdrawal fee is 0 or an extremely small percentage (<0.01%) of what you withdraw. The withdrawal fee will increase significantly only if the funding pool suffers from a serious shortage of either base or quote tokens and liquidity providers intend to withdraw the type of token in shortage.
The withdrawal fee serves as a protection mechanism for liquidity providers who maintain their supplies of liquidity and contribute to the sustainability and overall health of the DODO platform.
#+end_quote

**** Deposit Rewards#

Rewards will be distributed to those who make a deposit of base(quote) tokens when the capital pool faces a shortage of base(quote) tokens.

In the next section, we will explain the math behind these core concepts.
**** Flexibility and k, the "Liquidity Parameter"#

Last but not least, we will introduce the DODO's "liquidity parameter", k. The parameter k gives DODO the flexibility to handle different market situations.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_k.jpeg]]

When k is 0, DODO naively sells or buys at market price, as shown by the flat, blue line. As k increases, DODO’s price curve becomes more “curved”, but, consequently, liquidity becomes increasingly jeopardized, because more funds are placed far away from market price and are thus underutilized or not utilized at all. When k increases to 1, the flat section near the market price is completely eliminated and the curve essentially becomes a standard AMM curve, which Uniswap uses.

Normally, k is recommended to be a relatively small value, such as 0.1, which could provide liquidity 10 times better than the standard AMM algorithm.
*** The Math Behind PMM
**** Core PMM#

The core of PMM is essentially calculating one integral and solving two quadratic equations. The smart contract implementation can be found here.
***** The Price Curve Integral#

For traders, the most important thing is the average transaction price. The average transaction price is the integral of the marginal price Pmargin​. Let's take the base token shortage scenario as an example.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_integrate.jpeg]]

ΔQ=∫B1B2PmargindB

=∫B1B2(1−k)i+i(B0/B)2kdB

=i(B2−B1)∗(1−k+kB02B1B2)

This tells the trader how much they should pay if they buy B1−B2​ amount of base tokens.

Rearranging the equation above, the average transaction price is thus: P=ΔQB2−B1=i∗(1−k+kB02B1B2)P=\frac{\Delta Q}{B_2-B_1}=i*(1-k+k\frac{B_0^2}{B_1B_2})P=B2​−B1​ΔQ​=i∗(1−k+kB1​B2​B02​​)

We found that the average transaction price is only dependent on the state of the system before and after the transaction, so the price calculation methods for both buying and selling are the same: integrating Pmargin​.
***** Solving the quadratic equation for trading#

Without the loss of generality, the integral becomes the following when there is a shorage of quote tokens:

ΔB=1i(Q2−Q1)∗(1−k+kQ02Q1Q2)\Delta B = \frac{1}{i}(Q_2-Q_1)*(1-k+k\frac{Q_0^2}{Q_1Q_2})ΔB=i1​(Q2​−Q1​)∗(1−k+kQ1​Q2​Q02​​)

Let's derive how to calculate the price when there is a shortage of quote tokens and only the number of base tokens you want to buy or sell (i.e. ΔB\Delta BΔB) is given.

Now that ΔB,Q0,Q1\Delta B, Q_0, Q_1ΔB,Q0​,Q1​ are given, we need to calculate Q2Q_2Q2​, which is found by solving a quadratic equation. Transforming the equation into standard form:

(1−k)Q22+(kQ02Q1−Q1+kQ1−iΔB)Q2−kQ02=0(1-k)Q_2^2+(\frac{kQ_0^2}{Q_1}-Q_1+kQ_1-i\Delta B)Q_2-kQ_0^2=0(1−k)Q22​+(Q1​kQ02​​−Q1​+kQ1​−iΔB)Q2​−kQ02​=0

let a=1−k, b=kQ02Q1−Q1+kQ1−iΔB, c=−kQ02let \ a=1-k, \ b=\frac{kQ_0^2}{Q_1}-Q_1+kQ_1-i\Delta B, \ c=-kQ_0^2let a=1−k, b=Q1​kQ02​​−Q1​+kQ1​−iΔB, c=−kQ02​

Because Q2>=0Q_2>=0Q2​>=0, we discard the negative root, and so

Q2=−b+b2−4ac2aQ_2=\frac{-b+\sqrt{b^2-4ac}}{2a}Q2​=2a−b+b2−4ac

​​

It can be proven that:

    When ΔB>0\Delta B>0ΔB>0, Q2>Q1Q_2>Q_1Q2​>Q1​; trader buy base token, and should pay Q2−Q1Q_2-Q_1Q2​−Q1​
    When ΔB<0\Delta B<0ΔB<0, Q2<Q1Q_2<Q_1Q2​<Q1​; trader sell base token, and will receive Q1−Q2Q_1-Q_2Q1​−Q2​
    When ΔB=0\Delta B=0ΔB=0, Q2=Q1Q_2=Q_1Q2​=Q1​.

***** Solving the quadratic equation for regression targets#

When the system is not in the equilibrium state, changes to the oracle price will bring profit or loss. For example, assume that shortage of base tokens is the current state, and the oracle price goes up. It is clear that the excess quote tokens cannot buy enough base tokens to return the base token balance to the base token regression target. Thus, LPs who deposited base tokens will suffer a loss. Conversely, if the oracle price drops, the excess quote tokens can buy more base tokens, causing the base token balance to exceed the base token regression target, and LPs who deposited base tokens will make a profit.

In summary, the regression target is influenced by the oracle price. To calculate the regression target at a certain oracle price, we make the following derivation:

Given ΔQ=i(B2−B1)∗(1−k+kB02B1B2)\Delta Q = i(B_2-B_1)*(1-k+k\frac{B_0^2}{B_1B_2})ΔQ=i(B2​−B1​)∗(1−k+kB1​B2​B02​​)

Since we are doing regression, B2=B0B_2=B_0B2​=B0​. Rearraging the equation with respect to B0B_0B0​ gives

kB1B02+(1−2k)B0−[(1−k)B1+ΔQi]=0\frac{k}{B_1}B_0^2+(1-2k)B_0-[(1-k)B_1+\frac{\Delta Q}{i}] = 0B1​k​B02​+(1−2k)B0​−[(1−k)B1​+iΔQ​]=0

The negative root does not make sense and is discarded, so B0B_0B0​ is:

B0=B1+B11+4kΔQB1i−12kB_0=B_1+B_1\frac{\sqrt{1+\frac{4k\Delta Q}{B_1 i}}-1}{2k}B0​=B1​+B1​2k1+B1​i4kΔQ​

​−1​

In this case, ΔQ=Q−Q0\Delta Q=Q-Q_0ΔQ=Q−Q0​. It can be proven that, when ΔQ≥0\Delta Q \ge 0ΔQ≥0, B0≥B1B_0\ge B_1B0​≥B1​.

This fact is extremely important, because it ensures that the base token balance and the quote token balance will never be greater than the regression target simultaneously, or less than the regression target simultaneously. This means that PMM will only switch between the three states discussed in the Core Concepts section.

Similarly, the formula for quote token regression target Q0Q_0Q0​ is

Q0=Q1+Q1∗1+4kΔBiQ1−12kQ_0=Q_1+Q_1*\frac{\sqrt{1+\frac{4k\Delta B i}{Q_1}}-1}{2k}Q0​=Q1​+Q1​∗2k1+Q1​4kΔBi​

​−1​
**** Peripheral#

This section will deal with the math pertaining to the peripheral functioning of PMM.
***** Trades#

As mentioned above, the regression target depends on the oracle price, and the price curve in turn depend on the regression target. So in every trade, we should calculate the regression target well in advance to make the price curve fixed.

In addition, since the price curve given by PMM is segmented, if a transaction involves different states (for example, when a trader sells an astronomical amount of base tokens during a base token shortage and forces the state into a quote token shortage), the price needs to be calculated in segments as well.

Please be advised that this calculation requires a high degree of accuracy. The smart contract provides six trading functions for the three possible states. You can find the most important logic of cross-state trading here.
***** Deposit#

Depositing and withdrawing base token when there is a shortage of base tokens, or quote tokens when there is a shortage of quote token, will change the price curve. This requires us to process the deposit and withdrawal with caution and care in order to keep the capital pool sustainable and fair.

We will analyze what happens when an LP makes a deposit when there is a shortage of base tokens.

According to the calculation formula of B0B_0B0​ derived above B0=B1+B1∗1+4kΔQB1i−12kB_0=B_1+B_1*\frac{\sqrt{1+\frac{4k\Delta Q}{B_1 i}}-1}{2k}B0​=B1​+B1​∗2k1+B1​i4kΔQ​

​−1​

After an LP deposit bbb base tokens, B1B_1B1​ increases by bbb, and B0B_0B0​ increases more than than bbb's magnitude. It means that this deposit helps all LPs who provided base token make a profit. The reason why is that the deposit makes the price curve smoother, and the same amount of ΔQ\Delta QΔQ can now buy more base tokens.

In this case, as soon as the LP makes a deposit, the LP makes a profit. This is referred to as the deposit reward. The essential source of this reward is the slippage paid by the trader who made the system deviate from equilibrium state.
#+begin_quote
note
It is important to note that deposit rewards are not risk-free arbitrage trading opportunities.
#+end_quote
***** Withdrawal#

Similarly, after an LP withdraws bbb base tokens, B1B_1B1​ decreases by bbb, and B0B_0B0​ decreases by more than bbb's magnitude. This withdrawal causes all LPs who owes Base Tokens to suffer losses. This is because this withdrawal makes the price curve more steep, and the excess quote tokens have less purchasing power in terms of base tokens.

The PMM algorithm stipulates that a withdrawal fee is required to withdraw tokens in this case. The magnitude of the fee is equal to the aggregate loss of all LPs caused by the withdrawal. This fee will be directly distributed to all LPs that have not yet withdrawn.

Factoring in the deposit reward from the previous section, if an LP makes a withdrawal immediately after depositing, the withdrawal fee will be greater than the deposit reward, thus eliminating any possibility of risk-free arbitrage trading.

It is worth noting that both deposit reward and withdrawal fee are only significant when the system deviates very far from the equilibrium state and the deposit/withdrawal amount is large. Traders thus often overlook the existence of this gain/loss. Of course, traders are also welcome to extract value from the system by exploiting this if they so wish. In order to do that, they can first deposit to earn deposit rewards when the system deviates from the equilibrium, and then withdraw once the system returns to the equilibrium to avoid the withdrawal fee.
** Contract
*** Smart Contract Framework
**** Overview#

DODO is built with a set of smart contracts. The following figure shows the framework of these contracts and how they interact with each other in the DODO architecture.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_framework.jpeg]]

**** Core#

The core part of the DODO framework, which contains all the data and logic of DODO, consists of a set of DODO Proxy contracts and a singular DODO Implementation contract. Each trading pair binds with an independent DODO Proxy contract (e.g. WETH-USDC, DAI-USDT, etc.), which is a transparent proxy that only stores states and metadata. All underlying logic lies in the DODO Implementation contract.

For convenience's sake, we will call the transparent proxy DODO Pair and the logic implementation DODO Template. Users should interact with DODO Pair directly or through Helper.
**** Entrance#

DODO is an open-source contract, and the DODO team welcomes forks. However, it is important to note that the operation of DODO Pair is highly dependent on oracles and parameter fine-tuning, and a misconfigured DODO Pair could potentially cause significant losses for users. Therefore, we deployed an entrance contract to help blockchain developers navigate these obstacles. All DODO Pairs registered in this contract have been rigorously tested and audited, as the DODO team believes the safety of DODO users is of utmost importance. Developers should only look for the entrance called DODO Zoo when developing upon DODO. Even if the DODO Template is upgraded, DODO Zoo will remain unchanged.
**** Helper#

There are a lot of tedious tasks that can be packaged using contracts to make them easy to use and understand. For example, the DODO ETH Proxy shown in the figure above helps users convert between ETH and WETH and interact with DODO Pair. This way, the underlying complexity with WETH is abstracted away from users, effectively protecting them - users do and should only care about directly buying or selling ETH on DODO. There are many such contracts, such as arbitrage and route, which we collectively call Helper. We invite the community to help develop more helper contracts and we are willing to provide guidance and support.
*** User Guide
**** For traders#

There are only two functions that are relevant to traders in the entire contract: buyBaseToken and sellBaseToken
#+begin_src solidity
    uint256 amount,
    uint256 maxPayQuote,
    bytes calldata data
) external returns (uint256 payQuote);
#+end_src

This function buys an exact amount of base tokens. If the number of quote tokens needed to pay for these base tokens is larger than maxPayQuote, the transaction will be reverted. If data is not null，flash swap will be triggered.

The return value payQuote is the exact amount of quote tokens you will pay.
#+begin_src solidity
function sellBaseToken(
    uint256 amount,
    uint256 minReceiveQuote,
    bytes calldata data
) external returns (uint256 receiveQuote);
#+end_src

This function sells an exact amount of base tokens. If the the number of quote tokens to be received is smaller than minReceiveQuote, the transaction will be reverted. If data is not null，flash swap will be triggered.

The return value receiveQuote is the exact amount of quote tokens you will receive.

DODO also provides a view version of these two functions. View functions can be executed without sending transactions and they help users estimate prices bore spending gas.
#+begin_src solidity
function querySellBaseToken(
  uint256 amount
) external view returns (uint256 receiveQuote);

function queryBuyBaseToken(
  uint256 amount
) external view returns (uint256 payQuote);
#+end_src

In the next section, we will go into more details about flash swap.
**** For Liquidity Providers (LPs)#

For liquidity providers (LPs), the most important functions are deposit and withdrawal. We provide a set of functions to help LPs manage their assets in a flexible and efficient manner.

One of the biggest advantages of the PMM algorithm is that it can manage base or quote token assets separately. That is why the functions below all have two versions, one with the suffix "Base" and another with the suffix "Quote", to manage base and quote assets respectively. These two versions have the same input and output values.

#+begin_src solidity

  function depositBase(
    uint256 amount
  ) external returns (uint256 capital)

  function depositQuote(
    uint256 amount
  ) external returns (uint256 capital)

#+end_src

This function deposits an exact amount of assets into the capital pool and returns the capital amount issued for you.

#+begin_quote
note
Capital represents the LP's share of the capital pool. Capital is an ERC20 token and can be freely traded. Each DODO has two kinds of capital, which represent the share of base token and quote token capital pool respectively.
#+end_quote

#+begin_src solidity

  function getLpBaseBalance(address lp)
      public view returns (uint256 lpBalance)

  function getLpQuoteBalance(address lp)
      public view returns (uint256 lpBalance)

#+end_src

Query the pool balance based on the address of the LP. The return value lpBalance represents actual base or quote tokens, not capital tokens.

#+begin_src solidity

  function withdrawBase(
    uint256 amount
  ) external returns (uint256 receive)

  function withdrawQuote(
    uint256 amount
  ) external returns (uint256 receive)

#+end_src

This function attempts to withdraw an amount of assets from the capital pool. Since there may be a withdrawal fee, the function returns the exact amount of tokens received by the message sender.

#+begin_src solidity
  function withdrawAllBase() external returns (uint256 receive)

  function withdrawAllQuote() external returns (uint256 receive)
#+end_src

Since the size of the capital pool is constantly changing (transactions may occur at any time), in order to help LPs to completely withdraw all assets, the above two functions will consume all the capital of the message sender and withdraw the corresponding assets. Finally, the exact amount of asset received by the message sender is returned.

#+begin_src solidity
  function getWithdrawQuotePenalty(uint256 amount) public view returns (uint256 penalty)

  function getWithdrawBasePenalty(uint256 amount) public view returns (uint256 penalty)
#+end_src

In some cases, asset withdrawals will be charged a fee. The above two functions provide a view function to query the withdrawal fee. If you submit a request with an amount of withdrawal, you will be charged for the amount of penalty.

#+begin_quote
note

The final amount of withdrawal assets received will be amount-penalty.
#+end_quote

**** For Developers#

Developers can fetch metadata from DODO Zoo, the entrance part of the DODO framework.

#+begin_src solidity
  function getDODO(
    address baseToken,
    address quoteToken
  ) external view returns (address)
#+end_src

Given baseToken and quoteToken, there is only one DODO Pair registered in DODO Zoo at the same time.
*** Flash Swap
Flash Swap
**** What is Flash Swap#

Simply put, you are allowed to pay on credit on DODO! When you buy tokens DODO, you can first get the tokens you want to buy, do anything you want with the tokens, and pay for them later.
**** How Does Flash Swap Work#

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_flash_swap.jpeg]]

The figure above illustrates the four steps in a flash swap happening under the hood

 1. Call the buyBaseToken function from the DODO Pair smart contract
 2. DODO Pair transfers the base tokens to the message sender
 3. If the parameter data of the buyBaseToken function call is not null, the DODO Pair smart contract will call the dodoCall method of the message sender
 4. After the dodoCall is executed, the DODO Pair smart contract will retrieve the quote tokens required for this transaction from the message sender

#+begin_quote
note

The sellBaseToken function can also perform flash swap in the same way.
#+end_quote

Flash swap requires the message sender to be a contract that implements the IDODOCallee interface.

#+begin_src solidity
interface IDODOCallee {
    function dodoCall(
        bool isBuyBaseToken,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata data
    ) external;
}
#+end_src
**** What Can Flash Swap Do#

Flash swap can significantly improve market efficiency. Market parity is maintained by arbitrageurs, and flash swap completely removes capital requirements for them, essentially eliminating the barrier of entry to arbitrage trading.

We will demonstrate a completely trustless and risk-free arbitrage trading contract as a use case of flash swap. Please refer to the UniswapArbitrageur.sol source code for a concrete example. It has already been deployed and you can check out its Etherscan link here

The following figure illustrates how an arbitrageur might take advantage of the price discrepancies between DODO and Uniswap.

#+ATTR_ORG: :width 500
https://dodoex.github.io/docs/img/dodo_one_click_arbitrage.jpeg

A complete arbitrage trading maneuver consists of the following 9 steps:

 1. The user calls executeBuyArbitrage on UniswapArbitrageur
 2. UniswapArbitrageur calls buyBaseToken on DODO Pair and triggers flash swap
 3. DODO Pair transfers 1 WETH to UniswapArbitrageur
 4. DODO Pair calls dodoCall on UniswapArbitrageur
 5. UniswapArbitrageur transfers 1 WETH received from DODO Pair to UniswapV2
 6. UniswapArbitrageur calls swap on UniswapV2
 7. UniswapV2 transfers 200 USDC to UniswapArbitrageur
 8. DODO Pair calls transferFrom and retrieves 150 USDC from UniswapArbitrageur
 9. UniswapArbitrageur transfers the remaining 50 USDC to the user

In summary,

 - Steps 2, 3, 4, and 8 take care of the DODO front
 - Steps 5, 6, and 7 take care of the Uniswap front
 - The user is only exposed to the process of sending transactions and making profits, with everything else abstracted away!

The best part about the UniswapArbitrageur contract is that users do not need any capital, nor do they need to know how DODO and Uniswap work. They would simply call a function and, if the execution succeeds, make a profit. If the execution fails, the users would only lose some gas.

In order to avoid unnecessary gas consumption, we recommend that users use eth_call to execute executeBuyArbitrage or executeSellArbitrage in advance to estimate arbitrage returns. If there is an arbitrage opportunity, these two functions will return profit of quote tokens and base tokens after successful execution.
**** Some Thoughts on Flash Swap#

Once you have a deep understanding of flash swap, you will realize the superiority of the DeFi world over the centralized world. The composability of smart contracts has elevated the fund utilization of DeFi to an unprecedented level. Thanks to trustlessness, the cost of credit in DeFi is incredibly low. Once this financial system is integrated into the real world, its potential for improving our society and productivity will be truly boundless. The DODO team hopes that flash swap serves as a primer for DeFi builders and beginners alike to gain an appreciation for the power of DeFi.

#+begin_quote
note

Flash swap was inspired by dYdX and Uniswap. The DODO team genuinely appreciates and admires what these DeFi pioneers have done before us 👍
#+end_quote

*** Deployment Information
**** DODO Token#
| Contract Name             |                                    Address |
| DODO Token                | 0x43dfc4159d86f3a37a5a4b3d4580b888ad7d4ddd |
| DODO Pair: DODO-USDT      | 0x8876819535b48b551c9e97ebc07332c7482b4b2d |
| DODO Mining               | 0xaed7384f03844af886b830862ff0a7afce0a632c |
| Pre-allocation            | 0x0e504d3e053885a82bd1cb5c29cbaae5b3673be4 |
| Incentive Program Reserve | 0x4447183c50e82A8b0141718c405381a3b1bad634 |
| Locked Token Vault 1      | 0x9224fc9d1389734cebb7cb29545bddc546fb9802 |
| Locked Token Vault 2      | 0xde25cebdd50ff2af17bbc8b3cbf2e31c48b769b4 |
| Undistributed Token Vault | 0x3e19d726ed435AfD3A42967551426b3A47c0F5b7 |
**** DODO V1.5#
| Contract Name       |                                    Address |
| DODO Smart Approve  | 0xCB859eA579b28e02B87A1FDE08d087ab9dbE5149 |
| DODO Smart Proxy V1 | 0xd0678Ec59d1337e29D1E1B1b6338f3E85D311F5e |
**** Mainnet#
| Contract Name                  |                                    Address |
| DODO Pair: WETH-USDC           | 0x75c23271661d9d143dcb617222bc4bec783eff34 |
| DODO Pair: LINK-USDC           | 0x562c0b218cc9ba06d9eb42f3aef54c54cc5a4650 |
| DODO Pair: LEND-USDC           | 0xc226118fcd120634400ce228d61e1538fb21755f |
| DODO Pair: AAVE-USDC           | 0x94512fd4fb4feb63a6c0f4bedecc4a00ee260528 |
| DODO Pair: SNX-USDC            | 0xca7b0632bd0e646b0f823927d3d2e61b00fe4d80 |
| DODO Pair: COMP-USDC           | 0x0d04146b2fe5d267629a7eb341fb4388dcdbd22f |
| DODO Pair: WBTC-USDC           | 0x2109f78b46a789125598f5ad2b7f243751c2934d |
| DODO Pair: YFI-USDC            | 0x1b7902a66f133d899130bf44d7d879da89913b2e |
| DODO Pair: FIN-USDT            | 0x9d9793e1e18cdee6cf63818315d55244f73ec006 |
| DODO Pair: USDT-USDC           | 0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD |
| DODO Pair: WOO-USDT            | 0x181d93ea28023bf40c8bb94796c55138719803b4 |
| DODO Pair: wCRES-USDT          | 0x85f9569b69083c3e6aeffd301bb2c65606b5d575 |
| DODO Zoo                       | 0x3a97247df274a17c59a3bd12735ea3fcdfb49950 |
| DODO EthProxy                  | 0x37adc35f7b12582240818df04aac04ca409d5913 |
| DODO EthProxy (compatible)     | 0x3d7cbd8ae59505283d438eb6ff54b8b42d0c98a6 |
| Uniswap arbitrageur            | 0xbf90b54cc00ceeaa93db1f6a54a01e3fe9ed4422 |
| Multisig Wallet with Time Lock | 0x6dae6ae227438378c117821c51fd61661faa8893 |
| Gnosis Multisig Wallet         | 0x95C4F5b83aA70810D4f142d58e5F7242Bd891CB0 |
**** DLP Token Address#
| DLP              |                                    Address |
| WETH-USDC : WETH | 0xc11eCCDee225d644f873776A68A02eCD8c015697 |
| WETH-USDC : USDC | 0x6a5Eb3555cBbD29016Ba6F6fFbCcEE28D57b2932 |
| LINK-USDC : LINK | 0xF03F3d2FbeE37F92eC91aE927a8019CACef4b738 |
| LINK-USDC : USDC | 0x0F769BC3EcbdA8e0d78280c88e31609E899A1F78 |
| LEND-USDC : LEND | 0xbF999544B31706C5fEf693b64a6c2cD8ddB5BBeC |
| LEND-USDC : USDC | 0xD768B486645717a55Ed97126bBE2eB8b02f0e9b3 |
| SNX-USDC: SNX    | 0x5bd1b7d3930d7a5e8fd5aeec6b931C822C8Be14E |
| SNX-USDC: USDC   | 0x1b06A22b20362b4115388Ab8ca3ED0972230d78A |
| COMP-USDC: COMP  | 0x53Cf4694B427FcEf9BB1F4438B68dF51A10228D0 |
| COMP-USDC: USDC  | 0x51baf2656778ad6D67b19A419F91D38C3d0b87B6 |
| WBTC-USDC: WBTC  | 0x2eC2A42901c761b295a9e6b95200cd0BdAa474Eb |
| WBTC-USDC: USDC  | 0x0cDb21e20597d753C90458f5eF2083f6695eb794 |
| YFI-USDC: YFI    | 0xE2852C572FC42C9e2ec03197deFa42c647e89291 |
| YFI-USDC: USDC   | 0xD9D0bd18DDfA753d0c88a060fFb60657bB0D7A07 |
| USDT-USDC: USDT  | 0xE2852C572FC42C9e2ec03197deFa42c647e89291 |
| USDT-USDC: USDC  | 0xD9D0bd18DDfA753d0c88a060fFb60657bB0D7A07 |
| AAVE-USDC: AAVE  | 0x30ad5b6d4e531591591113b49eae2fafbc2236d5 |
| AAVE-USDC: USDC  | 0x5840a9e733960f591856a5d13f6366658535bbe5 |
**** Related Token Address#
| Symbol         |                                    Address |
| WETH           | 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 |
| USDT           | 0xdac17f958d2ee523a2206206994597c13d831ec7 |
| USDC           | 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48 |
| WBTC           | 0x2260fac5e5542a773aa44fbcfedf7c193bc2c599 |
| LINK           | 0x514910771af9ca656af840dff83e8264ecf986ca |
| LEND(old AAVE) | 0x80fb784b7ed66730e8b1dbd9820afd29931aab03 |
| AAVE           | 0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9 |
| SNX            | 0xc011a73ee8576fb46f5e1c5751ca3b9fe0af2a6f |
| COMP           | 0xc00e94cb662c3520282e6f5717214004a7f26888 |
| YFI            | 0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e |
| FIN            | 0x054f76beed60ab6dbeb23502178c52d6c5debe40 |
| WOO            | 0x4691937a7508860f876c9c0a2a617e7d9e945d4b |
| wCRES          | 0x85f9569b69083c3e6aeffd301bb2c65606b5d575 |
**** Kovan#
| Contract Name         |                                    Address |
| DODO Pair: BASE-QUOTE | 0x3c5ab3757de3dffbdb179800c26be7705592a816 |
| Test Base Token       | 0x215bd4d983c571a840b89028cc005b6ff0734ebe |
| Test Quote Token      | 0x3ef4a7e2e31a1b403f1199133a2000d0431f8e71 |
| Oracle: BASE-QUOTE    | 0xcd25c71fd5bbbdd26d507df3a7333d37d1e340ae |
| DODO Pair: WETH-USDC  | 0x2b517ba87eae60de363b7295b08167ba7ee25143 |
| WETH                  | 0x5eca15b12d959dfcf9c71c59f8b467eb8c6efd0b |
| USDC(Decimals:6)      | 0x69c8a7fc6e05d7aa36114b3e35f62deca8e11f6e |
| Oracle: WETH-USDC     | 0x94a2ef99cd4f11b57daaf688183eae536b3fbbe9 |
| DODO Zoo              | 0x92230e929a2226b29ed3441ae5524886347c60c8 |
| DODO EthProxy         | 0xa1345125ff04bb5b8f0fe0f12f7ce656310130ae |
| Clone Factory         | 0xaaff7478c1652c4d2b91c38956c01ae7dabef109 |
| Test Uniswap          | 0x125efdccfbb9e81d53095f2f2e8edae2c4c49369 |
| Uniswap arbitrageur   | 0x5b3f89afe4321b8914213dd44df35062d9dffaf6 |

To play with DODO on Kovan, you can:

 - Request test tokens by emailing contact@dodoex.io
 - Get free Kovan ETH from the Kovan faucet
*** Bug Bounty 💰

The DODO team has implemented a bug bounty program and invites bug bounty hunters to participate.
**** Scope#

The scope of the bug bounty program is all contracts in the DODO smart contracts repository.

The probability of finding a bug and winning a reward for the three parts of DODO is: Helper > Entrance > Core.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_framework.jpeg]]

**** Rewards#

Severity of bugs will be triaged and assessed under the CVSS Risk Rating scale. The rewards corresponding to the severities are as follows:

 - Critical (9.0-10.0): Up to $50,000
 - High (7.0-8.9): Up to $10,000
 - Medium (4.0-6.9): Up to $2,000
 - Low (0.1-3.9): Up to $1,000

In addition to bug severity, rewards will be paid out based on the impact of the discovered vulnerabilities, as well as the level of difficulty in discovering these vulnerabilities.
**** Disclosure#

Any vulnerability or bug discovered must be reported only to the DODO team at contact@dodoex.io. Bounty hunters must not disclose the vulnerability or bug publicly or to another person or entity prior to contacting the DODO team. In addition, disclosure to the DODO team must be made promptly following the discovery of the vulnerability. Please include as much information about the vulnerability as possible in your email, including:

 - The conditions on which reproducing the bug is contingent
 - The steps needed to reproduce the bug or, preferably, a proof of concept
 - The potential implications of the vulnerability being abused

A detailed vulnerability report increases the likelihood of receiving a reward and may increase the monetary amount of the reward.

Anyone who reports a unique, previously unreported vulnerability that results in a change to the code or a configuration change and who keeps such vulnerability confidential until it has been resolved by our engineers will be recognized publicly for their contribution, if agreed.
*** Audit
Audit

DODO smart contracts were audited by PeckShield Inc.

PeckShield Inc. is a blockchain security company with the goal of elevating the security, privacy, and usability of current blockchain ecosystems by offering top-notch, industry-leading services and products.

PeckShield's July 10, 2020 audit report on DODO can be accessed here.

DODO smart contracts were also audited by Trail of Bits

Since 2012, Trail of Bits has helped secure some of the world’s most targeted organizations and products. They combine high-end security research with a real-world attacker mentality to reduce risk and fortify code.

Trail of Bits' September 18, 2020 audit report on DODO can be accessed here
** Use Case
*** Initial DODO Offering

Initial DODO Offering (IDO) is a brand new approach to crypto asset issuance. Instead of paying exorbitant listing fees to get listed on CEXs or other DEXs, it is literally free to offer assets on DODO!

Normally, the PMM algorithm requires a price oracle to provide liquidity, but when there is no external market (which is usually the case when you are just starting your asset offering efforts), you can simply set the oracle price to a constant and start an initial DODO offering.
**** All You Need is Your Own Token#

As discussed in previous sections, DODO, unlike AMM, does not require quote tokens. The only thing you need to do is to deposit your own tokens to the pool. After your token deposit, PMM creates ask side depth on its own. The more tokens you deposit, the better the liquidity.

Because there are no quote tokens in the pool, there is no bid side depth, but there is no need to worry. There are also no base tokens in the market and no one is selling either. IDO might feel somewhat similar to an auction, but there are some important differences.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_long_tail_1.jpeg]]

Remember the constant price you set for the oracle? That price would be the initial offering price. When a trader buys your tokens, the price rises and quote tokens start flowing into the pool. These quote tokens then produce bid side depth as a result. Maybe we could call IDO a bidirectional auction 🤔

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_long_tail_2.jpeg]]

Compared to AMM-based platforms, asset issuance on DODO provides more benefits:

 - Sell tokens from an arbitrary price of your choice with zero capital requirement
 - Sufficient and contract-fillable liquidity
 - Flexible parameters (design your price curve by fine-tuning the parameters)
** Advanced Topics
*** Authority
Authority

There are two special roles in each DODO Pair smart contract: admin and supervisor.

Here I would like to introduce the scope of power of admin and supervisor, and the principles of design behind.
#+begin_quote
note

You may be very concerned about who is the admin and the supervisor, and will they abuse the power. Please don't worry, in the next section, we will introduce the decentralized governance process in detail.
#+end_quote

**** Scope#

Power of the supervisor is a subset of that of admin, and both supervisor and admin have A-level authority. Level A permissions include:

 - Disable trade
 - Disable deposit
 - Set gas price limit

admin is the only one with B-level authority, which includes:

 - Change admin
 - Change supervisor
 - Change maintainer
 - Change oracle
 - Set liquidity provider fee rate
 - Set maintainer fee rate
 - Set K
 - Enable trade
 - Enable deposit
 - Final settlement

**** Principle#

Level-A authority can be summarized as "freeze status" i.e. some functions of the system can be stopped urgently, but the status cannot be changed. In order to limit the power of admin, often actions taken by admin have to go through a complex governance process. To be risk resistant, we need a more flexible supervisor instead of an admin to take some actions that are not so sensitive but can significantly reduce system risks.

The B-level authority basically covers all aspects of the DODO Pair contract. The reason why so many parameters are designed to be variable is to better adapt to the rapidly changing market environment. It also leaves room for governance in the future.

It is worth pointing out that no one can prohibit users from withdrawing coins. Being non-custodial is the most important principle of Defi.
*** Decentralization

In our vision, DODO will be fully governed by the community, and controlled by three DAOs
**** Admin DAO#

Act as an administrator, the ultimate mediator of all issues.
**** Risk Control DAO#

Act as a supervisor and deal with all risk events urgently.
**** Earn DAO#

To distribute revenue of maintainer.
**** Process#

When DODO was launched, all authorities were governed by the team. As the community learns more about DODO, we will gradually return all the rights to the community. Although there is no timeline for this process yet, we do intend to follow the process.
| 0 | Step                                                 | Finished |
| 1 | Set Admin to multi-sig wallet with daily limit       | ✔        |
| 2 | Deploy DODOWild: Allows anyone create their own DODO |          |
| 3 | Issue governance token                               |          |
| 4 | Set Maintainer to Earn DAO                           |          |
| 5 | Set Admin to Admin DAO                               |          |
| 6 | Set Supervisor to Risk Control DAO                   |          |

What is the purpose of each step?

 - All admin actions come with a public announcement period to avoid single point failure
 - Anyone can create a new DODO Pair and use it to provide liquidity to their tokens. This marks the return of the code to the community
 - Issue governance tokens and formulate a token distribution plan, which will initiate the step down process
 - Hand over the profit distribution responsibility to Earn DAO
 - After handing admin authority over to the DAO, the team has no real control rights, and only reserves the right to control risk
 - The team steps down completely, marking the last step towards complete decentralization
*** Risk Parameters
**** Front Running#

Front running on DODO could occur in the following scenario.

Arbitrageurs listen for oracle price updates transactions. If they see that the oracle price for an asset will go up in the next block, they will buy asset on DODO before the price update by paying higher gas prices. And sell the asset immediately after the oracle price has been updated. This will result in a loss for liquidity providers, and this loss is referred to as arbitrage loss.

This might seem like a big deal, but the truth is, such opportunities are few and far between, and not necessarily profitable for arbitrageurs.

First of all, front running is only profitable when the price fluctuates significantly. This is because DODO charges a 0.3% transaction fee per trade, thus buying and selling assets once incurs a 0.6% transaction fee overall. Therefore, if the price discrepancy between the oracle updates is less than 0.6%, front running is not profitable at all for arbitrageurs.

Secondly, DODO uses Chainlink as its oracle of choice. The Chainlink price oracle provides price updates by aggregating updates from 22 independent price feeders. This means that price changes on DODO are usually gradual and thus not susceptible to front running.

With that said, although the probability of a significant price change between updates is low, it will happen, and arbitrageurs looking to extract value from the system will take advantage of front running. The DODO team conducted extensive backtesting and discovered that in the overwhelming majority of cases, profit from market making far outweighs arbitrage loss for liquidity providers.

Please note that arbitrage loss due to front running will increase significantly during drastic market fluctuations. The DODO team recommends withdrawing your assets during fluctuations to avert the risk and proceeding with caution depending on your risk profile.
**** Fee Percentage#

As mentioned above, the transaction fee deters arbitrageurs from extracting value from the system via front running, protecting liquidity providers from arbitrage loss.

The question is, what should the transaction fee percentage be? Lowering the percentage leads to more trading, potentially increasing profit for liquidity providers, but also elevating risk of arbitrage loss. On the other hand, increasing the percentage lowers the risk of arbitrage loss, but also reduces profit for liquidity providers. It is crucial to strike a reasonable balance between risk and profit.

Since market fluctuations have a bearing on arbitrageur behaviors, the fee percentage should also be fine-tuned based on market changes. The fee percentage should be low to facilitate more trading when the market is relatively stable, and high when the market is fluctuating. Determining the appropriate fee percentage is an important governance issue, and users should collectively have a say in how much risk they are willing to take on.
**** k#

Another important parameter is k from the PMM pricing formula. A small k provides good liquidity and increase trading volume, but increases the risk of arbitrage loss; whereas a large k hurts liquidity and decreases trading volume, but reduces the risk of arbitrage loss. Therefore, similar to the fee percentage above, the value of k should be governed and determined by the users.
*** Backtest
**** Background#

PMM stands for Proactive Market Maker, which is essentially a quantitative trading strategy used by liquidity providers (LP). To help LP understand ROI of PMM, we’ve performed a backtest to demonstrate the performance of PMM in different market environments.
**** Method#

Evaluation of PMM focuses on these two aspects: proﬁt and loss.

The proﬁt for LP is turnover rate multiplied by fee rate.

While the loss has to be explained in two perspectives, counterparty risk and arbitrage trading.

Counterparty risk can be ignored in this case, because PMM has built a mechanism to limit this risk. In addition, the risk comes from trades by normal users, which are almost random and are statistically balanced against.

Arbitrage trading is inevitable and contributes most of the loss, as onchain oracle price is always delayed from market.

Hence, in the following backtesting, we focus on these two key values:

    Turnover rate (profit wise)
    Arbitrage loss (loss wise)

**** Backtest#
***** Profit evaluation#

Assumptions:

 - Our pool size is 1/10 of uniswap's pool size
 - Base Token and Quote Token have the same value
 - PMM parameter k=0.1
 - Fee rate 0.3%

Those assumptions are not set arbitrarily. Under this condition, PMM could provide the same liquidity as Uniswap, and hence it's reasonable to assume PMM has the same trading volume as Uniswap. However, because of aggregators, it's more realistic to assume PMM has half of the trading volume of Uniswap. According to history data, PMM daily turnover rate is about 100% and ROI is 0.3%.
#+begin_quote
note

The backtest report is written at 2020/7/19. We use uniswap's historical data from 2020/6/1 to 2020/7/18.
#+end_quote

***** Loss evaluation#

It's more complex to evaluate arbitrage loss, as no PMM-like algorithm has been deployed before. The best alternative is backtest with the most stringent standards. below is the assumptions:

 - Onchain oracle price is always delayed from market price
 - Oracle price updates whenever deviates from market price by more than 0.5% (chainlink threshold)
 - Arbitrageurs always have enough funding and never miss a trade
 - The external cost of arbitrageurs is 0.2% (including CEX fees and gas cost)

We backtested using BTC price from Apr-2018 to Apr-2020 with 1 minute interval. Aggregate profit and loss, we got the following conclusions.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_backtest.png]]

**** Conclusion#

The backtesting has covered most cases of the market environment, both the bull and bear market, even including the black swan event on 12th March. We concluded that:

 - In most market environments, the fee income is sufficient to cover arbitrage losses and provides a very high rate of return (~80% APR)
 - When the market changes volatilely, despite of rises or falls, LP will lose a significant amount of money

In brief, PMM makes proﬁts when the market is flat, while makes losses when volatile.
***** Advantage & Disadvantage#

Most quant strategies make proﬁts only when market price goes up or down, and there is nothing to do when the market is flat. In contrast, PMM can make considerable proﬁts when the price is nearly flat. Furthermore, unlike AMM, PMM never requires LP to deposit base and quote assets at a certain ratio. Instead, LP could deposit any amount of any asset as they want. As a result, PMM can be a supplement to the original strategies when the market is not volatile.

Nevertheless, we have to point out its disadvantages. As the old saying goes, there is no free lunch. When the market is volatile, LP suffers from significant loss. LP should make a balance between risks and beneﬁts. So we recommend traders withdraw their assets when they predict the market to be volatile. As a decentralized project, what we can do is very limited. But we would deﬁnitely try our best to adjust system parameters to help LP, especially when black swan event happens.

In addition, one of the inherent drawbacks of backtesting is it cannot simulate 100% of the real trading. But to mitigate this risk, we have performed the backtesting with the most conservative assumptions. Still, LP should determine to what extent they trust the backtesting result.
***** FAQ about backtest#

 1. Where does the turnover rate data come from?

    We have counted the historical data of Uniswap in the past month. Because the capital utilization rate of PMM algorithm is very high, the capital utilization rate can reach ten times that of Uniswap. So the actual turnover rate is also much higher than Uniswap.

 2. Why do you use BTC price for backtesting?

    Because we did not find ETH price data of high-precision. We would be very grateful if someone could provide ETH price historical data with 1min interval or more frequent. But it is reasonable to use BTC price to estimate loss, because ETH and BTC prices are highly correlated.

 3. How does the arbitrage work?

    The arbitrage is carried out when arbitrageurs notice that the price provided by the PMM is more beneficial to them than the market price, i.e. the difference between the PMM and the market price is less than its comprehensive arbitrage cost (PMM Fee + Arbitrage Cost)

 4. Given that Chainlink's BTC Oracle accuracy rate is 1%, why is it set to 0.5% here?

    First of all, Chainlink will increase the accuracy rate of BTC Oracle to 0.5% soon. Secondly, PMM will focus on ETH trading pair for now. And the accuracy rate of Chainlink’s ETH Oracle is 0.5%.

 5. Does the size of the funding pool have an impact on the backtest?

    Yes, it does. ROI will not be so good if the pool size is too small. We need enough liquidity to compete with other liquidity sources. Actually, the 1/10 of Uniswap pool size required for backtesting is able to produce competitive liquidity, which equals only $900,000.

 6. How about the gas cost

    Swap between two standard ERC20 token cost 145,000 ~ 175,000 gas. The gas cost is slightly higher than uniswap(~100,000 gas), but significantly lower than other protocols. For example, kyber costs ~400,000gas; balancer costs ~300,000 gas; dydx costs ~400,000 gas;
*** Frequently Asked Questions (FAQs)
**** How does DODO keep the funding pools balanced?#

Taking the ETH-USDC trading pair as an example, DODO charges users ETH in transaction fees when they buy ETH, and USDC in transaction fees when they sell ETH. Statistically speaking, given a sufficiently large sample, the buying volume is roughly equal to the selling volume, so the absolute returns of the two asset pools are roughly the same. Therefore, when the size of one asset pool is smaller, its return on investment (ROI) will be higher. This (temporary) higher yield will encourage liquidity providers (LPs) to deposit more assets into the smaller funding pool, until the values of the two funding pools become balanced again.
* dodo paper
** abstract
DODO
———A Next-Generation On-Chain Liquidity Provider Powered by Pro-active Market Maker Algorithm
V1.0
DODO Team
*contact@dodoex.io*

Abstract: This article introduce DODO, a next-generation on-chain liquidity provider, which leverages the Proactive Market Maker algorithm (PMM) to provide pure on-chain and contract-fillable liquidity for everyone. Comparing to other on-chain liquidity solutions, DODO has multiple advantages: high fund utilization, low slippage, single risk exposure, reduced impermanent loss. We also discuss the core concepts and mathematical details about Proactive Market Maker algorithm (PMM), and include the contract framework.

Keywords: PMM; high fund utilization; reduced impermanent loss; single risk exposure
** 1 Introduction#

DODO is a next-generation on-chain liquidity provider, which leverages the Proactive Market Maker algorithm (PMM) to provide pure on-chain and contract-fillable liquidity for everyone. DODO accepts liquidity providers' assets. It gathers funds near market prices to provide sufficient liquidity. In order to minimize counterparty risks for LPs, DODO dynamically adjusts market prices to encourage arbitrageurs to step in and stabilize LPs' portfolios. Comparing to other on-chain liquidity solutions, DODO has multiple advantages: high fund utilization, low slippage, single risk exposure, reduced impermanent loss.

As a trader, you can see these features: Each and every trader enjoys sufficient liquidity similar to that of centralized exchanges; Arbitrageurs can profit from price discrepancies between DODO and other exchanges; Smart contracts can natively use DODO liquidity to complete on-chain transactions, such as liquidation and auctions

As a liquidity provider (LP), you can see these features: There are no minimal deposit requirements and restrictions on asset types; DODO charges a fee for each transaction and eventually distributes it to LPs as rewards; LPs can create trading pairs with their own tokens; LPs can obtain liquidity by depositing their tokens they already own, without taking on price risk.
** 2 Protocol#
*** 2.1 The DODO Advantage#
**** 2.1.1 Overview#

DODO is powered by a ground-breaking algorithm called Proactive Market Maker (PMM). PMM leverages price oracles to retrieve accurate market prices of assets as input. It then aims to provide sufficient liquidity near the market price for every asset. The result is that liquidity decreases rapidly when far away from the market price. The following graphs compare the price curves of DODO (PMM) and Uniswap (AMM).

With everything else fixed, it is clear that the PMM curve is significantly flatter than the AMM curve near the market price, indicating higher fund utilization and lower slippage. Prices provided by PMM are more favorable than AMM.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_curve.jpeg]]

As the market price changes, AMM passively relies on arbitrage trading to change prices. On the other hand, PMM proactively shifts the price curve in the same direction to ensure that the section in the vicinity of the market price remains flat. This ensures the constant provision of sufficient liquidity.

#+ATTR_ORG: :width 500
https://dodoex.github.io/docs/img/dodo_curve_move.jpeg

PMM outperforms AMM solutions in several important aspects.

    High Fund Utilization

As seen in the above graphs, PMM, like AMMs, provides liquidity in the price range of zero to positive infinity, but the PMM price curve is significantly flatter in the area near the oracle (market) price. That is, most of the funds are gathered near the market price, which allows for more active, frequent trading, increasing fund utilization.

    Single Risk Exposure

In the price curves above, each price curve consists of two parts: the bidding side to the left and the asking side to the right. These two parts may have different depth, or liquidity, resulting in what is known as the bid-ask spread[fn:1].

#+ATTR_ORG: :width 500
https://dodoex.github.io/docs/img/dodo_segment.jpeg

In PMM, the asking liquidity is solely determined by the amount of base token in the pool, and the bidding liquidity is solely determined by the amount of quote tokens in the pool. It allows the base and quote pools tohave different sizes, and thus allows liquidity providers to deposit any amount of either quote or base tokens, rather than both (like Uniswap). DODO Liquidity providers deposit what they already have, nothing more.

Please note: The design is intuitive, because when you take an asking order, you take liquidity providers' base tokens and the quote tokens are irrelevant.

    Reduced Impermanent Loss

But what about impermanent loss, i.e. how does PMM ensure that liquidity providers get what they deposited when they withdraw their tokens? The answer is by encouraging arbitrage trading. When individual traders buy base tokens, PMM slightly increases the price to make it more profitable for arbitrageurs to sell base tokens. In PMM, arbitrage trading makes sure that the number of tokens in the pool is always roughly equal to the number of tokens deposited by liquidity providers. This scheme effectively mitigates impermanent loss for liquidity providers, making liquidity provision on DODO a low-risk affair.
**** 2.1.2 Next Generation of Liquidity Provision#

Liquidity is the most important resource in the DeFi world, because it is the foundational element in all DeFi projects. There are two major proven approaches to decentralized liquidity provision today:

    Algorithmic market makers (e.g. Uniswap)

    Orderbook-based order matching (e.g. dYdX)

However, they are both flawed.

    Compared to centralized exchanges, algorithmic market makers cannot provide sufficient liquidity for mainstream assets. In addition, for niche, long-tail assets, AMM can only provide very basic liquidity support

    Orderbook-based order matching relies on human market makers to mirroring centralized exchanges liquidity. Effective market makers are expensive, and very few DEX teams can afford them. In addition, this kind of liquidity is difficult to be filled by smart contracts due to the human elements involved, significantly limiting the number of use cases for DeFi practitioners

PMM is also an algorithmic market maker algorithm, but it fundamentally differs from other approaches by mitigating and eliminating their disadvantages and amplifying their advantages. PMM provides sufficient and contract-fillable liquidity on-chain for all assets, empowering DeFi users to take advantage of composability
*** 2.2 Core Concepts#
**** 2.2.1 Base & Quote Token#

Base _and _quote are two concepts that will be mentioned frequently. Two easy ways to distinguish between them are:

    In a trading pair, the base is always the token before the hyphen, and quote after

    In transactions, price refers to how many quote tokens are needed in exchange for one base token

For example, in the ETH-USDC trading pair, ETH is the base token and USDC is the quote token
**** 2.2.2 PMM Parameters#

The funding pool of PMM is described by four parameters:

    B0B_0B0​: base token regression target - total number of base tokens deposited by liquidity providers

    Q0Q_0Q0​ : quote token regression target - total number of quote tokens deposited by liquidity providers

    BBB: base token balance - number of base tokens currently in the pool

    QQQ: quote token balance - number of quote tokens currently in the pool

**** 2.2.3 PMM Pricing Formula#

The PMM price curve is plotted by the following pricing formula:

Pmargin=iRP_{margin}=iRPmargin​=iR

Where R is defined to be the piecewise function below:

if B<B0,R=1−k+(B0B)2kB<B_0, R=1-k+(\frac{B_0}{B})^2kB<B0​,R=1−k+(BB0​​)2k

if Q<Q0,R=1/(1−k+(Q0Q)2k)Q<Q_0, R=1/(1-k+(\frac{Q_0}{Q})^2k)Q<Q0​,R=1/(1−k+(QQ0​​)2k)

else R=1R=1R=1

i is the market price provided by an oracle, and k is a parameter in the range (0, 1).
**** 2.2.4 Three Possible States in PMM#

At any given time, PMM is in one of three possible states: equilibrium, base token shortage, and quote token shortage.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_mode_switch.jpeg]]

Initially, i.e. prior to any transaction, the capital pool is in equilibrium, and both base tokens and quote token are at their regression targets. That is, B=B0B=B_0B=B0​ ​ and Q=Q0Q=Q_0Q=Q0​​.

When a trader sells base tokens, the base token balance of the capital pool is higher than the base token regression target; conversely, the quote token balance is now lower than the quote token regression target. In this state, PMM will try to sell the excess base tokens, lowering the base token balance and increasing the quote token balance, in order to move this state back to the state of equilibrium.

When a trader buys base tokens, the quote token balance of the capital pool is higher than the quote token regression target; conversely, the base token balance is now lower than the base token regression target. In this state, PMM will try to sell the excess quote tokens, lowering the quote token balance and increasing the base token balance, in order to move this state back to the state of equilibrium.

The parameter R in the pricing formula above assumes a critical role in facilitating this regression process. The more the capital pool deviates from the equilibrium state, the more R deviates from 1. When the price given by the PMM algorithm deviates from the market price, arbitrageurs step in to help bring the capital pool back to the equilibrium state.
**** 2.2.5 Liquidity Provider Fee#

A small amount of transaction fee will be charged on every trade. This fee is called the liquidity provider fee and will be distributed to every liquidity provider based on their proportional stake in the capital pool.

More specifically, liquidity provider fees are collected from what buyers received and distributed to liquidity providers who supplied this kind of asset to the capital pool. In other words, liquidity providers are rewarded in the same asset denomination.

For example, when traders buy ETH tokens with USDC tokens, liquidity provider fees will be charged in the form of ETH tokens, and distributed to liquidity providers who deposited ETH tokens into the capital pool.

When traders sell ETH tokens for USDC tokens, liquidity provider fees will be charged in the form of USDC tokens, and distributed to liquidity providers who deposited USDC tokens into the capital pool.

Please note: Base and quote tokens have different returns on investments (ROI) in PMM's funding pool.
**** 2.2.6 Maintainer Fee#

A maintainer fee is also collected from what buyers received, and will be directly transferred to the maintainer. The maintainer may be a development team, a foundation, or a staking decentralized autonomous organization (DAO). Currently, the maintenance fee on DODO is 0.
**** 2.2.7 Withdraw Fee#

A withdrawal will change the PMM price curve and may harm the interests of other liquidity providers. DODO charges a withdrawal fee from liquidity providers who withdraw their assets and distribute it to all remaining liquidity providers.

Please note:

Normally, the withdrawal fee is 0 or an extremely small percentage (\<0.01%) of what you withdraw. The withdrawal fee will increase significantly only if the funding pool suffers from a serious shortage of either base or quote tokens and liquidity providers intend to withdraw the type of token in shortage. The withdrawal fee serves as a protection mechanism for liquidity providers who maintain their supplies of liquidity and contribute to the sustainability and overall health of the DODO platform.
**** 2.2.8 Deposit Rewards#

Rewards will be distributed to those who make a deposit of base(quote) tokens when the capital pool faces a shortage of base(quote) tokens.

In the next section, we will explain the math behind these core concepts.
**** 2.2.9 Flexibility and k, the "Liquidity Parameter"#

Last but not least, we will introduce the DODO's "liquidity parameter", k. The parameter k gives DODO the flexibility to handle different market situations.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_k.jpeg]]

When k is 0, DODO naively sells or buys at market price, as shown by the flat, blue line. As k increases, DODO's price curve becomes more "curved", but, consequently, liquidity becomes increasingly jeopardized, because more funds are placed far away from market price and are thus underutilized or not utilized at all. When k increases to 1, the flat section near the market price is completely eliminated and the curve essentially becomes a standard AMM curve, which Uniswap uses.

Normally, k is recommended to be a relatively small value, such as 0.1, which could provide liquidity 10 times better than the standard AMM algorithm.
*** 2.3 The Math Behind PMM#
**** 2.3.1 Core PMM#

The core of PMM is essentially calculating one integral and solving two quadratic equations. The smart contract implementation can be found here[fn:2].
***** 2.3.1.1 The Price Curve Integral#

For traders, the most important thing is the average transaction price. The average transaction price is the integral of the marginal price ​. Let's take the base token shortage scenario as an example.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_integrate.jpeg]]

ΔQ=∫B1B2PmargindB

=∫B1B2(1−k)i+i(B0/B)2kdB

=i(B2−B1)∗(1−k+kB02B1B2)

This tells the trader how much they should pay if they buy B1−B2​ amount of base tokens.

Rearranging the equation above, the average transaction price is thus:

P=ΔQB2−B1=i∗(1−k+kB02B1B2)

We found that the average transaction price is only dependent on the state of the system before and after the transaction, so the price calculation methods for both buying and selling are the same: integrating Pmargin.
***** 2.3.1.2 Solving the Quadratic Equation for Trading#

Without the loss of generality, the integral becomes the following when there is a shortage of quote tokens:

ΔB = 1/i (Q2-Q1) * (1 - k + k(Q0^2/Q1Q2))

Let's derive how to calculate the price when there is a shortage of quote tokens and only the number of base tokens you want to buy or sell (i.e. ΔB\Delta BΔB ) is given.

Now that ΔB, Q0, Q1 are given, we need to calculate Q2, which is found by solving a quadratic equation. Transforming the equation into standard form:

(1−k)Q22+(kQ02Q1−Q1+kQ1−iΔB)Q2−kQ02=0(1-k)Q_2^2 +(\frac{kQ_0^2}{Q_1}-Q_1+kQ_1-i\Delta B)Q_2-kQ_0^2=0(1−k)Q22​+(Q1​kQ02​​−Q1​+kQ1​−iΔB)Q2​−kQ02​=0

let a=1−k,b=kQ02Q1−Q1+kQ1−iΔB,c=−kQ02a=1-k, b=\frac{kQ_0^2}{Q_1}-Q_1+kQ_1-i\Delta B, c=-kQ_0^2a=1−k,b=Q1​kQ02​​−Q1​+kQ1​−iΔB,c=−kQ02​

Because Q2≥0Q_2 \ge 0Q2​≥0, we discard the negative root, and so Q2=−b+b2−4ac2aQ_2=\frac{-b+\sqrt{b^2-4ac}}{2a}Q2​=2a−b+b2−4ac

It can be proven that:

    When ΔB>0\Delta B > 0ΔB>0 , Q2>Q1Q_2>Q_1Q2​>Q1​ ; trader buy base token, and should pay Q2>Q1Q_2>Q_1Q2​>Q1​

    When ΔB<0\Delta B < 0ΔB<0 , Q2<Q1Q_2<Q_1Q2​<Q1​; trader sell base token, and will receive Q2>Q1Q_2>Q_1Q2​>Q1​

    When ΔB=0\Delta B =0ΔB=0， Q2=Q1Q_2=Q_1Q2​=Q1​

***** 2.3.1.3 Solving the Quadratic Equation for Regression Targets#

When the system is not in the equilibrium state, changes to the oracle price will bring profit or loss. For example, assume that shortage of base tokens is the current state, and the oracle price goes up. It is clear that the excess quote tokens cannot buy enough base tokens to return the base token balance to the base token regression target. Thus, LPs who deposited base tokens will suffer a loss. Conversely, if the oracle price drops, the excess quote tokens can buy more base tokens, causing the base token balance to exceed the base token regression target, and LPs who deposited base tokens will make a profit.

In summary, the regression target is influenced by the oracle price. To calculate the regression target at a certain oracle price, we make the following derivation:

Given:

ΔQ=i(B2−B1)∗(1−k+kB02B1B2)\Delta Q = i(B_2-B_1)*(1-k+k\frac{B_0^2}{B_1B_2})ΔQ=i(B2​−B1​)∗(1−k+kB1​B2​B02​​)

Since we are doing regression, . Rearranging the equation with respect to gives

kB1B02+(1−2k)B0−[(1−k)B1+ΔQi]=0\frac{k}{B_1}B_0^2+(1-2k)B_0-[(1-k)B_1+\frac{\Delta Q}{i}] = 0B1​k​B02​+(1−2k)B0​−[(1−k)B1​+iΔQ​]=0

The negative root does not make sense and is discarded, so B0B_0B0​ is:

B0=B1+B11+4kΔQB1i−12kB_0=B_1+B_1\frac{\sqrt{1+\frac{4k\Delta Q}{B_1 i}}-1}{2k}B0​=B1​+B1​2k1+B1​i4kΔQ​

​−1​

In this case, ΔQ=Q−Q0\Delta Q = Q-Q_0ΔQ=Q−Q0​ . It can be proven that, when ΔQ≥0\Delta Q \ge 0ΔQ≥0 , B0<B1B_0<B_1B0​<B1​.

This fact is extremely important, because it ensures that the base token balance and the quote token balance will never be greater than the regression target simultaneously, or less than the regression target simultaneously. This means that PMM will only switch between the three states discussed in the Core Concepts section.

Similarly, the formula for quote token regression target Q0Q_0Q0​ is:

Q0=Q1+Q1∗1+4kΔBiQ1−12kQ_0=Q1+Q1*\frac{\sqrt{1+\frac{4k\Delta Bi}{Q_1}}-1}{2k}Q0​=Q1+Q1∗2k1+Q1​4kΔBi​

​−1​
**** 2.3.2 Peripheral#

This section will deal with the math pertaining to the peripheral functioning of PMM.
***** 2.3.2.1 Trades#

As mentioned above, the regression target depends on the oracle price, and the price curve in turn depend on the regression target. So in every trade, we should calculate the regression target well in advance to make the price curve fixed.

In addition, since the price curve given by PMM is segmented, if a transaction involves different states (for example, when a trader sells an astronomical amount of base tokens during a base token shortage and forces the state into a quote token shortage), the price needs to be calculated in segments as well.

Please be advised that this calculation requires a high degree of accuracy. The smart contract provides six trading functions for the three possible states. You can find the most important logic of cross-state trading here[fn:3].
***** 2.3.2.2 Deposit#

Depositing and withdrawing base token when there is a shortage of base tokens, or quote tokens when there is a shortage of quote token, will change the price curve. This requires us to process the deposit and withdrawal with caution and care in order to keep the capital pool sustainable and fair.

We will analyze what happens when an LP makes a deposit when there is a shortage of base tokens.

According to the calculation formula of B0B_0B0​ derived above

B0=B1+B1∗1+4kΔQB1i−12kB_0=B_1+B_1*\frac{\sqrt{1+\frac{4k\Delta Q}{B_1i}}-1}{2k}B0​=B1​+B1​∗2k1+B1​i4kΔQ​

​−1​

After an LP deposit b base tokens, B1B_1B1​ increases by b, and B0B_0B0​ ​increases more than b's magnitude. It means that this deposit helps all LPs who provided base token make a profit. The reason why is that the deposit makes the price curve smoother, and the same amount of ΔQ\Delta QΔQ can now buy more base tokens.

In this case, as soon as the LP makes a deposit, the LP makes a profit. This is referred to as the deposit reward. The essential source of this reward is the slippage paid by the trader who made the system deviate from equilibrium state.

Please note: It is important to note that deposit rewards are not risk-free arbitrage trading opportunities.
***** 2.3.2.3 Withdrawal#

Similarly, after an LP withdraws b base tokens, B1B_1B1​ decreases by b, and B0B_0B0​ decreases by more than b's magnitude. This withdrawal causes all LPs who owes Base Tokens to suffer losses. This is because this withdrawal makes the price curve more steep, and the excess quote tokens have less purchasing power in terms of base tokens.

The PMM algorithm stipulates that a withdrawal fee is required to withdraw tokens in this case. The magnitude of the fee is equal to the aggregate loss of all LPs caused by the withdrawal. This fee will be directly distributed to all LPs that have not yet withdrawn.

Factoring in the deposit reward from the previous section, if an LP makes a withdrawal immediately after depositing, the withdrawal fee will be greater than the deposit reward, thus eliminating any possibility of risk-free arbitrage trading.

It is worth noting that both deposit reward and withdrawal fee are only significant when the system deviates very far from the equilibrium state and the deposit/withdrawal amount is large. Traders thus often overlook the existence of this gain/loss. Of course, traders are also welcome to extract value from the system by exploiting this if they so wish. In order to do that, they can first deposit to earn deposit rewards when the system deviates from the equilibrium, and then withdraw once the system returns to the equilibrium to avoid the withdrawal fee.
** 3 Contract#
*** 3.1 Overview#

DODO is built with a set of smart contracts. The following figure shows the framework of these contracts and how they interact with each other in the DODO architecture.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_framework.jpeg]]
*** 3.2 Core#

The core part of the DODO framework, which contains all the data and logic of DODO, consists of a set of DODO Proxy contracts and a singular DODO Implementation contract. Each trading pair binds with an independent DODO Proxy contract (e.g. WETH-USDC, DAI-USDT, etc.), which is a transparent proxy that only stores states and metadata. All underlying logic lies in the DODO Implementation contract.

For convenience's sake, we will call the transparent proxy DODO Pair and the logic implementation DODO Template. Users should interact with DODO Pair directly or through Helper.
*** 3.3 Entrance#

DODO is an open-source contract, and the DODO team welcomes forks. However, it is important to note that the operation of DODO Pair is highly dependent on oracles and parameter fine-tuning, and a misconfigured DODO Pair could potentially cause significant losses for users. Therefore, we deployed an entrance contract to help blockchain developers navigate these obstacles. All DODO Pairs registered in this contract have been rigorously tested and audited, as the DODO team believes the safety of DODO users is of utmost importance. Developers should only look for the entrance called DODO Zoo when developing upon DODO. Even if the DODO Template is upgraded, DODO Zoo will remain unchanged.
*** 3.4 Helper#

There are a lot of tedious tasks that can be packaged using contracts to make them easy to use and understand. For example, the DODO ETH Proxy shown in the figure above helps users convert between ETH and WETH and interact with DODO Pair. This way, the underlying complexity with WETH is abstracted away from users, effectively protecting them - users do and should only care about directly buying or selling ETH on DODO. There are many such contracts, such as arbitrage and route, which we collectively call Helper. We invite the community to help develop more helper contracts and we are willing to provide guidance and support.
** 4 Use Case#
*** 4.1 Flash Swap#
**** 4.1.1 What is Flash Swap#

Simply put, you are allowed to pay on credit on DODO! When you buy tokens DODO, you can first get the tokens you want to buy, do anything you want with the tokens, and pay for them later.
**** 4.1.2 How Does Flash Swap Work#

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_flash_swap.jpeg]]

The figure above illustrates the four steps in a flash swap happening under the hood

    Call the buyBaseToken function from the DODO Pair smart contract

    DODO Pair transfers the base tokens to the message sender

    If the parameter data of the buyBaseToken function call is not null, the DODO Pair smart contract will call the dodoCall method of the message sender

    After the dodoCall is executed, the DODO Pair smart contract will retrieve the quote tokens required for this transaction from the message sender

Please note: The sellBaseToken function can also perform flash swap in the same way.
**** 4.1.3 What Can Flash Swap Do#

Flash swap can significantly improve market efficiency. Market parity is maintained by arbitrageurs, and flash swap completely removes capital requirements for them, essentially eliminating the barrier of entry to arbitrage trading.

We will demonstrate a completely trustless and risk-free arbitrage trading contract as a use case of flash swap. Please refer to the UniswapArbitrageur.sol source code[fn:4] for a concrete example. It has already been deployed and you can check out its Etherscan link here[fn:5].

The following figure illustrates how an arbitrageur might take advantage of the price discrepancies between DODO and Uniswap.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_one_click_arbitrage.jpeg]]

A complete arbitrage trading maneuver consists of the following 9 steps:

 1. The user calls executeBuyArbitrage on UniswapArbitrageur
 2. UniswapArbitrageur calls buyBaseToken on DODO Pair and triggers flash swap
 3. DODO Pair transfers 1 WETH to UniswapArbitrageur
 4. DODO Pair calls dodoCall on UniswapArbitrageur
 5. UniswapArbitrageur transfers 1 WETH received from DODO Pair to UniswapV2
 6. UniswapArbitrageur calls swap on UniswapV2
 7. UniswapV2 transfers 200 USDC to UniswapArbitrageur
 8. DODO Pair calls transferFrom and retrieves 150 USDC from UniswapArbitrageur
 9. UniswapArbitrageur transfers the remaining 50 USDC to the user

In summary,

 - Steps 2, 3, 4, and 8 take care of the DODO front
 - Steps 5, 6, and 7 take care of the Uniswap front
 - The user is only exposed to the process of sending transactions and making profits, with everything else abstracted away!

The best part about the UniswapArbitrageur contract is that users do not need any capital, nor do they need to know how DODO and Uniswap work. They would simply call a function and, if the execution succeeds, make a profit. If the execution fails, the users would only lose some gas.

In order to avoid unnecessary gas consumption, we recommend that users use eth_call to execute executeBuyArbitrage or executeSellArbitrage in advance to estimate arbitrage returns. If there is an arbitrage opportunity, these two functions will return profit of quote tokens and base tokens after successful execution.
**** 4.1.4 Some Thoughts on Flash Swap#

Once you have a deep understanding of flash swap, you will realize the superiority of the DeFi world over the centralized world. The composability of smart contracts has elevated the fund utilization of DeFi to an unprecedented level. Thanks to trustlessness, the cost of credit in DeFi is incredibly low. Once this financial system is integrated into the real world, its potential for improving our society and productivity will be truly boundless. The DODO team hopes that flash swap serves as a primer for DeFi builders and beginners alike to gain an appreciation for the power of DeFi.

Flash swap was inspired by dYdX and Uniswap. The DODO team genuinely appriciates and admires what these DeFi pioneers have done before us.
*** 4.2 Initial DODO Offering#

Initial DODO Offering (IDO) is a brand new approach to crypto asset issuance. Instead of paying exorbitant listing fees to get listed on CEXs or other DEXs, it is literally free to offer assets on DODO!

Normally, the PMM algorithm requires a price oracle to provide liquidity, but when there is no external market (which is usually the case when you are just starting your asset offering efforts), you can simply set the oracle price to a constant and start an initial DODO offering.

As discussed in previous sections, DODO, unlike AMM, does not require quote tokens. The only thing you need to do is to deposit your own tokens to the pool. After your token deposit, PMM creates ask side depth on its own. The more tokens you deposit, the better the liquidity.

Because there are no quote tokens in the pool, there is no bid side depth, but there is no need to worry. There are also no base tokens in the market and no one is selling either. IDO might feel somewhat similar to an auction, but there are some important differences.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_long_tail_1.jpeg]]

Remember the constant price you set for the oracle? That price would be the initial offering price. When a trader buys your tokens, the price rises and quote tokens start flowing into the pool. These quote tokens then produce bid side depth as a result. Maybe we could call IDO a bidirectional auction.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_long_tail_2.jpeg]]

Compared to AMM-based platforms, asset issuance on DODO provides more benefits:

 - Sell tokens from an arbitrary price of your choice with zero capital requirement
 - Sufficient and contract-fillable liquidity
 - Flexible parameters (design your price curve by fine-tuning the parameters)

** 5 Authority#

There are two special roles in each DODO Pair smart contract: admin and supervisor.

Here I would like to introduce the scope of power of admin and supervisor, and the principles of design behind.
*** 5.1 Scope#

Power of the supervisor is a subset of that of admin, and both supervisor and admin have A-level authority. Level A permissions include:

 - Disable trade
 - Disable deposit
 - Set gas price limit

admin is the only one with B-level authority, which includes:

 - Change admin
 - Change supervisor
 - Change maintainer
 - Change oracle
 - Set liquidity provider fee rate
 - Set maintainer fee rate
 - Set K
 - Enable trade
 - Enable deposit
 - Final settlement

*** 5.2 Principle#

Level-A authority can be summarized as "freeze status" i.e. some functions of the system can be stopped urgently, but the status cannot be changed. In order to limit the power of admin, often actions taken by admin have to go through a complex governance process. To be risk resistant, we need a more flexible supervisor instead of an admin to take some actions that are not so sensitive but can significantly reduce system risks.

The B-level authority basically covers all aspects of the DODO Pair contract. The reason why so many parameters are designed to be variable is to better adapt to the rapidly changing market environment. It also leaves room for governance in the future.

It is worth pointing out that no one can prohibit users from withdrawing coins. Being non-custodial is the most important principle of Defi.
** 6 Decentralization#

In our vision, DODO will be fully governed by the community, and controlled by three DAOs

 - Admin DAO

Act as an administrator, the ultimate mediator of all issues.

 - Risk Control DAO

Act as a supervisor and deal with all risk events urgently.

 - Earn DAO

To distribute revenue of maintainer.

When DODO was launched, all authorities were governed by the team. As the community learns more about DODO, we will gradually return all the rights to the community. Although there is no timeline for this process yet, we do intend to follow the process.

Steps:

 1. Set Admin to multi-sig wallet with daily limit
 2. Deploy DODOWild: Allows anyone create their own DODO
 3. Issue governance token
 4. Set Maintainer to Earn DAO
 5. Set Admin to Admin DAO
 6. Set Supervisor to Risk Control DAO

What is the purpose of each step?

 - All admin actions come with a public announcement period to avoid single point failure
 - Anyone can create a new DODO Pair and use it to provide liquidity to their tokens. This marks the return of the code to the community
 - Issue governance tokens and formulate a token distribution plan, which will initiate the step down process
 - Hand over the profit distribution responsibility to Earn DAO
 - After handing admin authority over to the DAO, the team has no real control rights, and only reserves the right to control risk
 - The team steps down completely, marking the last step towards complete decentralization

** 7 Risk Parameters#
*** 7.1 Front Running#

Front running on DODO could occur in the following scenario.

Arbitrageurs listen for oracle price updates transactions. If they see that the oracle price for an asset will go up in the next block, they will buy asset on DODO before the price update by paying higher gas prices. And sell the asset immediately after the oracle price has been updated. This will result in a loss for liquidity providers, and this loss is referred to as arbitrage loss.

This might seem like a big deal, but the truth is, such opportunities are few and far between, and not necessarily profitable for arbitrageurs.

First of all, front running is only profitable when the price fluctuates significantly. This is because DODO charges a 0.3% transaction fee per trade, thus buying and selling assets once incurs a 0.6% transaction fee overall. Therefore, if the price discrepancy between the oracle updates is less than 0.6%, front running is not profitable at all for arbitrageurs.

Secondly, DODO uses Chainlink as its oracle of choice. The Chainlink price oracle provides price updates by aggregating updates from 22 independent price feeders. This means that price changes on DODO are usually gradual and thus not susceptible to front running.

With that said, although the probability of a significant price change between updates is low, it will happen, and arbitrageurs looking to extract value from the system will take advantage of front running. The DODO team conducted extensive backtesting and discovered that in the overwhelming majority of cases, profit from market making far outweighs arbitrage loss for liquidity providers.

Please note that arbitrage loss due to front running will increase significantly during drastic market fluctuations. The DODO team recommends withdrawing your assets during fluctuations to avert the risk and proceeding with caution depending on your risk profile.
*** 7.2 Fee Percentage#

As mentioned above, the transaction fee deters arbitrageurs from extracting value from the system via front running, protecting liquidity providers from arbitrage loss.

The question is, what should the transaction fee percentage be? Lowering the percentage leads to more trading, potentially increasing profit for liquidity providers, but also elevating risk of arbitrage loss. On the other hand, increasing the percentage lowers the risk of arbitrage loss, but also reduces profit for liquidity providers. It is crucial to strike a reasonable balance between risk and profit.

Since market fluctuations have a bearing on arbitrageur behaviors, the fee percentage should also be fine-tuned based on market changes. The fee percentage should be low to facilitate more trading when the market is relatively stable, and high when the market is fluctuating. Determining the appropriate fee percentage is an important governance issue, and users should collectively have a say in how much risk they are willing to take on.
*** 7.3 Parameter K#

Another important parameter is k from the PMM pricing formula. A small k provides good liquidity and increase trading volume, but increases the risk of arbitrage loss; whereas a large k hurts liquidity and decreases trading volume, but reduces the risk of arbitrage loss. Therefore, similar to the fee percentage above, the value of k should be governed and determined by the users.
** 8 Backtest#
*** 8.1 Background#

PMM stands for Proactive Market Maker, which is essentially a quantitative trading strategy used by liquidity providers (LP). To help LP understand ROI of PMM, we've performed a backtest to demonstrate the performance of PMM in different market environments.
*** 8.2 Method#

Evaluation of PMM focuses on these two aspects: proﬁt and loss. The proﬁt for LP is turnover rate multiplied by fee rate. While the loss has to be explained in two perspectives, counterparty risk and arbitrage trading. Counterparty risk can be ignored in this case, because PMM has built a mechanism to limit this risk. In addition, the risk comes from trades by normal users, which are almost random and are statistically balanced against. Arbitrage trading is inevitable and contributes most of the loss, as onchain oracle price is always delayed from market. Hence, in the following backtesting, we focus on these two key values:

    Turnover rate (profit wise)
    Arbitrage loss (loss wise)

*** 8.3 Profit Evaluation#

Assumptions:

 - Our pool size is 1/10 of uniswap's pool size
 - Base Token and Quote Token have the same value
 - PMM parameter k=0.1
 - Fee rate 0.3%

Those assumptions are not set arbitrarily. Under this condition, PMM could provide the same liquidity as Uniswap, and hence it's reasonable to assume PMM has the same trading volume as Uniswap. However, because of aggregators, it's more realistic to assume PMM has half of the trading volume of Uniswap. According to history data[fn:6], PMM daily turnover rate is about 100% and ROI is 0.3%.

Please note: The backtest report is written at 2020/7/19. We use Uniswap's historical data from 2020/6/1 to 2020/7/18.

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_backtest.png]]
*** 8.4 Loss Evaluation#

It's more complex to evaluate arbitrage loss, as no PMM-like algorithm has been deployed before. The best alternative is backtest with the most stringent standards. below is the assumptions:

    Onchain oracle price is always delayed from market price
    Oracle price updates whenever deviates from market price by more than 0.5% (chainlink threshold)
    Arbitrageurs always have enough funding and never miss a trade
    The external cost of arbitrageurs is 0.2% (including CEX fees and gas cost)

We backtested using BTC price from Apr-2018 to Apr-2020 with 1 minute interval. Aggregate profit and loss, we got the following conclusions.
*** 8.5 Conclusion#

The backtesting has covered most cases of the market environment, both the bull and bear market, even including the black swan event on 12th March. We concluded that:

 - In most market environments, the fee income is sufficient to cover arbitrage losses and provides a very high rate of return (~80% APR)
 - When the market changes volatilely, despite of rises or falls, LP will lose a significant amount of money

In brief, PMM makes proﬁts when the market is flat, while makes losses when volatile.
*** 8.6 Advantage & Disadvantage#

Most quant strategies make proﬁts only when market price goes up or down, and there is nothing to do when the market is flat. In contrast, PMM can make considerable proﬁts when the price is nearly flat. Furthermore, unlike AMM, PMM never requires LP to deposit base and quote assets at a certain ratio. Instead, LP could deposit any amount of any asset as they want. As a result, PMM can be a supplement to the original strategies when the market is not volatile.

Nevertheless, we have to point out its disadvantages. As the old saying goes, there is no free lunch. When the market is volatile, LP suffers from significant loss. LP should make a balance between risks and beneﬁts. So we recommend traders withdraw their assets when they predict the market to be volatile. As a decentralized project, what we can do is very limited. But we would deﬁnitely try our best to adjust system parameters to help LP, especially when black swan event happens.

In addition, one of the inherent drawbacks of backtesting is it cannot simulate 100% of the real trading. But to mitigate this risk, we have performed the backtesting with the most conservative assumptions. Still, LP should determine to what extent they trust the backtesting result.
*** 8.7 FAQ about Backtest#

1. Where does the turnover rate data come from?

We have counted the historical data of Uniswap in the past month. Because the capital utilization rate of PMM algorithm is very high, the capital utilization rate can reach ten times that of Uniswap. So the actual turnover rate is also much higher than Uniswap.

2. Why do you use BTC price for backtesting?

Because we did not find ETH price data of high-precision. We would be very grateful if someone could provide ETH price historical data with 1min interval or more frequent. But it is reasonable to use BTC price to estimate loss, because ETH and BTC prices are highly correlated.

3. How does the arbitrage work?

The arbitrage is carried out when arbitrageurs notice that the price provided by the PMM is more beneficial to them than the market price, i.e. the difference between the PMM and the market price is less than its comprehensive arbitrage cost (PMM Fee + Arbitrage Cost)

4. Given that Chainlink's BTC Oracle accuracy rate is 1%, why is it set to 0.5% here?

First of all, Chainlink will increase the accuracy rate of BTC Oracle to 0.5% soon. Secondly, PMM will focus on ETH trading pair for now. And the accuracy rate of Chainlink's ETH Oracle is 0.5%.

5. Does the size of the funding pool have an impact on the backtest?

Yes, it does. ROI will not be so good if the pool size is too small. We need enough liquidity to compete with other liquidity sources. Actually, the 1/10 of Uniswap pool size required for backtesting is able to produce competitive liquidity, which equals only $900,000.

6. How about the gas cost

Swap between two standard ERC20 token cost 145,000 ~ 175,000 gas. The gas cost is slightly higher than Uniswap(~100,000 gas), but significantly lower than other protocols. For example, kyber costs ~400,000 gas; balancer costs ~300,000 gas; dydx costs ~400,000 gas;
** 9 Token Economy#

Since inception, our goal at DODO Family has been to decentralize and diversify governance of the DODO Exchange. We would like to issue the Governance Token: DODO, to achieve this goal.

The total supply of DODO token is 1,000,000,000. The distribution would be:

#+ATTR_ORG: :width 500
[[https://dodoex.github.io/docs/img/dodo_token_distribution.png]]

60,000,000  DODO Token to Seed Round Investors. this part of token will be locked 1 year after token issuance, and then linearly vested over nest 2 years per Ethereum Block.
100,000,000 DODO Token to Private Round Investors. this part of token will be locked 6 month after token issuance, and then linearly vested over next 1 year per Ethereum Block.
150,000,000 DODO Token to Core Team / Future Hires / Advisors, this part of token will have the same lock up period with Seed Round Investors.
10,000,000  DODO Token reserved for Initial DODO Offering(IDO), this part of token will circulate immediately after IDO.
80,000,000  DODO Token reserved by DODOEX Foundation for operations, marketing campaign, partnership, exchange listing or future uses.
600,000,000 DODO Token reserved for community incentives. This part of Token will be distributed to DODO's supporter who participate in the protocol.

In DODO's vision for a prudent, truly decentralized governance model, individual traders and liquidity providers (LPs) assume essential roles in ensuring the integrity of the ecosystem as its participants. The DODO team recognizes their importance in facilitating the growth of the DODO platform, and firmly believes that early adopters should be rewarded accordingly for their faith in the platform as it scales up. This is why the team intends to distribute DODO tokens to LPs in a fair and transparent manner.

Liquidity mining has been empirically proven by various DeFi projects to be an extremely effective and appealing way to incentivize participants, and the team may consider adopting this scheme going forward if needed. And the DODO Token mining and distribution strategy can be modified by DAO Governance in future.

** Footnotes

[fn:1] https://en.wikipedia.org/wiki/Bid%E2%80%93ask\_spread
[fn:2] https://github.com/DODOEX/dodo-smart-contract/blob/master/contracts/lib/DODOMath.sol
[fn:3] https://github.com/DODOEX/dodo-smart-contract/blob/master/contracts/impl/Trader.sol
[fn:4] https://github.com/DODOEX/dodo-smart-contract/blob/master/contracts/helper/UniswapArbitrageur.sol
[fn:5] https://etherscan.io/address/0xbf90b54cc00ceeaa93db1f6a54a01e3fe9ed4422
[fn:6] https://info.uniswap.org/pair/0xb4e16d0168e52d35cacd2c6185b44281ec28c9dc

* dodo contracts
** DODOEthProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";
import {SafeERC20} from "./lib/SafeERC20.sol";
import {SafeMath} from "./lib/SafeMath.sol";
import {IDODO} from "./intf/IDODO.sol";
import {IERC20} from "./intf/IERC20.sol";
import {IWETH} from "./intf/IWETH.sol";

#+end_src
*** interface
*** DODOEthProxy
*** sellEthToToken
*** getDODO
*** function

#+begin_src solidity
interface IDODOZoo {
    function getDODO(address baseToken, address quoteToken) external view returns (address);
}

/**
 * @title DODO Eth Proxy
 * @author DODO Breeder
 *
 * @notice Handle ETH-WETH converting for users.
 */
contract DODOEthProxy is ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    address public _DODO_ZOO_;
    address payable public _WETH_;

    // ============ Events ============

    event ProxySellEthToToken(
        address indexed seller,
        address indexed quoteToken,
        uint256 payEth,
        uint256 receiveToken
    );

    event ProxyBuyEthWithToken(
        address indexed buyer,
        address indexed quoteToken,
        uint256 receiveEth,
        uint256 payToken
    );

    event ProxySellTokenToEth(
        address indexed seller,
        address indexed baseToken,
        uint256 payToken,
        uint256 receiveEth
    );

    event ProxyBuyTokenWithEth(
        address indexed buyer,
        address indexed baseToken,
        uint256 receiveToken,
        uint256 payEth
    );

    event ProxyDepositEthAsBase(address indexed lp, address indexed DODO, uint256 ethAmount);

    event ProxyWithdrawEthAsBase(address indexed lp, address indexed DODO, uint256 ethAmount);

    event ProxyDepositEthAsQuote(address indexed lp, address indexed DODO, uint256 ethAmount);

    event ProxyWithdrawEthAsQuote(address indexed lp, address indexed DODO, uint256 ethAmount);

    // ============ Functions ============

    constructor(address dodoZoo, address payable weth) public {
        _DODO_ZOO_ = dodoZoo;
        _WETH_ = weth;
    }

    fallback() external payable {
        require(msg.sender == _WETH_, "WE_SAVED_YOUR_ETH_:)");
    }

    receive() external payable {
        require(msg.sender == _WETH_, "WE_SAVED_YOUR_ETH_:)");
    }

    function sellEthToToken(
        address quoteTokenAddress,
        uint256 ethAmount,
        uint256 minReceiveTokenAmount
    ) external payable preventReentrant returns (uint256 receiveTokenAmount) {
        require(msg.value == ethAmount, "ETH_AMOUNT_NOT_MATCH");
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(_WETH_, quoteTokenAddress);
        require(DODO != address(0), "DODO_NOT_EXIST");
        IWETH(_WETH_).deposit{value: ethAmount}();
        IWETH(_WETH_).approve(DODO, ethAmount);
        receiveTokenAmount = IDODO(DODO).sellBaseToken(ethAmount, minReceiveTokenAmount, "");
        _transferOut(quoteTokenAddress, msg.sender, receiveTokenAmount);
        emit ProxySellEthToToken(msg.sender, quoteTokenAddress, ethAmount, receiveTokenAmount);
        return receiveTokenAmount;
    }

    function buyEthWithToken(
        address quoteTokenAddress,
        uint256 ethAmount,
        uint256 maxPayTokenAmount
    ) external preventReentrant returns (uint256 payTokenAmount) {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(_WETH_, quoteTokenAddress);
        require(DODO != address(0), "DODO_NOT_EXIST");
        payTokenAmount = IDODO(DODO).queryBuyBaseToken(ethAmount);
        _transferIn(quoteTokenAddress, msg.sender, payTokenAmount);
        IERC20(quoteTokenAddress).safeApprove(DODO, payTokenAmount);
        IDODO(DODO).buyBaseToken(ethAmount, maxPayTokenAmount, "");
        IWETH(_WETH_).withdraw(ethAmount);
        msg.sender.transfer(ethAmount);
        emit ProxyBuyEthWithToken(msg.sender, quoteTokenAddress, ethAmount, payTokenAmount);
        return payTokenAmount;
    }

    function sellTokenToEth(
        address baseTokenAddress,
        uint256 tokenAmount,
        uint256 minReceiveEthAmount
    ) external preventReentrant returns (uint256 receiveEthAmount) {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(baseTokenAddress, _WETH_);
        require(DODO != address(0), "DODO_NOT_EXIST");
        IERC20(baseTokenAddress).safeApprove(DODO, tokenAmount);
        _transferIn(baseTokenAddress, msg.sender, tokenAmount);
        receiveEthAmount = IDODO(DODO).sellBaseToken(tokenAmount, minReceiveEthAmount, "");
        IWETH(_WETH_).withdraw(receiveEthAmount);
        msg.sender.transfer(receiveEthAmount);
        emit ProxySellTokenToEth(msg.sender, baseTokenAddress, tokenAmount, receiveEthAmount);
        return receiveEthAmount;
    }

    function buyTokenWithEth(
        address baseTokenAddress,
        uint256 tokenAmount,
        uint256 maxPayEthAmount
    ) external payable preventReentrant returns (uint256 payEthAmount) {
        require(msg.value == maxPayEthAmount, "ETH_AMOUNT_NOT_MATCH");
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(baseTokenAddress, _WETH_);
        require(DODO != address(0), "DODO_NOT_EXIST");
        payEthAmount = IDODO(DODO).queryBuyBaseToken(tokenAmount);
        IWETH(_WETH_).deposit{value: payEthAmount}();
        IWETH(_WETH_).approve(DODO, payEthAmount);
        IDODO(DODO).buyBaseToken(tokenAmount, maxPayEthAmount, "");
        _transferOut(baseTokenAddress, msg.sender, tokenAmount);
        uint256 refund = maxPayEthAmount.sub(payEthAmount);
        if (refund > 0) {
            msg.sender.transfer(refund);
        }
        emit ProxyBuyTokenWithEth(msg.sender, baseTokenAddress, tokenAmount, payEthAmount);
        return payEthAmount;
    }

    function depositEthAsBase(uint256 ethAmount, address quoteTokenAddress)
        external
        payable
        preventReentrant
    {
        require(msg.value == ethAmount, "ETH_AMOUNT_NOT_MATCH");
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(_WETH_, quoteTokenAddress);
        require(DODO != address(0), "DODO_NOT_EXIST");
        IWETH(_WETH_).deposit{value: ethAmount}();
        IWETH(_WETH_).approve(DODO, ethAmount);
        IDODO(DODO).depositBaseTo(msg.sender, ethAmount);
        emit ProxyDepositEthAsBase(msg.sender, DODO, ethAmount);
    }

    function withdrawEthAsBase(uint256 ethAmount, address quoteTokenAddress)
        external
        preventReentrant
        returns (uint256 withdrawAmount)
    {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(_WETH_, quoteTokenAddress);
        require(DODO != address(0), "DODO_NOT_EXIST");
        address ethLpToken = IDODO(DODO)._BASE_CAPITAL_TOKEN_();

        // transfer all pool shares to proxy
        uint256 lpBalance = IERC20(ethLpToken).balanceOf(msg.sender);
        IERC20(ethLpToken).transferFrom(msg.sender, address(this), lpBalance);
        IDODO(DODO).withdrawBase(ethAmount);

        // transfer remain shares back to msg.sender
        lpBalance = IERC20(ethLpToken).balanceOf(address(this));
        IERC20(ethLpToken).transfer(msg.sender, lpBalance);

        // because of withdraw penalty, withdrawAmount may not equal to ethAmount
        // query weth amount first and than transfer ETH to msg.sender
        uint256 wethAmount = IERC20(_WETH_).balanceOf(address(this));
        IWETH(_WETH_).withdraw(wethAmount);
        msg.sender.transfer(wethAmount);
        emit ProxyWithdrawEthAsBase(msg.sender, DODO, wethAmount);
        return wethAmount;
    }

    function withdrawAllEthAsBase(address quoteTokenAddress)
        external
        preventReentrant
        returns (uint256 withdrawAmount)
    {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(_WETH_, quoteTokenAddress);
        require(DODO != address(0), "DODO_NOT_EXIST");
        address ethLpToken = IDODO(DODO)._BASE_CAPITAL_TOKEN_();

        // transfer all pool shares to proxy
        uint256 lpBalance = IERC20(ethLpToken).balanceOf(msg.sender);
        IERC20(ethLpToken).transferFrom(msg.sender, address(this), lpBalance);
        IDODO(DODO).withdrawAllBase();

        // because of withdraw penalty, withdrawAmount may not equal to ethAmount
        // query weth amount first and than transfer ETH to msg.sender
        uint256 wethAmount = IERC20(_WETH_).balanceOf(address(this));
        IWETH(_WETH_).withdraw(wethAmount);
        msg.sender.transfer(wethAmount);
        emit ProxyWithdrawEthAsBase(msg.sender, DODO, wethAmount);
        return wethAmount;
    }

    function depositEthAsQuote(uint256 ethAmount, address baseTokenAddress)
        external
        payable
        preventReentrant
    {
        require(msg.value == ethAmount, "ETH_AMOUNT_NOT_MATCH");
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(baseTokenAddress, _WETH_);
        require(DODO != address(0), "DODO_NOT_EXIST");
        IWETH(_WETH_).deposit{value: ethAmount}();
        IWETH(_WETH_).approve(DODO, ethAmount);
        IDODO(DODO).depositQuoteTo(msg.sender, ethAmount);
        emit ProxyDepositEthAsQuote(msg.sender, DODO, ethAmount);
    }

    function withdrawEthAsQuote(uint256 ethAmount, address baseTokenAddress)
        external
        preventReentrant
        returns (uint256 withdrawAmount)
    {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(baseTokenAddress, _WETH_);
        require(DODO != address(0), "DODO_NOT_EXIST");
        address ethLpToken = IDODO(DODO)._QUOTE_CAPITAL_TOKEN_();

        // transfer all pool shares to proxy
        uint256 lpBalance = IERC20(ethLpToken).balanceOf(msg.sender);
        IERC20(ethLpToken).transferFrom(msg.sender, address(this), lpBalance);
        IDODO(DODO).withdrawQuote(ethAmount);

        // transfer remain shares back to msg.sender
        lpBalance = IERC20(ethLpToken).balanceOf(address(this));
        IERC20(ethLpToken).transfer(msg.sender, lpBalance);

        // because of withdraw penalty, withdrawAmount may not equal to ethAmount
        // query weth amount first and than transfer ETH to msg.sender
        uint256 wethAmount = IERC20(_WETH_).balanceOf(address(this));
        IWETH(_WETH_).withdraw(wethAmount);
        msg.sender.transfer(wethAmount);
        emit ProxyWithdrawEthAsQuote(msg.sender, DODO, wethAmount);
        return wethAmount;
    }

    function withdrawAllEthAsQuote(address baseTokenAddress)
        external
        preventReentrant
        returns (uint256 withdrawAmount)
    {
        address DODO = IDODOZoo(_DODO_ZOO_).getDODO(baseTokenAddress, _WETH_);
        require(DODO != address(0), "DODO_NOT_EXIST");
        address ethLpToken = IDODO(DODO)._QUOTE_CAPITAL_TOKEN_();

        // transfer all pool shares to proxy
        uint256 lpBalance = IERC20(ethLpToken).balanceOf(msg.sender);
        IERC20(ethLpToken).transferFrom(msg.sender, address(this), lpBalance);
        IDODO(DODO).withdrawAllQuote();

        // because of withdraw penalty, withdrawAmount may not equal to ethAmount
        // query weth amount first and than transfer ETH to msg.sender
        uint256 wethAmount = IERC20(_WETH_).balanceOf(address(this));
        IWETH(_WETH_).withdraw(wethAmount);
        msg.sender.transfer(wethAmount);
        emit ProxyWithdrawEthAsQuote(msg.sender, DODO, wethAmount);
        return wethAmount;
    }

    // ============ Helper Functions ============

    function _transferIn(
        address tokenAddress,
        address from,
        uint256 amount
    ) internal {
        IERC20(tokenAddress).safeTransferFrom(from, address(this), amount);
    }

    function _transferOut(
        address tokenAddress,
        address to,
        uint256 amount
    ) internal {
        IERC20(tokenAddress).safeTransfer(to, amount);
    }
}
#+end_src
** dodo.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Types} from "./lib/Types.sol";
import {IERC20} from "./intf/IERC20.sol";
import {Storage} from "./impl/Storage.sol";
import {Trader} from "./impl/Trader.sol";
import {LiquidityProvider} from "./impl/LiquidityProvider.sol";
import {Admin} from "./impl/Admin.sol";
import {DODOLpToken} from "./impl/DODOLpToken.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title DODO
 * @author DODO Breeder
 *
 * @notice Entrance for users
 */
contract DODO is Admin, Trader, LiquidityProvider {
    function init(
        address owner,
        address supervisor,
        address maintainer,
        address baseToken,
        address quoteToken,
        address oracle,
        uint256 lpFeeRate,
        uint256 mtFeeRate,
        uint256 k,
        uint256 gasPriceLimit
    ) external {
        require(!_INITIALIZED_, "DODO_INITIALIZED");
        _INITIALIZED_ = true;

        // constructor
        _OWNER_ = owner;
        emit OwnershipTransferred(address(0), _OWNER_);

        _SUPERVISOR_ = supervisor;
        _MAINTAINER_ = maintainer;
        _BASE_TOKEN_ = baseToken;
        _QUOTE_TOKEN_ = quoteToken;
        _ORACLE_ = oracle;

        _DEPOSIT_BASE_ALLOWED_ = false;
        _DEPOSIT_QUOTE_ALLOWED_ = false;
        _TRADE_ALLOWED_ = false;
        _GAS_PRICE_LIMIT_ = gasPriceLimit;

        // Advanced controls are disabled by default
        _BUYING_ALLOWED_ = true;
        _SELLING_ALLOWED_ = true;
        uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
        _BASE_BALANCE_LIMIT_ = MAX_INT;
        _QUOTE_BALANCE_LIMIT_ = MAX_INT;

        _LP_FEE_RATE_ = lpFeeRate;
        _MT_FEE_RATE_ = mtFeeRate;
        _K_ = k;
        _R_STATUS_ = Types.RStatus.ONE;

        _BASE_CAPITAL_TOKEN_ = address(new DODOLpToken(_BASE_TOKEN_));
        _QUOTE_CAPITAL_TOKEN_ = address(new DODOLpToken(_QUOTE_TOKEN_));

        _checkDODOParameters();
    }
}

#+end_src
** DODOZoo.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Ownable} from "./lib/Ownable.sol";
import {IDODO} from "./intf/IDODO.sol";
import {ICloneFactory} from "./helper/CloneFactory.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title DODOZoo
 * @author DODO Breeder
 *
 * @notice Register of All DODO
 */
contract DODOZoo is Ownable {
    address public _DODO_LOGIC_;
    address public _CLONE_FACTORY_;

    address public _DEFAULT_SUPERVISOR_;

    mapping(address => mapping(address => address)) internal _DODO_REGISTER_;
    address[] public _DODOs;

    // ============ Events ============

    event DODOBirth(address newBorn, address baseToken, address quoteToken);

    // ============ Constructor Function ============

    constructor(
        address _dodoLogic,
        address _cloneFactory,
        address _defaultSupervisor
    ) public {
        _DODO_LOGIC_ = _dodoLogic;
        _CLONE_FACTORY_ = _cloneFactory;
        _DEFAULT_SUPERVISOR_ = _defaultSupervisor;
    }

    // ============ Admin Function ============

    function setDODOLogic(address _dodoLogic) external onlyOwner {
        _DODO_LOGIC_ = _dodoLogic;
    }

    function setCloneFactory(address _cloneFactory) external onlyOwner {
        _CLONE_FACTORY_ = _cloneFactory;
    }

    function setDefaultSupervisor(address _defaultSupervisor) external onlyOwner {
        _DEFAULT_SUPERVISOR_ = _defaultSupervisor;
    }

    function removeDODO(address dodo) external onlyOwner {
        address baseToken = IDODO(dodo)._BASE_TOKEN_();
        address quoteToken = IDODO(dodo)._QUOTE_TOKEN_();
        require(isDODORegistered(baseToken, quoteToken), "DODO_NOT_REGISTERED");
        _DODO_REGISTER_[baseToken][quoteToken] = address(0);
        for (uint256 i = 0; i <= _DODOs.length - 1; i++) {
            if (_DODOs[i] == dodo) {
                _DODOs[i] = _DODOs[_DODOs.length - 1];
                _DODOs.pop();
                break;
            }
        }
    }

    function addDODO(address dodo) public onlyOwner {
        address baseToken = IDODO(dodo)._BASE_TOKEN_();
        address quoteToken = IDODO(dodo)._QUOTE_TOKEN_();
        require(!isDODORegistered(baseToken, quoteToken), "DODO_REGISTERED");
        _DODO_REGISTER_[baseToken][quoteToken] = dodo;
        _DODOs.push(dodo);
    }

    // ============ Breed DODO Function ============

    function breedDODO(
        address maintainer,
        address baseToken,
        address quoteToken,
        address oracle,
        uint256 lpFeeRate,
        uint256 mtFeeRate,
        uint256 k,
        uint256 gasPriceLimit
    ) external onlyOwner returns (address newBornDODO) {
        require(!isDODORegistered(baseToken, quoteToken), "DODO_REGISTERED");
        newBornDODO = ICloneFactory(_CLONE_FACTORY_).clone(_DODO_LOGIC_);
        IDODO(newBornDODO).init(
            _OWNER_,
            _DEFAULT_SUPERVISOR_,
            maintainer,
            baseToken,
            quoteToken,
            oracle,
            lpFeeRate,
            mtFeeRate,
            k,
            gasPriceLimit
        );
        addDODO(newBornDODO);
        emit DODOBirth(newBornDODO, baseToken, quoteToken);
        return newBornDODO;
    }

    // ============ View Functions ============

    function isDODORegistered(address baseToken, address quoteToken) public view returns (bool) {
        if (
            _DODO_REGISTER_[baseToken][quoteToken] == address(0) &&
            _DODO_REGISTER_[quoteToken][baseToken] == address(0)
        ) {
            return false;
        } else {
            return true;
        }
    }

    function getDODO(address baseToken, address quoteToken) external view returns (address) {
        return _DODO_REGISTER_[baseToken][quoteToken];
    }

    function getDODOs() external view returns (address[] memory) {
        return _DODOs;
    }
}

#+end_src
** token/DODOMine.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Ownable} from "../lib/Ownable.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";
import {SafeMath} from "../lib/SafeMath.sol";
import {IERC20} from "../intf/IERC20.sol";
import {IDODORewardVault, DODORewardVault} from "./DODORewardVault.sol";


#+end_src
*** function
#+begin_src solidity

contract DODOMine is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // Info of each user.
    struct UserInfo {
        uint256 amount; // How many LP tokens the user has provided.
        uint256 rewardDebt; // Reward debt. See explanation below.
        //
        // We do some fancy math here. Basically, any point in time, the amount of DODOs
        // entitled to a user but is pending to be distributed is:
        //
        //   pending reward = (user.amount * pool.accDODOPerShare) - user.rewardDebt
        //
        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:
        //   1. The pool's `accDODOPerShare` (and `lastRewardBlock`) gets updated.
        //   2. User receives the pending reward sent to his/her address.
        //   3. User's `amount` gets updated.
        //   4. User's `rewardDebt` gets updated.
    }

    // Info of each pool.
    struct PoolInfo {
        address lpToken; // Address of LP token contract.
        uint256 allocPoint; // How many allocation points assigned to this pool. DODOs to distribute per block.
        uint256 lastRewardBlock; // Last block number that DODOs distribution occurs.
        uint256 accDODOPerShare; // Accumulated DODOs per share, times 1e12. See below.
    }

    address public dodoRewardVault;
    uint256 public dodoPerBlock;

    // Info of each pool.
    PoolInfo[] public poolInfos;
    mapping(address => uint256) public lpTokenRegistry;

    // Info of each user that stakes LP tokens.
    mapping(uint256 => mapping(address => UserInfo)) public userInfo;
    mapping(address => uint256) public realizedReward;

    // Total allocation points. Must be the sum of all allocation points in all pools.
    uint256 public totalAllocPoint = 0;
    // The block number when DODO mining starts.
    uint256 public startBlock;

    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);
    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);
    event Claim(address indexed user, uint256 amount);

    constructor(address _dodoToken, uint256 _startBlock) public {
        dodoRewardVault = address(new DODORewardVault(_dodoToken));
        startBlock = _startBlock;
    }

    // ============ Modifiers ============

    modifier lpTokenExist(address lpToken) {
        require(lpTokenRegistry[lpToken] > 0, "LP Token Not Exist");
        _;
    }

    modifier lpTokenNotExist(address lpToken) {
        require(lpTokenRegistry[lpToken] == 0, "LP Token Already Exist");
        _;
    }

    // ============ Helper ============

    function poolLength() external view returns (uint256) {
        return poolInfos.length;
    }

    function getPid(address _lpToken) public view lpTokenExist(_lpToken) returns (uint256) {
        return lpTokenRegistry[_lpToken] - 1;
    }

    function getUserLpBalance(address _lpToken, address _user) public view returns (uint256) {
        uint256 pid = getPid(_lpToken);
        return userInfo[pid][_user].amount;
    }

    // ============ Ownable ============

    function addLpToken(
        address _lpToken,
        uint256 _allocPoint,
        bool _withUpdate
    ) public lpTokenNotExist(_lpToken) onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;
        totalAllocPoint = totalAllocPoint.add(_allocPoint);
        poolInfos.push(
            PoolInfo({
                lpToken: _lpToken,
                allocPoint: _allocPoint,
                lastRewardBlock: lastRewardBlock,
                accDODOPerShare: 0
            })
        );
        lpTokenRegistry[_lpToken] = poolInfos.length;
    }

    function setLpToken(
        address _lpToken,
        uint256 _allocPoint,
        bool _withUpdate
    ) public onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        uint256 pid = getPid(_lpToken);
        totalAllocPoint = totalAllocPoint.sub(poolInfos[pid].allocPoint).add(_allocPoint);
        poolInfos[pid].allocPoint = _allocPoint;
    }

    function setReward(uint256 _dodoPerBlock, bool _withUpdate) external onlyOwner {
        if (_withUpdate) {
            massUpdatePools();
        }
        dodoPerBlock = _dodoPerBlock;
    }

    // ============ View Rewards ============

    function getPendingReward(address _lpToken, address _user) external view returns (uint256) {
        uint256 pid = getPid(_lpToken);
        PoolInfo storage pool = poolInfos[pid];
        UserInfo storage user = userInfo[pid][_user];
        uint256 accDODOPerShare = pool.accDODOPerShare;
        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));
        if (block.number > pool.lastRewardBlock && lpSupply != 0) {
            uint256 DODOReward = block
                .number
                .sub(pool.lastRewardBlock)
                .mul(dodoPerBlock)
                .mul(pool.allocPoint)
                .div(totalAllocPoint);
            accDODOPerShare = accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));
        }
        return DecimalMath.mul(user.amount, accDODOPerShare).sub(user.rewardDebt);
    }

    function getAllPendingReward(address _user) external view returns (uint256) {
        uint256 length = poolInfos.length;
        uint256 totalReward = 0;
        for (uint256 pid = 0; pid < length; ++pid) {
            if (userInfo[pid][_user].amount == 0 || poolInfos[pid].allocPoint == 0) {
                continue; // save gas
            }
            PoolInfo storage pool = poolInfos[pid];
            UserInfo storage user = userInfo[pid][_user];
            uint256 accDODOPerShare = pool.accDODOPerShare;
            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));
            if (block.number > pool.lastRewardBlock && lpSupply != 0) {
                uint256 DODOReward = block
                    .number
                    .sub(pool.lastRewardBlock)
                    .mul(dodoPerBlock)
                    .mul(pool.allocPoint)
                    .div(totalAllocPoint);
                accDODOPerShare = accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));
            }
            totalReward = totalReward.add(
                DecimalMath.mul(user.amount, accDODOPerShare).sub(user.rewardDebt)
            );
        }
        return totalReward;
    }

    function getRealizedReward(address _user) external view returns (uint256) {
        return realizedReward[_user];
    }

    function getDlpMiningSpeed(address _lpToken) external view returns (uint256) {
        uint256 pid = getPid(_lpToken);
        PoolInfo storage pool = poolInfos[pid];
        return dodoPerBlock.mul(pool.allocPoint).div(totalAllocPoint);
    }

    // ============ Update Pools ============

    // Update reward vairables for all pools. Be careful of gas spending!
    function massUpdatePools() public {
        uint256 length = poolInfos.length;
        for (uint256 pid = 0; pid < length; ++pid) {
            updatePool(pid);
        }
    }

    // Update reward variables of the given pool to be up-to-date.
    function updatePool(uint256 _pid) public {
        PoolInfo storage pool = poolInfos[_pid];
        if (block.number <= pool.lastRewardBlock) {
            return;
        }
        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));
        if (lpSupply == 0) {
            pool.lastRewardBlock = block.number;
            return;
        }
        uint256 DODOReward = block
            .number
            .sub(pool.lastRewardBlock)
            .mul(dodoPerBlock)
            .mul(pool.allocPoint)
            .div(totalAllocPoint);
        pool.accDODOPerShare = pool.accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));
        pool.lastRewardBlock = block.number;
    }

    // ============ Deposit & Withdraw & Claim ============
    // Deposit & withdraw will also trigger claim

    function deposit(address _lpToken, uint256 _amount) public {
        uint256 pid = getPid(_lpToken);
        PoolInfo storage pool = poolInfos[pid];
        UserInfo storage user = userInfo[pid][msg.sender];
        updatePool(pid);
        if (user.amount > 0) {
            uint256 pending = DecimalMath.mul(user.amount, pool.accDODOPerShare).sub(
                user.rewardDebt
            );
            safeDODOTransfer(msg.sender, pending);
        }
        IERC20(pool.lpToken).safeTransferFrom(address(msg.sender), address(this), _amount);
        user.amount = user.amount.add(_amount);
        user.rewardDebt = DecimalMath.mul(user.amount, pool.accDODOPerShare);
        emit Deposit(msg.sender, pid, _amount);
    }

    function withdraw(address _lpToken, uint256 _amount) public {
        uint256 pid = getPid(_lpToken);
        PoolInfo storage pool = poolInfos[pid];
        UserInfo storage user = userInfo[pid][msg.sender];
        require(user.amount >= _amount, "withdraw too much");
        updatePool(pid);
        uint256 pending = DecimalMath.mul(user.amount, pool.accDODOPerShare).sub(user.rewardDebt);
        safeDODOTransfer(msg.sender, pending);
        user.amount = user.amount.sub(_amount);
        user.rewardDebt = DecimalMath.mul(user.amount, pool.accDODOPerShare);
        IERC20(pool.lpToken).safeTransfer(address(msg.sender), _amount);
        emit Withdraw(msg.sender, pid, _amount);
    }

    function withdrawAll(address _lpToken) public {
        uint256 balance = getUserLpBalance(_lpToken, msg.sender);
        withdraw(_lpToken, balance);
    }

    // Withdraw without caring about rewards. EMERGENCY ONLY.
    function emergencyWithdraw(address _lpToken) public {
        uint256 pid = getPid(_lpToken);
        PoolInfo storage pool = poolInfos[pid];
        UserInfo storage user = userInfo[pid][msg.sender];
        IERC20(pool.lpToken).safeTransfer(address(msg.sender), user.amount);
        user.amount = 0;
        user.rewardDebt = 0;
    }

    function claim(address _lpToken) public {
        uint256 pid = getPid(_lpToken);
        if (userInfo[pid][msg.sender].amount == 0 || poolInfos[pid].allocPoint == 0) {
            return; // save gas
        }
        PoolInfo storage pool = poolInfos[pid];
        UserInfo storage user = userInfo[pid][msg.sender];
        updatePool(pid);
        uint256 pending = DecimalMath.mul(user.amount, pool.accDODOPerShare).sub(user.rewardDebt);
        user.rewardDebt = DecimalMath.mul(user.amount, pool.accDODOPerShare);
        safeDODOTransfer(msg.sender, pending);
    }

    function claimAll() public {
        uint256 length = poolInfos.length;
        uint256 pending = 0;
        for (uint256 pid = 0; pid < length; ++pid) {
            if (userInfo[pid][msg.sender].amount == 0 || poolInfos[pid].allocPoint == 0) {
                continue; // save gas
            }
            PoolInfo storage pool = poolInfos[pid];
            UserInfo storage user = userInfo[pid][msg.sender];
            updatePool(pid);
            pending = pending.add(
                DecimalMath.mul(user.amount, pool.accDODOPerShare).sub(user.rewardDebt)
            );
            user.rewardDebt = DecimalMath.mul(user.amount, pool.accDODOPerShare);
        }
        safeDODOTransfer(msg.sender, pending);
    }

    // Safe DODO transfer function
    function safeDODOTransfer(address _to, uint256 _amount) internal {
        IDODORewardVault(dodoRewardVault).reward(_to, _amount);
        realizedReward[_to] = realizedReward[_to].add(_amount);
        emit Claim(_to, _amount);
    }
}

#+end_src
** token/DODOToken.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";



#+end_src
*** function
#+begin_src solidity
/**
 * @title DODO Token
 * @author DODO Breeder
 */
contract DODOToken {
    using SafeMath for uint256;

    string public symbol = "DODO";
    string public name = "DODO bird";

    uint256 public decimals = 18;
    uint256 public totalSupply = 1000000000 * 10**18; // 1 Billion

    mapping(address => uint256) internal balances;
    mapping(address => mapping(address => uint256)) internal allowed;

    // ============ Events ============

    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    // ============ Functions ============

    constructor() public {
        balances[msg.sender] = totalSupply;
    }

    /**
     * @dev transfer token for a specified address
     * @param to The address to transfer to.
     * @param amount The amount to be transferred.
     */
    function transfer(address to, uint256 amount) public returns (bool) {
        require(amount <= balances[msg.sender], "BALANCE_NOT_ENOUGH");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the the balance of.
     * @return balance An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) external view returns (uint256 balance) {
        return balances[owner];
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param amount uint256 the amount of tokens to be transferred
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        require(amount <= balances[from], "BALANCE_NOT_ENOUGH");
        require(amount <= allowed[from][msg.sender], "ALLOWANCE_NOT_ENOUGH");

        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * @param spender The address which will spend the funds.
     * @param amount The amount of tokens to be spent.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return allowed[owner][spender];
    }
}

#+end_src
** token/DODOMineReader.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {IDODO} from "../intf/IDODO.sol";
import {IERC20} from "../intf/IERC20.sol";
import {SafeMath} from "../lib/SafeMath.sol";


#+end_src
*** function
#+begin_src solidity

interface IDODOMine {
    function getUserLpBalance(address _lpToken, address _user) external view returns (uint256);
}


contract DODOMineReader {
    using SafeMath for uint256;

    function getUserStakedBalance(
        address _dodoMine,
        address _dodo,
        address _user
    ) external view returns (uint256 baseBalance, uint256 quoteBalance) {
        address baseLpToken = IDODO(_dodo)._BASE_CAPITAL_TOKEN_();
        address quoteLpToken = IDODO(_dodo)._QUOTE_CAPITAL_TOKEN_();

        uint256 baseLpBalance = IDODOMine(_dodoMine).getUserLpBalance(baseLpToken, _user);
        uint256 quoteLpBalance = IDODOMine(_dodoMine).getUserLpBalance(quoteLpToken, _user);

        uint256 baseLpTotalSupply = IERC20(baseLpToken).totalSupply();
        uint256 quoteLpTotalSupply = IERC20(quoteLpToken).totalSupply();

        (uint256 baseTarget, uint256 quoteTarget) = IDODO(_dodo).getExpectedTarget();
        baseBalance = baseTarget.mul(baseLpBalance).div(baseLpTotalSupply);
        quoteBalance = quoteTarget.mul(quoteLpBalance).div(quoteLpTotalSupply);

        return (baseBalance, quoteBalance);
    }
}

#+end_src
** token/DODORewardVault.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Ownable} from "../lib/Ownable.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";
import {IERC20} from "../intf/IERC20.sol";


#+end_src
*** function
#+begin_src solidity

interface IDODORewardVault {
    function reward(address to, uint256 amount) external;
}


contract DODORewardVault is Ownable {
    using SafeERC20 for IERC20;

    address public dodoToken;

    constructor(address _dodoToken) public {
        dodoToken = _dodoToken;
    }

    function reward(address to, uint256 amount) external onlyOwner {
        IERC20(dodoToken).safeTransfer(to, amount);
    }
}

#+end_src
** token/LockedTokenVault.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {Ownable} from "../lib/Ownable.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";
import {IERC20} from "../intf/IERC20.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title LockedTokenVault
 * @author DODO Breeder
 *
 * @notice Lock Token and release it linearly
 */

contract LockedTokenVault is Ownable {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address _TOKEN_;

    mapping(address => uint256) internal originBalances;
    mapping(address => uint256) internal claimedBalances;

    uint256 public _UNDISTRIBUTED_AMOUNT_;
    uint256 public _START_RELEASE_TIME_;
    uint256 public _RELEASE_DURATION_;
    uint256 public _CLIFF_RATE_;

    bool public _DISTRIBUTE_FINISHED_;

    // ============ Modifiers ============

    event Claim(address indexed holder, uint256 origin, uint256 claimed, uint256 amount);

    // ============ Modifiers ============

    modifier beforeStartRelease() {
        require(block.timestamp < _START_RELEASE_TIME_, "RELEASE START");
        _;
    }

    modifier afterStartRelease() {
        require(block.timestamp >= _START_RELEASE_TIME_, "RELEASE NOT START");
        _;
    }

    modifier distributeNotFinished() {
        require(!_DISTRIBUTE_FINISHED_, "DISTRIBUTE FINISHED");
        _;
    }

    // ============ Init Functions ============

    constructor(
        address _token,
        uint256 _startReleaseTime,
        uint256 _releaseDuration,
        uint256 _cliffRate
    ) public {
        _TOKEN_ = _token;
        _START_RELEASE_TIME_ = _startReleaseTime;
        _RELEASE_DURATION_ = _releaseDuration;
        _CLIFF_RATE_ = _cliffRate;
    }

    function deposit(uint256 amount) external onlyOwner {
        _tokenTransferIn(_OWNER_, amount);
        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.add(amount);
    }

    function withdraw(uint256 amount) external onlyOwner {
        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.sub(amount);
        _tokenTransferOut(_OWNER_, amount);
    }

    function finishDistribute() external onlyOwner {
        _DISTRIBUTE_FINISHED_ = true;
    }

    // ============ For Owner ============

    function grant(address[] calldata holderList, uint256[] calldata amountList)
        external
        onlyOwner
    {
        require(holderList.length == amountList.length, "batch grant length not match");
        uint256 amount = 0;
        for (uint256 i = 0; i < holderList.length; ++i) {
            // for saving gas, no event for grant
            originBalances[holderList[i]] = originBalances[holderList[i]].add(amountList[i]);
            amount = amount.add(amountList[i]);
        }
        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.sub(amount);
    }

    function recall(address holder) external onlyOwner distributeNotFinished {
        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.add(originBalances[holder]).sub(
            claimedBalances[holder]
        );
        originBalances[holder] = 0;
        claimedBalances[holder] = 0;
    }

    // ============ For Holder ============

    function transferLockedToken(address to) external {
        originBalances[to] = originBalances[to].add(originBalances[msg.sender]);
        claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]);

        originBalances[msg.sender] = 0;
        claimedBalances[msg.sender] = 0;
    }

    function claim() external {
        uint256 claimableToken = getClaimableBalance(msg.sender);
        _tokenTransferOut(msg.sender, claimableToken);
        claimedBalances[msg.sender] = claimedBalances[msg.sender].add(claimableToken);
        emit Claim(
            msg.sender,
            originBalances[msg.sender],
            claimedBalances[msg.sender],
            claimableToken
        );
    }

    // ============ View ============

    function isReleaseStart() external view returns (bool) {
        return block.timestamp >= _START_RELEASE_TIME_;
    }

    function getOriginBalance(address holder) external view returns (uint256) {
        return originBalances[holder];
    }

    function getClaimedBalance(address holder) external view returns (uint256) {
        return claimedBalances[holder];
    }

    function getClaimableBalance(address holder) public view returns (uint256) {
        uint256 remainingToken = getRemainingBalance(holder);
        return originBalances[holder].sub(remainingToken).sub(claimedBalances[holder]);
    }

    function getRemainingBalance(address holder) public view returns (uint256) {
        uint256 remainingRatio = getRemainingRatio(block.timestamp);
        return DecimalMath.mul(originBalances[holder], remainingRatio);
    }

    function getRemainingRatio(uint256 timestamp) public view returns (uint256) {
        if (timestamp < _START_RELEASE_TIME_) {
            return DecimalMath.ONE;
        }
        uint256 timePast = timestamp.sub(_START_RELEASE_TIME_);
        if (timePast < _RELEASE_DURATION_) {
            uint256 remainingTime = _RELEASE_DURATION_.sub(timePast);
            return DecimalMath.ONE.sub(_CLIFF_RATE_).mul(remainingTime).div(_RELEASE_DURATION_);
        } else {
            return 0;
        }
    }

    // ============ Internal Helper ============

    function _tokenTransferIn(address from, uint256 amount) internal {
        IERC20(_TOKEN_).safeTransferFrom(from, address(this), amount);
    }

    function _tokenTransferOut(address to, uint256 amount) internal {
        IERC20(_TOKEN_).safeTransfer(to, amount);
    }
}

#+end_src
** impl/Admin.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Storage} from "./Storage.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title Admin
 * @author DODO Breeder
 *
 * @notice Functions for admin operations
 */
contract Admin is Storage {
    // ============ Events ============

    event UpdateGasPriceLimit(uint256 oldGasPriceLimit, uint256 newGasPriceLimit);

    event UpdateLiquidityProviderFeeRate(
        uint256 oldLiquidityProviderFeeRate,
        uint256 newLiquidityProviderFeeRate
    );

    event UpdateMaintainerFeeRate(uint256 oldMaintainerFeeRate, uint256 newMaintainerFeeRate);

    event UpdateK(uint256 oldK, uint256 newK);

    // ============ Params Setting Functions ============

    function setOracle(address newOracle) external onlyOwner {
        _ORACLE_ = newOracle;
    }

    function setSupervisor(address newSupervisor) external onlyOwner {
        _SUPERVISOR_ = newSupervisor;
    }

    function setMaintainer(address newMaintainer) external onlyOwner {
        _MAINTAINER_ = newMaintainer;
    }

    function setLiquidityProviderFeeRate(uint256 newLiquidityPorviderFeeRate) external onlyOwner {
        emit UpdateLiquidityProviderFeeRate(_LP_FEE_RATE_, newLiquidityPorviderFeeRate);
        _LP_FEE_RATE_ = newLiquidityPorviderFeeRate;
        _checkDODOParameters();
    }

    function setMaintainerFeeRate(uint256 newMaintainerFeeRate) external onlyOwner {
        emit UpdateMaintainerFeeRate(_MT_FEE_RATE_, newMaintainerFeeRate);
        _MT_FEE_RATE_ = newMaintainerFeeRate;
        _checkDODOParameters();
    }

    function setK(uint256 newK) external onlyOwner {
        emit UpdateK(_K_, newK);
        _K_ = newK;
        _checkDODOParameters();
    }

    function setGasPriceLimit(uint256 newGasPriceLimit) external onlySupervisorOrOwner {
        emit UpdateGasPriceLimit(_GAS_PRICE_LIMIT_, newGasPriceLimit);
        _GAS_PRICE_LIMIT_ = newGasPriceLimit;
    }

    // ============ System Control Functions ============

    function disableTrading() external onlySupervisorOrOwner {
        _TRADE_ALLOWED_ = false;
    }

    function enableTrading() external onlyOwner notClosed {
        _TRADE_ALLOWED_ = true;
    }

    function disableQuoteDeposit() external onlySupervisorOrOwner {
        _DEPOSIT_QUOTE_ALLOWED_ = false;
    }

    function enableQuoteDeposit() external onlyOwner notClosed {
        _DEPOSIT_QUOTE_ALLOWED_ = true;
    }

    function disableBaseDeposit() external onlySupervisorOrOwner {
        _DEPOSIT_BASE_ALLOWED_ = false;
    }

    function enableBaseDeposit() external onlyOwner notClosed {
        _DEPOSIT_BASE_ALLOWED_ = true;
    }

    // ============ Advanced Control Functions ============

    function disableBuying() external onlySupervisorOrOwner {
        _BUYING_ALLOWED_ = false;
    }

    function enableBuying() external onlyOwner notClosed {
        _BUYING_ALLOWED_ = true;
    }

    function disableSelling() external onlySupervisorOrOwner {
        _SELLING_ALLOWED_ = false;
    }

    function enableSelling() external onlyOwner notClosed {
        _SELLING_ALLOWED_ = true;
    }

    function setBaseBalanceLimit(uint256 newBaseBalanceLimit) external onlyOwner notClosed {
        _BASE_BALANCE_LIMIT_ = newBaseBalanceLimit;
    }

    function setQuoteBalanceLimit(uint256 newQuoteBalanceLimit) external onlyOwner notClosed {
        _QUOTE_BALANCE_LIMIT_ = newQuoteBalanceLimit;
    }
}

#+end_src
** impl/DODOLpToken.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {IERC20} from "../intf/IERC20.sol";
import {SafeMath} from "../lib/SafeMath.sol";
import {Ownable} from "../lib/Ownable.sol";

#+end_src
*** function
#+begin_src solidity

/**
 * @title DODOLpToken
 * @author DODO Breeder
 *
 * @notice Tokenize liquidity pool assets. An ordinary ERC20 contract with mint and burn functions
 */
contract DODOLpToken is Ownable {
    using SafeMath for uint256;

    string public symbol = "DLP";
    address public originToken;

    uint256 public totalSupply;
    mapping(address => uint256) internal balances;
    mapping(address => mapping(address => uint256)) internal allowed;

    // ============ Events ============

    event Transfer(address indexed from, address indexed to, uint256 amount);

    event Approval(address indexed owner, address indexed spender, uint256 amount);

    event Mint(address indexed user, uint256 value);

    event Burn(address indexed user, uint256 value);

    // ============ Functions ============

    constructor(address _originToken) public {
        originToken = _originToken;
    }

    function name() public view returns (string memory) {
        string memory lpTokenSuffix = "_DODO_LP_TOKEN_";
        return string(abi.encodePacked(IERC20(originToken).name(), lpTokenSuffix));
    }

    function decimals() public view returns (uint8) {
        return IERC20(originToken).decimals();
    }

    /**
     * @dev transfer token for a specified address
     * @param to The address to transfer to.
     * @param amount The amount to be transferred.
     */
    function transfer(address to, uint256 amount) public returns (bool) {
        require(amount <= balances[msg.sender], "BALANCE_NOT_ENOUGH");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    /**
     * @dev Gets the balance of the specified address.
     * @param owner The address to query the the balance of.
     * @return balance An uint256 representing the amount owned by the passed address.
     */
    function balanceOf(address owner) external view returns (uint256 balance) {
        return balances[owner];
    }

    /**
     * @dev Transfer tokens from one address to another
     * @param from address The address which you want to send tokens from
     * @param to address The address which you want to transfer to
     * @param amount uint256 the amount of tokens to be transferred
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        require(amount <= balances[from], "BALANCE_NOT_ENOUGH");
        require(amount <= allowed[from][msg.sender], "ALLOWANCE_NOT_ENOUGH");

        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    /**
     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
     * @param spender The address which will spend the funds.
     * @param amount The amount of tokens to be spent.
     */
    function approve(address spender, uint256 amount) public returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    /**
     * @dev Function to check the amount of tokens that an owner allowed to a spender.
     * @param owner address The address which owns the funds.
     * @param spender address The address which will spend the funds.
     * @return A uint256 specifying the amount of tokens still available for the spender.
     */
    function allowance(address owner, address spender) public view returns (uint256) {
        return allowed[owner][spender];
    }

    function mint(address user, uint256 value) external onlyOwner {
        balances[user] = balances[user].add(value);
        totalSupply = totalSupply.add(value);
        emit Mint(user, value);
        emit Transfer(address(0), user, value);
    }

    function burn(address user, uint256 value) external onlyOwner {
        balances[user] = balances[user].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Burn(user, value);
        emit Transfer(user, address(0), value);
    }
}

#+end_src
** impl/Pricing.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {DODOMath} from "../lib/DODOMath.sol";
import {Types} from "../lib/Types.sol";
import {Storage} from "./Storage.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title Pricing
 * @author DODO Breeder
 *
 * @notice DODO Pricing model
 */
contract Pricing is Storage {
    using SafeMath for uint256;

    // ============ R = 1 cases ============

    function _ROneSellBaseToken(uint256 amount, uint256 targetQuoteTokenAmount)
        internal
        view
        returns (uint256 receiveQuoteToken)
    {
        uint256 i = getOraclePrice();
        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(
            targetQuoteTokenAmount,
            targetQuoteTokenAmount,
            DecimalMath.mul(i, amount),
            false,
            _K_
        );
        // in theory Q2 <= targetQuoteTokenAmount
        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount
        return targetQuoteTokenAmount.sub(Q2);
    }

    function _ROneBuyBaseToken(uint256 amount, uint256 targetBaseTokenAmount)
        internal
        view
        returns (uint256 payQuoteToken)
    {
        require(amount < targetBaseTokenAmount, "DODO_BASE_BALANCE_NOT_ENOUGH");
        uint256 B2 = targetBaseTokenAmount.sub(amount);
        payQuoteToken = _RAboveIntegrate(targetBaseTokenAmount, targetBaseTokenAmount, B2);
        return payQuoteToken;
    }

    // ============ R < 1 cases ============

    function _RBelowSellBaseToken(
        uint256 amount,
        uint256 quoteBalance,
        uint256 targetQuoteAmount
    ) internal view returns (uint256 receieQuoteToken) {
        uint256 i = getOraclePrice();
        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(
            targetQuoteAmount,
            quoteBalance,
            DecimalMath.mul(i, amount),
            false,
            _K_
        );
        return quoteBalance.sub(Q2);
    }

    function _RBelowBuyBaseToken(
        uint256 amount,
        uint256 quoteBalance,
        uint256 targetQuoteAmount
    ) internal view returns (uint256 payQuoteToken) {
        // Here we don't require amount less than some value
        // Because it is limited at upper function
        // See Trader.queryBuyBaseToken
        uint256 i = getOraclePrice();
        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(
            targetQuoteAmount,
            quoteBalance,
            DecimalMath.mulCeil(i, amount),
            true,
            _K_
        );
        return Q2.sub(quoteBalance);
    }

    function _RBelowBackToOne() internal view returns (uint256 payQuoteToken) {
        // important: carefully design the system to make sure spareBase always greater than or equal to 0
        uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);
        uint256 price = getOraclePrice();
        uint256 fairAmount = DecimalMath.mul(spareBase, price);
        uint256 newTargetQuote = DODOMath._SolveQuadraticFunctionForTarget(
            _QUOTE_BALANCE_,
            _K_,
            fairAmount
        );
        return newTargetQuote.sub(_QUOTE_BALANCE_);
    }

    // ============ R > 1 cases ============

    function _RAboveBuyBaseToken(
        uint256 amount,
        uint256 baseBalance,
        uint256 targetBaseAmount
    ) internal view returns (uint256 payQuoteToken) {
        require(amount < baseBalance, "DODO_BASE_BALANCE_NOT_ENOUGH");
        uint256 B2 = baseBalance.sub(amount);
        return _RAboveIntegrate(targetBaseAmount, baseBalance, B2);
    }

    function _RAboveSellBaseToken(
        uint256 amount,
        uint256 baseBalance,
        uint256 targetBaseAmount
    ) internal view returns (uint256 receiveQuoteToken) {
        // here we don't require B1 <= targetBaseAmount
        // Because it is limited at upper function
        // See Trader.querySellBaseToken
        uint256 B1 = baseBalance.add(amount);
        return _RAboveIntegrate(targetBaseAmount, B1, baseBalance);
    }

    function _RAboveBackToOne() internal view returns (uint256 payBaseToken) {
        // important: carefully design the system to make sure spareBase always greater than or equal to 0
        uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);
        uint256 price = getOraclePrice();
        uint256 fairAmount = DecimalMath.divFloor(spareQuote, price);
        uint256 newTargetBase = DODOMath._SolveQuadraticFunctionForTarget(
            _BASE_BALANCE_,
            _K_,
            fairAmount
        );
        return newTargetBase.sub(_BASE_BALANCE_);
    }

    // ============ Helper functions ============

    function getExpectedTarget() public view returns (uint256 baseTarget, uint256 quoteTarget) {
        uint256 Q = _QUOTE_BALANCE_;
        uint256 B = _BASE_BALANCE_;
        if (_R_STATUS_ == Types.RStatus.ONE) {
            return (_TARGET_BASE_TOKEN_AMOUNT_, _TARGET_QUOTE_TOKEN_AMOUNT_);
        } else if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {
            uint256 payQuoteToken = _RBelowBackToOne();
            return (_TARGET_BASE_TOKEN_AMOUNT_, Q.add(payQuoteToken));
        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {
            uint256 payBaseToken = _RAboveBackToOne();
            return (B.add(payBaseToken), _TARGET_QUOTE_TOKEN_AMOUNT_);
        }
    }

    function getMidPrice() public view returns (uint256 midPrice) {
        (uint256 baseTarget, uint256 quoteTarget) = getExpectedTarget();
        if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {
            uint256 R = DecimalMath.divFloor(
                quoteTarget.mul(quoteTarget).div(_QUOTE_BALANCE_),
                _QUOTE_BALANCE_
            );
            R = DecimalMath.ONE.sub(_K_).add(DecimalMath.mul(_K_, R));
            return DecimalMath.divFloor(getOraclePrice(), R);
        } else {
            uint256 R = DecimalMath.divFloor(
                baseTarget.mul(baseTarget).div(_BASE_BALANCE_),
                _BASE_BALANCE_
            );
            R = DecimalMath.ONE.sub(_K_).add(DecimalMath.mul(_K_, R));
            return DecimalMath.mul(getOraclePrice(), R);
        }
    }

    function _RAboveIntegrate(
        uint256 B0,
        uint256 B1,
        uint256 B2
    ) internal view returns (uint256) {
        uint256 i = getOraclePrice();
        return DODOMath._GeneralIntegrate(B0, B1, B2, i, _K_);
    }

    // function _RBelowIntegrate(
    //     uint256 Q0,
    //     uint256 Q1,
    //     uint256 Q2
    // ) internal view returns (uint256) {
    //     uint256 i = getOraclePrice();
    //     i = DecimalMath.divFloor(DecimalMath.ONE, i); // 1/i
    //     return DODOMath._GeneralIntegrate(Q0, Q1, Q2, i, _K_);
    // }
}

#+end_src
** impl/Trader.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {Types} from "../lib/Types.sol";
import {IDODOCallee} from "../intf/IDODOCallee.sol";
import {Storage} from "./Storage.sol";
import {Pricing} from "./Pricing.sol";
import {Settlement} from "./Settlement.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title Trader
 * @author DODO Breeder
 *
 * @notice Functions for trader operations
 */
contract Trader is Storage, Pricing, Settlement {
    using SafeMath for uint256;

    // ============ Events ============

    event SellBaseToken(address indexed seller, uint256 payBase, uint256 receiveQuote);

    event BuyBaseToken(address indexed buyer, uint256 receiveBase, uint256 payQuote);

    event ChargeMaintainerFee(address indexed maintainer, bool isBaseToken, uint256 amount);

    // ============ Modifiers ============

    modifier tradeAllowed() {
        require(_TRADE_ALLOWED_, "TRADE_NOT_ALLOWED");
        _;
    }

    modifier buyingAllowed() {
        require(_BUYING_ALLOWED_, "BUYING_NOT_ALLOWED");
        _;
    }

    modifier sellingAllowed() {
        require(_SELLING_ALLOWED_, "SELLING_NOT_ALLOWED");
        _;
    }

    modifier gasPriceLimit() {
        require(tx.gasprice <= _GAS_PRICE_LIMIT_, "GAS_PRICE_EXCEED");
        _;
    }

    // ============ Trade Functions ============

    function sellBaseToken(
        uint256 amount,
        uint256 minReceiveQuote,
        bytes calldata data
    ) external tradeAllowed sellingAllowed gasPriceLimit preventReentrant returns (uint256) {
        // query price
        (
            uint256 receiveQuote,
            uint256 lpFeeQuote,
            uint256 mtFeeQuote,
            Types.RStatus newRStatus,
            uint256 newQuoteTarget,
            uint256 newBaseTarget
        ) = _querySellBaseToken(amount);
        require(receiveQuote >= minReceiveQuote, "SELL_BASE_RECEIVE_NOT_ENOUGH");

        // settle assets
        _quoteTokenTransferOut(msg.sender, receiveQuote);
        if (data.length > 0) {
            IDODOCallee(msg.sender).dodoCall(false, amount, receiveQuote, data);
        }
        _baseTokenTransferIn(msg.sender, amount);
        if (mtFeeQuote != 0) {
            _quoteTokenTransferOut(_MAINTAINER_, mtFeeQuote);
            emit ChargeMaintainerFee(_MAINTAINER_, false, mtFeeQuote);
        }

        // update TARGET
        if (_TARGET_QUOTE_TOKEN_AMOUNT_ != newQuoteTarget) {
            _TARGET_QUOTE_TOKEN_AMOUNT_ = newQuoteTarget;
        }
        if (_TARGET_BASE_TOKEN_AMOUNT_ != newBaseTarget) {
            _TARGET_BASE_TOKEN_AMOUNT_ = newBaseTarget;
        }
        if (_R_STATUS_ != newRStatus) {
            _R_STATUS_ = newRStatus;
        }

        _donateQuoteToken(lpFeeQuote);
        emit SellBaseToken(msg.sender, amount, receiveQuote);

        return receiveQuote;
    }

    function buyBaseToken(
        uint256 amount,
        uint256 maxPayQuote,
        bytes calldata data
    ) external tradeAllowed buyingAllowed gasPriceLimit preventReentrant returns (uint256) {
        // query price
        (
            uint256 payQuote,
            uint256 lpFeeBase,
            uint256 mtFeeBase,
            Types.RStatus newRStatus,
            uint256 newQuoteTarget,
            uint256 newBaseTarget
        ) = _queryBuyBaseToken(amount);
        require(payQuote <= maxPayQuote, "BUY_BASE_COST_TOO_MUCH");

        // settle assets
        _baseTokenTransferOut(msg.sender, amount);
        if (data.length > 0) {
            IDODOCallee(msg.sender).dodoCall(true, amount, payQuote, data);
        }
        _quoteTokenTransferIn(msg.sender, payQuote);
        if (mtFeeBase != 0) {
            _baseTokenTransferOut(_MAINTAINER_, mtFeeBase);
            emit ChargeMaintainerFee(_MAINTAINER_, true, mtFeeBase);
        }

        // update TARGET
        if (_TARGET_QUOTE_TOKEN_AMOUNT_ != newQuoteTarget) {
            _TARGET_QUOTE_TOKEN_AMOUNT_ = newQuoteTarget;
        }
        if (_TARGET_BASE_TOKEN_AMOUNT_ != newBaseTarget) {
            _TARGET_BASE_TOKEN_AMOUNT_ = newBaseTarget;
        }
        if (_R_STATUS_ != newRStatus) {
            _R_STATUS_ = newRStatus;
        }

        _donateBaseToken(lpFeeBase);
        emit BuyBaseToken(msg.sender, amount, payQuote);

        return payQuote;
    }

    // ============ Query Functions ============

    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote) {
        (receiveQuote, , , , , ) = _querySellBaseToken(amount);
        return receiveQuote;
    }

    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote) {
        (payQuote, , , , , ) = _queryBuyBaseToken(amount);
        return payQuote;
    }

    function _querySellBaseToken(uint256 amount)
        internal
        view
        returns (
            uint256 receiveQuote,
            uint256 lpFeeQuote,
            uint256 mtFeeQuote,
            Types.RStatus newRStatus,
            uint256 newQuoteTarget,
            uint256 newBaseTarget
        )
    {
        (newBaseTarget, newQuoteTarget) = getExpectedTarget();

        uint256 sellBaseAmount = amount;

        if (_R_STATUS_ == Types.RStatus.ONE) {
            // case 1: R=1
            // R falls below one
            receiveQuote = _ROneSellBaseToken(sellBaseAmount, newQuoteTarget);
            newRStatus = Types.RStatus.BELOW_ONE;
        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {
            uint256 backToOnePayBase = newBaseTarget.sub(_BASE_BALANCE_);
            uint256 backToOneReceiveQuote = _QUOTE_BALANCE_.sub(newQuoteTarget);
            // case 2: R>1
            // complex case, R status depends on trading amount
            if (sellBaseAmount < backToOnePayBase) {
                // case 2.1: R status do not change
                receiveQuote = _RAboveSellBaseToken(sellBaseAmount, _BASE_BALANCE_, newBaseTarget);
                newRStatus = Types.RStatus.ABOVE_ONE;
                if (receiveQuote > backToOneReceiveQuote) {
                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount
                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote
                    receiveQuote = backToOneReceiveQuote;
                }
            } else if (sellBaseAmount == backToOnePayBase) {
                // case 2.2: R status changes to ONE
                receiveQuote = backToOneReceiveQuote;
                newRStatus = Types.RStatus.ONE;
            } else {
                // case 2.3: R status changes to BELOW_ONE
                receiveQuote = backToOneReceiveQuote.add(
                    _ROneSellBaseToken(sellBaseAmount.sub(backToOnePayBase), newQuoteTarget)
                );
                newRStatus = Types.RStatus.BELOW_ONE;
            }
        } else {
            // _R_STATUS_ == Types.RStatus.BELOW_ONE
            // case 3: R<1
            receiveQuote = _RBelowSellBaseToken(sellBaseAmount, _QUOTE_BALANCE_, newQuoteTarget);
            newRStatus = Types.RStatus.BELOW_ONE;
        }

        // count fees
        lpFeeQuote = DecimalMath.mul(receiveQuote, _LP_FEE_RATE_);
        mtFeeQuote = DecimalMath.mul(receiveQuote, _MT_FEE_RATE_);
        receiveQuote = receiveQuote.sub(lpFeeQuote).sub(mtFeeQuote);

        return (receiveQuote, lpFeeQuote, mtFeeQuote, newRStatus, newQuoteTarget, newBaseTarget);
    }

    function _queryBuyBaseToken(uint256 amount)
        internal
        view
        returns (
            uint256 payQuote,
            uint256 lpFeeBase,
            uint256 mtFeeBase,
            Types.RStatus newRStatus,
            uint256 newQuoteTarget,
            uint256 newBaseTarget
        )
    {
        (newBaseTarget, newQuoteTarget) = getExpectedTarget();

        // charge fee from user receive amount
        lpFeeBase = DecimalMath.mul(amount, _LP_FEE_RATE_);
        mtFeeBase = DecimalMath.mul(amount, _MT_FEE_RATE_);
        uint256 buyBaseAmount = amount.add(lpFeeBase).add(mtFeeBase);

        if (_R_STATUS_ == Types.RStatus.ONE) {
            // case 1: R=1
            payQuote = _ROneBuyBaseToken(buyBaseAmount, newBaseTarget);
            newRStatus = Types.RStatus.ABOVE_ONE;
        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {
            // case 2: R>1
            payQuote = _RAboveBuyBaseToken(buyBaseAmount, _BASE_BALANCE_, newBaseTarget);
            newRStatus = Types.RStatus.ABOVE_ONE;
        } else if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {
            uint256 backToOnePayQuote = newQuoteTarget.sub(_QUOTE_BALANCE_);
            uint256 backToOneReceiveBase = _BASE_BALANCE_.sub(newBaseTarget);
            // case 3: R<1
            // complex case, R status may change
            if (buyBaseAmount < backToOneReceiveBase) {
                // case 3.1: R status do not change
                // no need to check payQuote because spare base token must be greater than zero
                payQuote = _RBelowBuyBaseToken(buyBaseAmount, _QUOTE_BALANCE_, newQuoteTarget);
                newRStatus = Types.RStatus.BELOW_ONE;
            } else if (buyBaseAmount == backToOneReceiveBase) {
                // case 3.2: R status changes to ONE
                payQuote = backToOnePayQuote;
                newRStatus = Types.RStatus.ONE;
            } else {
                // case 3.3: R status changes to ABOVE_ONE
                payQuote = backToOnePayQuote.add(
                    _ROneBuyBaseToken(buyBaseAmount.sub(backToOneReceiveBase), newBaseTarget)
                );
                newRStatus = Types.RStatus.ABOVE_ONE;
            }
        }

        return (payQuote, lpFeeBase, mtFeeBase, newRStatus, newQuoteTarget, newBaseTarget);
    }
}

#+end_src
** impl/Settlement.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {Types} from "../lib/Types.sol";
import {IDODOLpToken} from "../intf/IDODOLpToken.sol";
import {IERC20} from "../intf/IERC20.sol";
import {Storage} from "./Storage.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title Settlement
 * @author DODO Breeder
 *
 * @notice Functions for assets settlement
 */
contract Settlement is Storage {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    // ============ Events ============

    event Donate(uint256 amount, bool isBaseToken);

    event ClaimAssets(address indexed user, uint256 baseTokenAmount, uint256 quoteTokenAmount);

    // ============ Assets IN/OUT Functions ============

    function _baseTokenTransferIn(address from, uint256 amount) internal {
        require(_BASE_BALANCE_.add(amount) <= _BASE_BALANCE_LIMIT_, "BASE_BALANCE_LIMIT_EXCEEDED");
        IERC20(_BASE_TOKEN_).safeTransferFrom(from, address(this), amount);
        _BASE_BALANCE_ = _BASE_BALANCE_.add(amount);
    }

    function _quoteTokenTransferIn(address from, uint256 amount) internal {
        require(
            _QUOTE_BALANCE_.add(amount) <= _QUOTE_BALANCE_LIMIT_,
            "QUOTE_BALANCE_LIMIT_EXCEEDED"
        );
        IERC20(_QUOTE_TOKEN_).safeTransferFrom(from, address(this), amount);
        _QUOTE_BALANCE_ = _QUOTE_BALANCE_.add(amount);
    }

    function _baseTokenTransferOut(address to, uint256 amount) internal {
        IERC20(_BASE_TOKEN_).safeTransfer(to, amount);
        _BASE_BALANCE_ = _BASE_BALANCE_.sub(amount);
    }

    function _quoteTokenTransferOut(address to, uint256 amount) internal {
        IERC20(_QUOTE_TOKEN_).safeTransfer(to, amount);
        _QUOTE_BALANCE_ = _QUOTE_BALANCE_.sub(amount);
    }

    // ============ Donate to Liquidity Pool Functions ============

    function _donateBaseToken(uint256 amount) internal {
        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.add(amount);
        emit Donate(amount, true);
    }

    function _donateQuoteToken(uint256 amount) internal {
        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.add(amount);
        emit Donate(amount, false);
    }

    function donateBaseToken(uint256 amount) external preventReentrant {
        _baseTokenTransferIn(msg.sender, amount);
        _donateBaseToken(amount);
    }

    function donateQuoteToken(uint256 amount) external preventReentrant {
        _quoteTokenTransferIn(msg.sender, amount);
        _donateQuoteToken(amount);
    }

    // ============ Final Settlement Functions ============

    // last step to shut down dodo
    function finalSettlement() external onlyOwner notClosed {
        _CLOSED_ = true;
        _DEPOSIT_QUOTE_ALLOWED_ = false;
        _DEPOSIT_BASE_ALLOWED_ = false;
        _TRADE_ALLOWED_ = false;
        uint256 totalBaseCapital = getTotalBaseCapital();
        uint256 totalQuoteCapital = getTotalQuoteCapital();

        if (_QUOTE_BALANCE_ > _TARGET_QUOTE_TOKEN_AMOUNT_) {
            uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);
            _BASE_CAPITAL_RECEIVE_QUOTE_ = DecimalMath.divFloor(spareQuote, totalBaseCapital);
        } else {
            _TARGET_QUOTE_TOKEN_AMOUNT_ = _QUOTE_BALANCE_;
        }

        if (_BASE_BALANCE_ > _TARGET_BASE_TOKEN_AMOUNT_) {
            uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);
            _QUOTE_CAPITAL_RECEIVE_BASE_ = DecimalMath.divFloor(spareBase, totalQuoteCapital);
        } else {
            _TARGET_BASE_TOKEN_AMOUNT_ = _BASE_BALANCE_;
        }

        _R_STATUS_ = Types.RStatus.ONE;
    }

    // claim remaining assets after final settlement
    function claimAssets() external preventReentrant {
        require(_CLOSED_, "DODO_NOT_CLOSED");
        require(!_CLAIMED_[msg.sender], "ALREADY_CLAIMED");
        _CLAIMED_[msg.sender] = true;

        uint256 quoteCapital = getQuoteCapitalBalanceOf(msg.sender);
        uint256 baseCapital = getBaseCapitalBalanceOf(msg.sender);

        uint256 quoteAmount = 0;
        if (quoteCapital > 0) {
            quoteAmount = _TARGET_QUOTE_TOKEN_AMOUNT_.mul(quoteCapital).div(getTotalQuoteCapital());
        }
        uint256 baseAmount = 0;
        if (baseCapital > 0) {
            baseAmount = _TARGET_BASE_TOKEN_AMOUNT_.mul(baseCapital).div(getTotalBaseCapital());
        }

        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(quoteAmount);
        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(baseAmount);

        quoteAmount = quoteAmount.add(DecimalMath.mul(baseCapital, _BASE_CAPITAL_RECEIVE_QUOTE_));
        baseAmount = baseAmount.add(DecimalMath.mul(quoteCapital, _QUOTE_CAPITAL_RECEIVE_BASE_));

        _baseTokenTransferOut(msg.sender, baseAmount);
        _quoteTokenTransferOut(msg.sender, quoteAmount);

        IDODOLpToken(_BASE_CAPITAL_TOKEN_).burn(msg.sender, baseCapital);
        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).burn(msg.sender, quoteCapital);

        emit ClaimAssets(msg.sender, baseAmount, quoteAmount);
        return;
    }

    // in case someone transfer to contract directly
    function retrieve(address token, uint256 amount) external onlyOwner {
        if (token == _BASE_TOKEN_) {
            require(
                IERC20(_BASE_TOKEN_).balanceOf(address(this)) >= _BASE_BALANCE_.add(amount),
                "DODO_BASE_BALANCE_NOT_ENOUGH"
            );
        }
        if (token == _QUOTE_TOKEN_) {
            require(
                IERC20(_QUOTE_TOKEN_).balanceOf(address(this)) >= _QUOTE_BALANCE_.add(amount),
                "DODO_QUOTE_BALANCE_NOT_ENOUGH"
            );
        }
        IERC20(token).safeTransfer(msg.sender, amount);
    }
}

#+end_src
** impl/LiquidityProvider.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {DODOMath} from "../lib/DODOMath.sol";
import {Types} from "../lib/Types.sol";
import {IDODOLpToken} from "../intf/IDODOLpToken.sol";
import {Storage} from "./Storage.sol";
import {Settlement} from "./Settlement.sol";
import {Pricing} from "./Pricing.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title LiquidityProvider
 * @author DODO Breeder
 *
 * @notice Functions for liquidity provider operations
 */
contract LiquidityProvider is Storage, Pricing, Settlement {
    using SafeMath for uint256;

    // ============ Events ============

    event Deposit(
        address indexed payer,
        address indexed receiver,
        bool isBaseToken,
        uint256 amount,
        uint256 lpTokenAmount
    );

    event Withdraw(
        address indexed payer,
        address indexed receiver,
        bool isBaseToken,
        uint256 amount,
        uint256 lpTokenAmount
    );

    event ChargePenalty(address indexed payer, bool isBaseToken, uint256 amount);

    // ============ Modifiers ============

    modifier depositQuoteAllowed() {
        require(_DEPOSIT_QUOTE_ALLOWED_, "DEPOSIT_QUOTE_NOT_ALLOWED");
        _;
    }

    modifier depositBaseAllowed() {
        require(_DEPOSIT_BASE_ALLOWED_, "DEPOSIT_BASE_NOT_ALLOWED");
        _;
    }

    modifier dodoNotClosed() {
        require(!_CLOSED_, "DODO_CLOSED");
        _;
    }

    // ============ Routine Functions ============

    function withdrawBase(uint256 amount) external returns (uint256) {
        return withdrawBaseTo(msg.sender, amount);
    }

    function depositBase(uint256 amount) external returns (uint256) {
        return depositBaseTo(msg.sender, amount);
    }

    function withdrawQuote(uint256 amount) external returns (uint256) {
        return withdrawQuoteTo(msg.sender, amount);
    }

    function depositQuote(uint256 amount) external returns (uint256) {
        return depositQuoteTo(msg.sender, amount);
    }

    function withdrawAllBase() external returns (uint256) {
        return withdrawAllBaseTo(msg.sender);
    }

    function withdrawAllQuote() external returns (uint256) {
        return withdrawAllQuoteTo(msg.sender);
    }

    // ============ Deposit Functions ============

    function depositQuoteTo(address to, uint256 amount)
        public
        preventReentrant
        depositQuoteAllowed
        returns (uint256)
    {
        (, uint256 quoteTarget) = getExpectedTarget();
        uint256 totalQuoteCapital = getTotalQuoteCapital();
        uint256 capital = amount;
        if (totalQuoteCapital == 0) {
            // give remaining quote token to lp as a gift
            capital = amount.add(quoteTarget);
        } else if (quoteTarget > 0) {
            capital = amount.mul(totalQuoteCapital).div(quoteTarget);
        }

        // settlement
        _quoteTokenTransferIn(msg.sender, amount);
        _mintQuoteCapital(to, capital);
        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.add(amount);

        emit Deposit(msg.sender, to, false, amount, capital);
        return capital;
    }

    function depositBaseTo(address to, uint256 amount)
        public
        preventReentrant
        depositBaseAllowed
        returns (uint256)
    {
        (uint256 baseTarget, ) = getExpectedTarget();
        uint256 totalBaseCapital = getTotalBaseCapital();
        uint256 capital = amount;
        if (totalBaseCapital == 0) {
            // give remaining base token to lp as a gift
            capital = amount.add(baseTarget);
        } else if (baseTarget > 0) {
            capital = amount.mul(totalBaseCapital).div(baseTarget);
        }

        // settlement
        _baseTokenTransferIn(msg.sender, amount);
        _mintBaseCapital(to, capital);
        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.add(amount);

        emit Deposit(msg.sender, to, true, amount, capital);
        return capital;
    }

    // ============ Withdraw Functions ============

    function withdrawQuoteTo(address to, uint256 amount)
        public
        preventReentrant
        dodoNotClosed
        returns (uint256)
    {
        // calculate capital
        (, uint256 quoteTarget) = getExpectedTarget();
        uint256 totalQuoteCapital = getTotalQuoteCapital();
        require(totalQuoteCapital > 0, "NO_QUOTE_LP");

        uint256 requireQuoteCapital = amount.mul(totalQuoteCapital).divCeil(quoteTarget);
        require(
            requireQuoteCapital <= getQuoteCapitalBalanceOf(msg.sender),
            "LP_QUOTE_CAPITAL_BALANCE_NOT_ENOUGH"
        );

        // handle penalty, penalty may exceed amount
        uint256 penalty = getWithdrawQuotePenalty(amount);
        require(penalty < amount, "PENALTY_EXCEED");

        // settlement
        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(amount);
        _burnQuoteCapital(msg.sender, requireQuoteCapital);
        _quoteTokenTransferOut(to, amount.sub(penalty));
        _donateQuoteToken(penalty);

        emit Withdraw(msg.sender, to, false, amount.sub(penalty), requireQuoteCapital);
        emit ChargePenalty(msg.sender, false, penalty);

        return amount.sub(penalty);
    }

    function withdrawBaseTo(address to, uint256 amount)
        public
        preventReentrant
        dodoNotClosed
        returns (uint256)
    {
        // calculate capital
        (uint256 baseTarget, ) = getExpectedTarget();
        uint256 totalBaseCapital = getTotalBaseCapital();
        require(totalBaseCapital > 0, "NO_BASE_LP");

        uint256 requireBaseCapital = amount.mul(totalBaseCapital).divCeil(baseTarget);
        require(
            requireBaseCapital <= getBaseCapitalBalanceOf(msg.sender),
            "LP_BASE_CAPITAL_BALANCE_NOT_ENOUGH"
        );

        // handle penalty, penalty may exceed amount
        uint256 penalty = getWithdrawBasePenalty(amount);
        require(penalty <= amount, "PENALTY_EXCEED");

        // settlement
        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(amount);
        _burnBaseCapital(msg.sender, requireBaseCapital);
        _baseTokenTransferOut(to, amount.sub(penalty));
        _donateBaseToken(penalty);

        emit Withdraw(msg.sender, to, true, amount.sub(penalty), requireBaseCapital);
        emit ChargePenalty(msg.sender, true, penalty);

        return amount.sub(penalty);
    }

    // ============ Withdraw all Functions ============

    function withdrawAllQuoteTo(address to)
        public
        preventReentrant
        dodoNotClosed
        returns (uint256)
    {
        uint256 withdrawAmount = getLpQuoteBalance(msg.sender);
        uint256 capital = getQuoteCapitalBalanceOf(msg.sender);

        // handle penalty, penalty may exceed amount
        uint256 penalty = getWithdrawQuotePenalty(withdrawAmount);
        require(penalty <= withdrawAmount, "PENALTY_EXCEED");

        // settlement
        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(withdrawAmount);
        _burnQuoteCapital(msg.sender, capital);
        _quoteTokenTransferOut(to, withdrawAmount.sub(penalty));
        _donateQuoteToken(penalty);

        emit Withdraw(msg.sender, to, false, withdrawAmount, capital);
        emit ChargePenalty(msg.sender, false, penalty);

        return withdrawAmount.sub(penalty);
    }

    function withdrawAllBaseTo(address to) public preventReentrant dodoNotClosed returns (uint256) {
        uint256 withdrawAmount = getLpBaseBalance(msg.sender);
        uint256 capital = getBaseCapitalBalanceOf(msg.sender);

        // handle penalty, penalty may exceed amount
        uint256 penalty = getWithdrawBasePenalty(withdrawAmount);
        require(penalty <= withdrawAmount, "PENALTY_EXCEED");

        // settlement
        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(withdrawAmount);
        _burnBaseCapital(msg.sender, capital);
        _baseTokenTransferOut(to, withdrawAmount.sub(penalty));
        _donateBaseToken(penalty);

        emit Withdraw(msg.sender, to, true, withdrawAmount, capital);
        emit ChargePenalty(msg.sender, true, penalty);

        return withdrawAmount.sub(penalty);
    }

    // ============ Helper Functions ============

    function _mintBaseCapital(address user, uint256 amount) internal {
        IDODOLpToken(_BASE_CAPITAL_TOKEN_).mint(user, amount);
    }

    function _mintQuoteCapital(address user, uint256 amount) internal {
        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).mint(user, amount);
    }

    function _burnBaseCapital(address user, uint256 amount) internal {
        IDODOLpToken(_BASE_CAPITAL_TOKEN_).burn(user, amount);
    }

    function _burnQuoteCapital(address user, uint256 amount) internal {
        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).burn(user, amount);
    }

    // ============ Getter Functions ============

    function getLpBaseBalance(address lp) public view returns (uint256 lpBalance) {
        uint256 totalBaseCapital = getTotalBaseCapital();
        (uint256 baseTarget, ) = getExpectedTarget();
        if (totalBaseCapital == 0) {
            return 0;
        }
        lpBalance = getBaseCapitalBalanceOf(lp).mul(baseTarget).div(totalBaseCapital);
        return lpBalance;
    }

    function getLpQuoteBalance(address lp) public view returns (uint256 lpBalance) {
        uint256 totalQuoteCapital = getTotalQuoteCapital();
        (, uint256 quoteTarget) = getExpectedTarget();
        if (totalQuoteCapital == 0) {
            return 0;
        }
        lpBalance = getQuoteCapitalBalanceOf(lp).mul(quoteTarget).div(totalQuoteCapital);
        return lpBalance;
    }

    function getWithdrawQuotePenalty(uint256 amount) public view returns (uint256 penalty) {
        require(amount <= _QUOTE_BALANCE_, "DODO_QUOTE_BALANCE_NOT_ENOUGH");
        if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {
            uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);
            uint256 price = getOraclePrice();
            uint256 fairAmount = DecimalMath.mul(spareBase, price);
            uint256 targetQuote = DODOMath._SolveQuadraticFunctionForTarget(
                _QUOTE_BALANCE_,
                _K_,
                fairAmount
            );
            // if amount = _QUOTE_BALANCE_, div error
            uint256 targetQuoteWithWithdraw = DODOMath._SolveQuadraticFunctionForTarget(
                _QUOTE_BALANCE_.sub(amount),
                _K_,
                fairAmount
            );
            return targetQuote.sub(targetQuoteWithWithdraw.add(amount));
        } else {
            return 0;
        }
    }

    function getWithdrawBasePenalty(uint256 amount) public view returns (uint256 penalty) {
        require(amount <= _BASE_BALANCE_, "DODO_BASE_BALANCE_NOT_ENOUGH");
        if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {
            uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);
            uint256 price = getOraclePrice();
            uint256 fairAmount = DecimalMath.divFloor(spareQuote, price);
            uint256 targetBase = DODOMath._SolveQuadraticFunctionForTarget(
                _BASE_BALANCE_,
                _K_,
                fairAmount
            );
            // if amount = _BASE_BALANCE_, div error
            uint256 targetBaseWithWithdraw = DODOMath._SolveQuadraticFunctionForTarget(
                _BASE_BALANCE_.sub(amount),
                _K_,
                fairAmount
            );
            return targetBase.sub(targetBaseWithWithdraw.add(amount));
        } else {
            return 0;
        }
    }
}

#+end_src
** impl/Storage.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {InitializableOwnable} from "../lib/InitializableOwnable.sol";
import {SafeMath} from "../lib/SafeMath.sol";
import {DecimalMath} from "../lib/DecimalMath.sol";
import {ReentrancyGuard} from "../lib/ReentrancyGuard.sol";
import {IOracle} from "../intf/IOracle.sol";
import {IDODOLpToken} from "../intf/IDODOLpToken.sol";
import {Types} from "../lib/Types.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title Storage
 * @author DODO Breeder
 *
 * @notice Local Variables
 */
contract Storage is InitializableOwnable, ReentrancyGuard {
    using SafeMath for uint256;

    // ============ Variables for Control ============

    bool internal _INITIALIZED_;
    bool public _CLOSED_;
    bool public _DEPOSIT_QUOTE_ALLOWED_;
    bool public _DEPOSIT_BASE_ALLOWED_;
    bool public _TRADE_ALLOWED_;
    uint256 public _GAS_PRICE_LIMIT_;

    // ============ Advanced Controls ============
    bool public _BUYING_ALLOWED_;
    bool public _SELLING_ALLOWED_;
    uint256 public _BASE_BALANCE_LIMIT_;
    uint256 public _QUOTE_BALANCE_LIMIT_;

    // ============ Core Address ============

    address public _SUPERVISOR_; // could freeze system in emergency
    address public _MAINTAINER_; // collect maintainer fee to buy food for DODO

    address public _BASE_TOKEN_;
    address public _QUOTE_TOKEN_;
    address public _ORACLE_;

    // ============ Variables for PMM Algorithm ============

    uint256 public _LP_FEE_RATE_;
    uint256 public _MT_FEE_RATE_;
    uint256 public _K_;

    Types.RStatus public _R_STATUS_;
    uint256 public _TARGET_BASE_TOKEN_AMOUNT_;
    uint256 public _TARGET_QUOTE_TOKEN_AMOUNT_;
    uint256 public _BASE_BALANCE_;
    uint256 public _QUOTE_BALANCE_;

    address public _BASE_CAPITAL_TOKEN_;
    address public _QUOTE_CAPITAL_TOKEN_;

    // ============ Variables for Final Settlement ============

    uint256 public _BASE_CAPITAL_RECEIVE_QUOTE_;
    uint256 public _QUOTE_CAPITAL_RECEIVE_BASE_;
    mapping(address => bool) public _CLAIMED_;

    // ============ Modifiers ============

    modifier onlySupervisorOrOwner() {
        require(msg.sender == _SUPERVISOR_ || msg.sender == _OWNER_, "NOT_SUPERVISOR_OR_OWNER");
        _;
    }

    modifier notClosed() {
        require(!_CLOSED_, "DODO_CLOSED");
        _;
    }

    // ============ Helper Functions ============

    function _checkDODOParameters() internal view returns (uint256) {
        require(_K_ < DecimalMath.ONE, "K>=1");
        require(_K_ > 0, "K=0");
        require(_LP_FEE_RATE_.add(_MT_FEE_RATE_) < DecimalMath.ONE, "FEE_RATE>=1");
    }

    function getOraclePrice() public view returns (uint256) {
        return IOracle(_ORACLE_).getPrice();
    }

    function getBaseCapitalBalanceOf(address lp) public view returns (uint256) {
        return IDODOLpToken(_BASE_CAPITAL_TOKEN_).balanceOf(lp);
    }

    function getTotalBaseCapital() public view returns (uint256) {
        return IDODOLpToken(_BASE_CAPITAL_TOKEN_).totalSupply();
    }

    function getQuoteCapitalBalanceOf(address lp) public view returns (uint256) {
        return IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).balanceOf(lp);
    }

    function getTotalQuoteCapital() public view returns (uint256) {
        return IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).totalSupply();
    }

    // ============ Version Control ============
    function version() external pure returns (uint256) {
        return 101; // 1.0.1
    }
}

#+end_src
** intf/IERC20.sol
*** head
#+begin_src solidity
// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol
// SPDX-License-Identifier: MIT

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    function decimals() external view returns (uint8);

    function name() external view returns (string memory);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `recipient`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address recipient, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `sender` to `recipient` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) external returns (bool);
}

#+end_src
** intf/IDODOCallee.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

interface IDODOCallee {
    function dodoCall(
        bool isBuyBaseToken,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata data
    ) external;
}

#+end_src
** intf/IWETH.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IWETH {
    function totalSupply() external view returns (uint256);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address recipient, uint256 amount) external returns (bool);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 amount) external returns (bool);

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) external returns (bool);

    function deposit() external payable;

    function withdraw(uint256 wad) external;
}

#+end_src
** intf/IOracle.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IOracle {
    function getPrice() external view returns (uint256);
}

#+end_src
** intf/IDODOLpToken.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity ^0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IDODOLpToken {
    function mint(address user, uint256 value) external;

    function burn(address user, uint256 value) external;

    function balanceOf(address owner) external view returns (uint256);

    function totalSupply() external view returns (uint256);
}

#+end_src
** intf/IDODO.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IDODO {
    function init(
        address owner,
        address supervisor,
        address maintainer,
        address baseToken,
        address quoteToken,
        address oracle,
        uint256 lpFeeRate,
        uint256 mtFeeRate,
        uint256 k,
        uint256 gasPriceLimit
    ) external;

    function transferOwnership(address newOwner) external;

    function claimOwnership() external;

    function sellBaseToken(
        uint256 amount,
        uint256 minReceiveQuote,
        bytes calldata data
    ) external returns (uint256);

    function buyBaseToken(
        uint256 amount,
        uint256 maxPayQuote,
        bytes calldata data
    ) external returns (uint256);

    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote);

    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote);

    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);

    function depositBaseTo(address to, uint256 amount) external returns (uint256);

    function withdrawBase(uint256 amount) external returns (uint256);

    function withdrawAllBase() external returns (uint256);

    function depositQuoteTo(address to, uint256 amount) external returns (uint256);

    function withdrawQuote(uint256 amount) external returns (uint256);

    function withdrawAllQuote() external returns (uint256);

    function _BASE_CAPITAL_TOKEN_() external view returns (address);

    function _QUOTE_CAPITAL_TOKEN_() external view returns (address);

    function _BASE_TOKEN_() external returns (address);

    function _QUOTE_TOKEN_() external returns (address);
}

#+end_src
** lib/ReentrancyGuard.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity
/**
 * @title ReentrancyGuard
 * @author DODO Breeder
 *
 * @notice Protect functions from Reentrancy Attack
 */
contract ReentrancyGuard {
    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations
    // zero-state of _ENTERED_ is false
    bool private _ENTERED_;

    modifier preventReentrant() {
        require(!_ENTERED_, "REENTRANT");
        _ENTERED_ = true;
        _;
        _ENTERED_ = false;
    }
}

#+end_src
** lib/Ownable.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

/**
 * @title Ownable
 * @author DODO Breeder
 *
 * @notice Ownership related functions
 */
contract Ownable {
    address public _OWNER_;
    address public _NEW_OWNER_;

    // ============ Events ============

    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    // ============ Modifiers ============

    modifier onlyOwner() {
        require(msg.sender == _OWNER_, "NOT_OWNER");
        _;
    }

    // ============ Functions ============

    constructor() internal {
        _OWNER_ = msg.sender;
        emit OwnershipTransferred(address(0), _OWNER_);
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferPrepared(_OWNER_, newOwner);
        _NEW_OWNER_ = newOwner;
    }

    function claimOwnership() external {
        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");
        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);
        _OWNER_ = _NEW_OWNER_;
        _NEW_OWNER_ = address(0);
    }
}

#+end_src
** lib/SafeERC20.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0
    This is a simplified version of OpenZepplin's SafeERC20 library

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {IERC20} from "../intf/IERC20.sol";
import {SafeMath} from "./SafeMath.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using SafeMath for uint256;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(
            token,
            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)
        );
    }

    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        // solhint-disable-next-line max-line-length
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves.

        // A Solidity high level call has three parts:
        //  1. The target address is checked to verify it contains contract code
        //  2. The call itself is made, and success asserted
        //  3. The return value is decoded, which in turn checks the size of the returned data.
        // solhint-disable-next-line max-line-length

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) {
            // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

#+end_src
** lib/SafeMath.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

/**
 * @title SafeMath
 * @author DODO Breeder
 *
 * @notice Math operations with safety checks that revert on error
 */
library SafeMath {
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "MUL_ERROR");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0, "DIVIDING_ERROR");
        return a / b;
    }

    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 quotient = div(a, b);
        uint256 remainder = a - quotient * b;
        if (remainder > 0) {
            return quotient + 1;
        } else {
            return quotient;
        }
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SUB_ERROR");
        return a - b;
    }

    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "ADD_ERROR");
        return c;
    }

    function sqrt(uint256 x) internal pure returns (uint256 y) {
        uint256 z = x / 2 + 1;
        y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
    }
}
#+end_src
** lib/InitializableOwnable.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

/**
 * @title Ownable
 * @author DODO Breeder
 *
 * @notice Ownership related functions
 */
contract InitializableOwnable {
    address public _OWNER_;
    address public _NEW_OWNER_;

    // ============ Events ============

    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    // ============ Modifiers ============

    modifier onlyOwner() {
        require(msg.sender == _OWNER_, "NOT_OWNER");
        _;
    }

    // ============ Functions ============

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransferPrepared(_OWNER_, newOwner);
        _NEW_OWNER_ = newOwner;
    }

    function claimOwnership() external {
        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");
        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);
        _OWNER_ = _NEW_OWNER_;
        _NEW_OWNER_ = address(0);
    }
}

#+end_src
** lib/DecimalMath.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "./SafeMath.sol";


#+end_src
*** function
#+begin_src solidity

/**
 * @title DecimalMath
 * @author DODO Breeder
 *
 * @notice Functions for fixed point number with 18 decimals
 */
library DecimalMath {
    using SafeMath for uint256;

    uint256 constant ONE = 10**18;

    function mul(uint256 target, uint256 d) internal pure returns (uint256) {
        return target.mul(d) / ONE;
    }

    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {
        return target.mul(d).divCeil(ONE);
    }

    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {
        return target.mul(ONE).div(d);
    }

    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {
        return target.mul(ONE).divCeil(d);
    }
}

#+end_src
** lib/Types.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

library Types {
    enum RStatus {ONE, ABOVE_ONE, BELOW_ONE}
}

#+end_src
** lib/DODOMath.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "./SafeMath.sol";
import {DecimalMath} from "./DecimalMath.sol";

#+end_src
*** function
#+begin_src solidity

/**
 * @title DODOMath
 * @author DODO Breeder
 *
 * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions
 */
library DODOMath {
    using SafeMath for uint256;

    /*
        Integrate dodo curve fron V1 to V2
        require V0>=V1>=V2>0
        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)
        let V1-V2=delta
        res = i*delta*(1-k+k(V0^2/V1/V2))
    */
    function _GeneralIntegrate(
        uint256 V0,
        uint256 V1,
        uint256 V2,
        uint256 i,
        uint256 k
    ) internal pure returns (uint256) {
        uint256 fairAmount = DecimalMath.mul(i, V1.sub(V2)); // i*delta
        uint256 V0V0V1V2 = DecimalMath.divCeil(V0.mul(V0).div(V1), V2);
        uint256 penalty = DecimalMath.mul(k, V0V0V1V2); // k(V0^2/V1/V2)
        return DecimalMath.mul(fairAmount, DecimalMath.ONE.sub(k).add(penalty));
    }

    /*
        The same with integration expression above, we have:
        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)
        Given Q1 and deltaB, solve Q2
        This is a quadratic function and the standard version is
        aQ2^2 + bQ2 + c = 0, where
        a=1-k
        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB
        c=-kQ0^2
        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)
        note: another root is negative, abondan
        if deltaBSig=true, then Q2>Q1
        if deltaBSig=false, then Q2<Q1
    */
    function _SolveQuadraticFunctionForTrade(
        uint256 Q0,
        uint256 Q1,
        uint256 ideltaB,
        bool deltaBSig,
        uint256 k
    ) internal pure returns (uint256) {
        // calculate -b value and sig
        // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB
        uint256 kQ02Q1 = DecimalMath.mul(k, Q0).mul(Q0).div(Q1); // kQ0^2/Q1
        uint256 b = DecimalMath.mul(DecimalMath.ONE.sub(k), Q1); // (1-k)Q1
        bool minusbSig = true;
        if (deltaBSig) {
            b = b.add(ideltaB); // (1-k)Q1+i*deltaB
        } else {
            kQ02Q1 = kQ02Q1.add(ideltaB); // i*deltaB+kQ0^2/Q1
        }
        if (b >= kQ02Q1) {
            b = b.sub(kQ02Q1);
            minusbSig = true;
        } else {
            b = kQ02Q1.sub(b);
            minusbSig = false;
        }

        // calculate sqrt
        uint256 squareRoot = DecimalMath.mul(
            DecimalMath.ONE.sub(k).mul(4),
            DecimalMath.mul(k, Q0).mul(Q0)
        ); // 4(1-k)kQ0^2
        squareRoot = b.mul(b).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)

        // final res
        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)
        uint256 numerator;
        if (minusbSig) {
            numerator = b.add(squareRoot);
        } else {
            numerator = squareRoot.sub(b);
        }

        if (deltaBSig) {
            return DecimalMath.divFloor(numerator, denominator);
        } else {
            return DecimalMath.divCeil(numerator, denominator);
        }
    }

    /*
        Start from the integration function
        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)
        Assume Q2=Q0, Given Q1 and deltaB, solve Q0
        let fairAmount = i*deltaB
    */
    function _SolveQuadraticFunctionForTarget(
        uint256 V1,
        uint256 k,
        uint256 fairAmount
    ) internal pure returns (uint256 V0) {
        // V0 = V1+V1*(sqrt-1)/2k
        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mul(k, fairAmount).mul(4), V1);
        sqrt = sqrt.add(DecimalMath.ONE).mul(DecimalMath.ONE).sqrt();
        uint256 premium = DecimalMath.divCeil(sqrt.sub(DecimalMath.ONE), k.mul(2));
        // V0 is greater than or equal to V1 according to the solution
        return DecimalMath.mul(V1, DecimalMath.ONE.add(premium));
    }
}

#+end_src
** helper/UniswapArbitrageur.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Ownable} from "../lib/Ownable.sol";
import {IDODO} from "../intf/IDODO.sol";
import {IERC20} from "../intf/IERC20.sol";
import {SafeERC20} from "../lib/SafeERC20.sol";
import {SafeMath} from "../lib/SafeMath.sol";


#+end_src
*** function
#+begin_src solidity
interface IUniswapV2Pair {
    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;
}

contract UniswapArbitrageur {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    address public _UNISWAP_;
    address public _DODO_;
    address public _BASE_;
    address public _QUOTE_;

    bool public _REVERSE_; // true if dodo.baseToken=uniswap.token0

    constructor(address _uniswap, address _dodo) public {
        _UNISWAP_ = _uniswap;
        _DODO_ = _dodo;

        _BASE_ = IDODO(_DODO_)._BASE_TOKEN_();
        _QUOTE_ = IDODO(_DODO_)._QUOTE_TOKEN_();

        address token0 = IUniswapV2Pair(_UNISWAP_).token0();
        address token1 = IUniswapV2Pair(_UNISWAP_).token1();

        if (token0 == _BASE_ && token1 == _QUOTE_) {
            _REVERSE_ = false;
        } else if (token0 == _QUOTE_ && token1 == _BASE_) {
            _REVERSE_ = true;
        } else {
            require(true, "DODO_UNISWAP_NOT_MATCH");
        }

        IERC20(_BASE_).approve(_DODO_, uint256(-1));
        IERC20(_QUOTE_).approve(_DODO_, uint256(-1));
    }

    function executeBuyArbitrage(uint256 baseAmount) external returns (uint256 quoteProfit) {
        IDODO(_DODO_).buyBaseToken(baseAmount, uint256(-1), "0xd");
        quoteProfit = IERC20(_QUOTE_).balanceOf(address(this));
        IERC20(_QUOTE_).transfer(msg.sender, quoteProfit);
        return quoteProfit;
    }

    function executeSellArbitrage(uint256 baseAmount) external returns (uint256 baseProfit) {
        IDODO(_DODO_).sellBaseToken(baseAmount, 0, "0xd");
        baseProfit = IERC20(_BASE_).balanceOf(address(this));
        IERC20(_BASE_).transfer(msg.sender, baseProfit);
        return baseProfit;
    }

    function dodoCall(
        bool isDODOBuy,
        uint256 baseAmount,
        uint256 quoteAmount,
        bytes calldata
    ) external {
        require(msg.sender == _DODO_, "WRONG_DODO");
        if (_REVERSE_) {
            _inverseArbitrage(isDODOBuy, baseAmount, quoteAmount);
        } else {
            _arbitrage(isDODOBuy, baseAmount, quoteAmount);
        }
    }

    function _inverseArbitrage(
        bool isDODOBuy,
        uint256 baseAmount,
        uint256 quoteAmount
    ) internal {
        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(_UNISWAP_).getReserves();
        uint256 token0Balance = uint256(_reserve0);
        uint256 token1Balance = uint256(_reserve1);
        uint256 token0Amount;
        uint256 token1Amount;
        if (isDODOBuy) {
            IERC20(_BASE_).transfer(_UNISWAP_, baseAmount);
            // transfer token1 into uniswap
            uint256 newToken0Balance = token0Balance.mul(token1Balance).div(
                token1Balance.add(baseAmount)
            );
            token0Amount = token0Balance.sub(newToken0Balance).mul(9969).div(10000); // mul 0.9969
            require(token0Amount > quoteAmount, "NOT_PROFITABLE");
            IUniswapV2Pair(_UNISWAP_).swap(token0Amount, token1Amount, address(this), "");
        } else {
            IERC20(_QUOTE_).transfer(_UNISWAP_, quoteAmount);
            // transfer token0 into uniswap
            uint256 newToken1Balance = token0Balance.mul(token1Balance).div(
                token0Balance.add(quoteAmount)
            );
            token1Amount = token1Balance.sub(newToken1Balance).mul(9969).div(10000); // mul 0.9969
            require(token1Amount > baseAmount, "NOT_PROFITABLE");
            IUniswapV2Pair(_UNISWAP_).swap(token0Amount, token1Amount, address(this), "");
        }
    }

    function _arbitrage(
        bool isDODOBuy,
        uint256 baseAmount,
        uint256 quoteAmount
    ) internal {
        (uint112 _reserve0, uint112 _reserve1, ) = IUniswapV2Pair(_UNISWAP_).getReserves();
        uint256 token0Balance = uint256(_reserve0);
        uint256 token1Balance = uint256(_reserve1);
        uint256 token0Amount;
        uint256 token1Amount;
        if (isDODOBuy) {
            IERC20(_BASE_).transfer(_UNISWAP_, baseAmount);
            // transfer token0 into uniswap
            uint256 newToken1Balance = token1Balance.mul(token0Balance).div(
                token0Balance.add(baseAmount)
            );
            token1Amount = token1Balance.sub(newToken1Balance).mul(9969).div(10000); // mul 0.9969
            require(token1Amount > quoteAmount, "NOT_PROFITABLE");
            IUniswapV2Pair(_UNISWAP_).swap(token0Amount, token1Amount, address(this), "");
        } else {
            IERC20(_QUOTE_).transfer(_UNISWAP_, quoteAmount);
            // transfer token1 into uniswap
            uint256 newToken0Balance = token1Balance.mul(token0Balance).div(
                token1Balance.add(quoteAmount)
            );
            token0Amount = token0Balance.sub(newToken0Balance).mul(9969).div(10000); // mul 0.9969
            require(token0Amount > baseAmount, "NOT_PROFITABLE");
            IUniswapV2Pair(_UNISWAP_).swap(token0Amount, token1Amount, address(this), "");
        }
    }

    function retrieve(address token, uint256 amount) external {
        IERC20(token).safeTransfer(msg.sender, amount);
    }
}

#+end_src
** helper/ChainlinkEthUSDTPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for WETH-USDT(decimals=6) price convert

contract ChainlinkETHUSDTPriceOracleProxy {
    address public chainlink = 0xEe9F2375b4bdF6387aa8265dD4FB8F16512A1d46;

    function getPrice() external view returns (uint256) {
        return 10**24 / IChainlink(chainlink).latestAnswer();
    }
}

#+end_src
** helper/ChainlinkEthUSDCPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for WETH-USDC(decimals=6) price convert

contract ChainlinkETHPriceOracleProxy {
    address public chainlink = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() / 100;
    }
}

#+end_src
** helper/NaiveOracle.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {Ownable} from "../lib/Ownable.sol";


#+end_src
*** function
#+begin_src solidity

// Oracle only for test
contract NaiveOracle is Ownable {
    uint256 public tokenPrice;

    function setPrice(uint256 newPrice) external onlyOwner {
        tokenPrice = newPrice;
    }

    function getPrice() external view returns (uint256) {
        return tokenPrice;
    }
}

#+end_src
** helper/ChainlinkLINKUSDPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for LINK-USDC(decimals=6) price convert

contract ChainlinkLINKUSDCPriceOracleProxy {
    address public chainlink = 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() / 100;
    }
}

#+end_src
** helper/ChainlinkYFIUSDCPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

import {SafeMath} from "../lib/SafeMath.sol";


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for YFI-USDC(decimals=6) price convert

contract ChainlinkYFIUSDCPriceOracleProxy {
    using SafeMath for uint256;

    address public yfiEth = 0x7c5d4F8345e66f68099581Db340cd65B078C41f4;
    address public EthUsd = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;

    function getPrice() external view returns (uint256) {
        uint256 yfiEthPrice = IChainlink(yfiEth).latestAnswer();
        uint256 EthUsdPrice = IChainlink(EthUsd).latestAnswer();
        return yfiEthPrice.mul(EthUsdPrice).div(10**20);
    }
}

#+end_src
** helper/MultiSig.sol
*** head
#+begin_src solidity
/**
 *Submitted for verification at Bscscan.com on 2020-09-25
 */

/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

contract MultiSigWalletWithTimelock {
    uint256 public constant MAX_OWNER_COUNT = 50;
    uint256 public lockSeconds = 86400;

    event Confirmation(address indexed sender, uint256 indexed transactionId);
    event Revocation(address indexed sender, uint256 indexed transactionId);
    event Submission(uint256 indexed transactionId);
    event Execution(uint256 indexed transactionId);
    event ExecutionFailure(uint256 indexed transactionId);
    event Deposit(address indexed sender, uint256 value);
    event OwnerAddition(address indexed owner);
    event OwnerRemoval(address indexed owner);
    event RequirementChange(uint256 required);
    event UnlockTimeSet(uint256 indexed transactionId, uint256 confirmationTime);
    event LockSecondsChange(uint256 lockSeconds);

    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    mapping(address => bool) public isOwner;
    mapping(uint256 => uint256) public unlockTimes;

    address[] public owners;
    uint256 public required;
    uint256 public transactionCount;

    struct Transaction {
        address destination;
        uint256 value;
        bytes data;
        bool executed;
    }

    struct EmergencyCall {
        bytes32 selector;
        uint256 paramsBytesCount;
    }

    // Functions bypass the time lock process
    EmergencyCall[] public emergencyCalls;

    modifier onlyWallet() {
        if (msg.sender != address(this)) revert("ONLY_WALLET_ERROR");
        _;
    }

    modifier ownerDoesNotExist(address owner) {
        if (isOwner[owner]) revert("OWNER_DOES_NOT_EXIST_ERROR");
        _;
    }

    modifier ownerExists(address owner) {
        if (!isOwner[owner]) revert("OWNER_EXISTS_ERROR");
        _;
    }

    modifier transactionExists(uint256 transactionId) {
        if (transactions[transactionId].destination == address(0))
            revert("TRANSACTION_EXISTS_ERROR");
        _;
    }

    modifier confirmed(uint256 transactionId, address owner) {
        if (!confirmations[transactionId][owner]) revert("CONFIRMED_ERROR");
        _;
    }

    modifier notConfirmed(uint256 transactionId, address owner) {
        if (confirmations[transactionId][owner]) revert("NOT_CONFIRMED_ERROR");
        _;
    }

    modifier notExecuted(uint256 transactionId) {
        if (transactions[transactionId].executed) revert("NOT_EXECUTED_ERROR");
        _;
    }

    modifier notNull(address _address) {
        if (_address == address(0)) revert("NOT_NULL_ERROR");
        _;
    }

    modifier validRequirement(uint256 ownerCount, uint256 _required) {
        if (
            ownerCount > MAX_OWNER_COUNT ||
            _required > ownerCount ||
            _required == 0 ||
            ownerCount == 0
        ) revert("VALID_REQUIREMENT_ERROR");
        _;
    }

    /** @dev Fallback function allows to deposit ether. */
    fallback() external payable {
        if (msg.value > 0) {
            emit Deposit(msg.sender, msg.value);
        }
    }

    receive() external payable {
        if (msg.value > 0) {
            emit Deposit(msg.sender, msg.value);
        }
    }

    /** @dev Contract constructor sets initial owners and required number of confirmations.
     * @param _owners List of initial owners.
     * @param _required Number of required confirmations.
     */
    constructor(address[] memory _owners, uint256 _required)
        public
        validRequirement(_owners.length, _required)
    {
        for (uint256 i = 0; i < _owners.length; i++) {
            if (isOwner[_owners[i]] || _owners[i] == address(0)) {
                revert("OWNER_ERROR");
            }

            isOwner[_owners[i]] = true;
        }

        owners = _owners;
        required = _required;

        // initialzie Emergency calls
        emergencyCalls.push(
            EmergencyCall({
                selector: keccak256(abi.encodePacked("claimOwnership()")),
                paramsBytesCount: 0
            })
        );
        emergencyCalls.push(
            EmergencyCall({
                selector: keccak256(abi.encodePacked("setK(uint256)")),
                paramsBytesCount: 64
            })
        );
        emergencyCalls.push(
            EmergencyCall({
                selector: keccak256(abi.encodePacked("setLiquidityProviderFeeRate(uint256)")),
                paramsBytesCount: 64
            })
        );
    }

    function getEmergencyCallsCount() external view returns (uint256 count) {
        return emergencyCalls.length;
    }

    /** @dev Allows to add a new owner. Transaction has to be sent by wallet.
     * @param owner Address of new owner.
     */
    function addOwner(address owner)
        external
        onlyWallet
        ownerDoesNotExist(owner)
        notNull(owner)
        validRequirement(owners.length + 1, required)
    {
        isOwner[owner] = true;
        owners.push(owner);
        emit OwnerAddition(owner);
    }

    /** @dev Allows to remove an owner. Transaction has to be sent by wallet.
     * @param owner Address of owner.
     */
    function removeOwner(address owner) external onlyWallet ownerExists(owner) {
        isOwner[owner] = false;
        for (uint256 i = 0; i < owners.length - 1; i++) {
            if (owners[i] == owner) {
                owners[i] = owners[owners.length - 1];
                break;
            }
        }

        owners.pop;

        if (required > owners.length) {
            changeRequirement(owners.length);
        }

        emit OwnerRemoval(owner);
    }

    /** @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.
     * @param owner Address of owner to be replaced.
     * @param owner Address of new owner.
     */
    function replaceOwner(address owner, address newOwner)
        external
        onlyWallet
        ownerExists(owner)
        ownerDoesNotExist(newOwner)
    {
        for (uint256 i = 0; i < owners.length; i++) {
            if (owners[i] == owner) {
                owners[i] = newOwner;
                break;
            }
        }

        isOwner[owner] = false;
        isOwner[newOwner] = true;
        emit OwnerRemoval(owner);
        emit OwnerAddition(newOwner);
    }

    /** @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.
     * @param _required Number of required confirmations.
     */
    function changeRequirement(uint256 _required)
        public
        onlyWallet
        validRequirement(owners.length, _required)
    {
        required = _required;
        emit RequirementChange(_required);
    }

    /** @dev Changes the duration of the time lock for transactions.
     * @param _lockSeconds Duration needed after a transaction is confirmed and before it becomes executable, in seconds.
     */
    function changeLockSeconds(uint256 _lockSeconds) external onlyWallet {
        lockSeconds = _lockSeconds;
        emit LockSecondsChange(_lockSeconds);
    }

    /** @dev Allows an owner to submit and confirm a transaction.
     * @param destination Transaction target address.
     * @param value Transaction ether value.
     * @param data Transaction data payload.
     * @return transactionId Returns transaction ID.
     */
    function submitTransaction(
        address destination,
        uint256 value,
        bytes calldata data
    ) external ownerExists(msg.sender) notNull(destination) returns (uint256 transactionId) {
        transactionId = transactionCount;
        transactions[transactionId] = Transaction({
            destination: destination,
            value: value,
            data: data,
            executed: false
        });
        transactionCount += 1;
        emit Submission(transactionId);
        confirmTransaction(transactionId);
    }

    /** @dev Allows an owner to confirm a transaction.
     * @param transactionId Transaction ID.
     */
    function confirmTransaction(uint256 transactionId)
        public
        ownerExists(msg.sender)
        transactionExists(transactionId)
        notConfirmed(transactionId, msg.sender)
    {
        confirmations[transactionId][msg.sender] = true;
        emit Confirmation(msg.sender, transactionId);

        if (
            isConfirmed(transactionId) &&
            unlockTimes[transactionId] == 0 &&
            !isEmergencyCall(transactionId)
        ) {
            uint256 unlockTime = block.timestamp + lockSeconds;
            unlockTimes[transactionId] = unlockTime;
            emit UnlockTimeSet(transactionId, unlockTime);
        }
    }

    function isEmergencyCall(uint256 transactionId) internal view returns (bool) {
        bytes memory data = transactions[transactionId].data;

        for (uint256 i = 0; i < emergencyCalls.length; i++) {
            EmergencyCall memory emergencyCall = emergencyCalls[i];

            if (
                data.length == emergencyCall.paramsBytesCount + 4 &&
                data.length >= 4 &&
                emergencyCall.selector[0] == data[0] &&
                emergencyCall.selector[1] == data[1] &&
                emergencyCall.selector[2] == data[2] &&
                emergencyCall.selector[3] == data[3]
            ) {
                return true;
            }
        }

        return false;
    }

    function addEmergencyCall(string memory funcName, uint256 _paramsBytesCount) public onlyWallet {
        emergencyCalls.push(
            EmergencyCall({
                selector: keccak256(abi.encodePacked(funcName)),
                paramsBytesCount: _paramsBytesCount
            })
        );
    }

    /** @dev Allows an owner to revoke a confirmation for a transaction.
     * @param transactionId Transaction ID.
     */
    function revokeConfirmation(uint256 transactionId)
        external
        ownerExists(msg.sender)
        confirmed(transactionId, msg.sender)
        notExecuted(transactionId)
    {
        confirmations[transactionId][msg.sender] = false;
        emit Revocation(msg.sender, transactionId);
    }

    /** @dev Allows anyone to execute a confirmed transaction.
     * @param transactionId Transaction ID.
     */
    function executeTransaction(uint256 transactionId)
        external
        ownerExists(msg.sender)
        notExecuted(transactionId)
    {
        require(block.timestamp >= unlockTimes[transactionId], "TRANSACTION_NEED_TO_UNLOCK");

        if (isConfirmed(transactionId)) {
            Transaction storage transaction = transactions[transactionId];
            transaction.executed = true;
            (bool success, ) = transaction.destination.call{value: transaction.value}(
                transaction.data
            );
            if (success) emit Execution(transactionId);
            else {
                emit ExecutionFailure(transactionId);
                transaction.executed = false;
            }
        }
    }

    /** @dev Returns the confirmation status of a transaction.
     * @param transactionId Transaction ID.
     * @return Confirmation status.
     */
    function isConfirmed(uint256 transactionId) public view returns (bool) {
        uint256 count = 0;

        for (uint256 i = 0; i < owners.length; i++) {
            if (confirmations[transactionId][owners[i]]) {
                count += 1;
            }

            if (count >= required) {
                return true;
            }
        }

        return false;
    }

    /* Web3 call functions */

    /** @dev Returns number of confirmations of a transaction.
     * @param transactionId Transaction ID.
     * @return count Number of confirmations.
     */
    function getConfirmationCount(uint256 transactionId) external view returns (uint256 count) {
        for (uint256 i = 0; i < owners.length; i++) {
            if (confirmations[transactionId][owners[i]]) {
                count += 1;
            }
        }
    }

    /** @dev Returns total number of transactions after filers are applied.
     * @param pending Include pending transactions.
     * @param executed Include executed transactions.
     * @return count Total number of transactions after filters are applied.
     */
    function getTransactionCount(bool pending, bool executed)
        external
        view
        returns (uint256 count)
    {
        for (uint256 i = 0; i < transactionCount; i++) {
            if ((pending && !transactions[i].executed) || (executed && transactions[i].executed)) {
                count += 1;
            }
        }
    }

    /** @dev Returns list of owners.
     * @return List of owner addresses.
     */
    function getOwners() external view returns (address[] memory) {
        return owners;
    }

    /** @dev Returns array with owner addresses, which confirmed transaction.
     * @param transactionId Transaction ID.
     * @return _confirmations Returns array of owner addresses.
     */
    function getConfirmations(uint256 transactionId)
        external
        view
        returns (address[] memory _confirmations)
    {
        address[] memory confirmationsTemp = new address[](owners.length);
        uint256 count = 0;
        uint256 i;

        for (i = 0; i < owners.length; i++) {
            if (confirmations[transactionId][owners[i]]) {
                confirmationsTemp[count] = owners[i];
                count += 1;
            }
        }

        _confirmations = new address[](count);

        for (i = 0; i < count; i++) {
            _confirmations[i] = confirmationsTemp[i];
        }
    }
}

#+end_src
** helper/ChainlinkLENDUSDCPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for LEND-USDC(decimals=6) price convert

contract ChainlinkLENDUSDCPriceOracleProxy {
    address public chainlink = 0x4aB81192BB75474Cf203B56c36D6a13623270A67;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() / 100;
    }
}

#+end_src
** helper/TestWETH.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;


#+end_src
*** function
#+begin_src solidity

contract WETH9 {
    string public name = "Wrapped Ether";
    string public symbol = "WETH";
    uint8 public decimals = 18;

    event Approval(address indexed src, address indexed guy, uint256 wad);
    event Transfer(address indexed src, address indexed dst, uint256 wad);
    event Deposit(address indexed dst, uint256 wad);
    event Withdrawal(address indexed src, uint256 wad);

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    fallback() external payable {
        deposit();
    }

    receive() external payable {
        deposit();
    }

    function deposit() public payable {
        balanceOf[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }

    function withdraw(uint256 wad) public {
        require(balanceOf[msg.sender] >= wad);
        balanceOf[msg.sender] -= wad;
        msg.sender.transfer(wad);
        emit Withdrawal(msg.sender, wad);
    }

    function totalSupply() public view returns (uint256) {
        return address(this).balance;
    }

    function approve(address guy, uint256 wad) public returns (bool) {
        allowance[msg.sender][guy] = wad;
        emit Approval(msg.sender, guy, wad);
        return true;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(
        address src,
        address dst,
        uint256 wad
    ) public returns (bool) {
        require(balanceOf[src] >= wad);

        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {
            require(allowance[src][msg.sender] >= wad);
            allowance[src][msg.sender] -= wad;
        }

        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        Transfer(src, dst, wad);

        return true;
    }
}

#+end_src
** helper/Migrations.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

contract Migrations {
    address public owner;
    uint256 public last_completed_migration;

    modifier restricted() {
        if (msg.sender == owner) {
            _;
        }
    }

    constructor() public {
        owner = msg.sender;
    }

    function setCompleted(uint256 completed) public restricted {
        last_completed_migration = completed;
    }

    function upgrade(address newAddress) public restricted {
        Migrations upgraded = Migrations(newAddress);
        upgraded.setCompleted(last_completed_migration);
    }
}

#+end_src
** helper/BandBNBBUSDPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IBandOracleAggregator {
    function getReferenceData(string memory base, string memory quote)
        external
        view
        returns (uint256);
}


contract BandBNBBUSDPriceOracleProxy {
    IBandOracleAggregator public aggregator;

    constructor(IBandOracleAggregator _aggregator) public {
        aggregator = _aggregator;
    }

    function getPrice() public view returns (uint256) {
        return aggregator.getReferenceData("BNB", "USD");
    }
}

#+end_src
** helper/UniswapV2.sol
*** head
#+begin_src solidity
/**
 *Submitted for verification at Etherscan.io on 2020-05-05
 */

// File: contracts/interfaces/IUniswapV2Pair.sol

pragma solidity >=0.5.0;

#+end_src
*** function
#+begin_src solidity

interface IUniswapV2Pair {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    function MINIMUM_LIQUIDITY() external pure returns (uint256);

    function factory() external view returns (address);

    function token0() external view returns (address);

    function token1() external view returns (address);

    function getReserves()
        external
        view
        returns (
            uint112 reserve0,
            uint112 reserve1,
            uint32 blockTimestampLast
        );

    function price0CumulativeLast() external view returns (uint256);

    function price1CumulativeLast() external view returns (uint256);

    function kLast() external view returns (uint256);

    function mint(address to) external returns (uint256 liquidity);

    function burn(address to) external returns (uint256 amount0, uint256 amount1);

    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external;

    function skim(address to) external;

    function sync() external;

    function initialize(address, address) external;
}

// File: contracts/interfaces/IUniswapV2ERC20.sol

pragma solidity >=0.5.0;

interface IUniswapV2ERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external pure returns (string memory);

    function symbol() external pure returns (string memory);

    function decimals() external pure returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);

    function DOMAIN_SEPARATOR() external view returns (bytes32);

    function PERMIT_TYPEHASH() external pure returns (bytes32);

    function nonces(address owner) external view returns (uint256);

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external;
}

// File: contracts/libraries/SafeMath.sol

pragma solidity 0.6.9;

// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)

library SafeMath {
    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x + y) >= x, "ds-math-add-overflow");
    }

    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require((z = x - y) <= x, "ds-math-sub-underflow");
    }

    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");
    }
}

// File: contracts/UniswapV2ERC20.sol

pragma solidity 0.6.9;

contract UniswapV2ERC20 {
    using SafeMath for uint256;

    string public constant name = "Uniswap V2";
    string public constant symbol = "UNI-V2";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    bytes32 public DOMAIN_SEPARATOR;
    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
    mapping(address => uint256) public nonces;

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function _mint(address to, uint256 value) internal {
        totalSupply = totalSupply.add(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(address(0), to, value);
    }

    function _burn(address from, uint256 value) internal {
        balanceOf[from] = balanceOf[from].sub(value);
        totalSupply = totalSupply.sub(value);
        emit Transfer(from, address(0), value);
    }

    function _approve(
        address owner,
        address spender,
        uint256 value
    ) private {
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    function _transfer(
        address from,
        address to,
        uint256 value
    ) private {
        balanceOf[from] = balanceOf[from].sub(value);
        balanceOf[to] = balanceOf[to].add(value);
        emit Transfer(from, to, value);
    }

    function approve(address spender, uint256 value) external returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool) {
        if (allowance[from][msg.sender] != uint256(-1)) {
            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
        }
        _transfer(from, to, value);
        return true;
    }

    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        require(deadline >= block.timestamp, "UniswapV2: EXPIRED");
        bytes32 digest = keccak256(
            abi.encodePacked(
                "\x19\x01",
                DOMAIN_SEPARATOR,
                keccak256(
                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)
                )
            )
        );
        address recoveredAddress = ecrecover(digest, v, r, s);
        require(
            recoveredAddress != address(0) && recoveredAddress == owner,
            "UniswapV2: INVALID_SIGNATURE"
        );
        _approve(owner, spender, value);
    }
}

// File: contracts/libraries/Math.sol

pragma solidity 0.6.9;

// a library for performing various math operations

library Math {
    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}

// File: contracts/libraries/UQ112x112.sol

pragma solidity 0.6.9;

// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))

// range: [0, 2**112 - 1]
// resolution: 1 / 2**112

library UQ112x112 {
    uint224 constant Q112 = 2**112;

    // encode a uint112 as a UQ112x112
    function encode(uint112 y) internal pure returns (uint224 z) {
        z = uint224(y) * Q112; // never overflows
    }

    // divide a UQ112x112 by a uint112, returning a UQ112x112
    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
        z = x / uint224(y);
    }
}

// File: contracts/interfaces/IERC20.sol

pragma solidity >=0.5.0;

interface IERC20 {
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function name() external view returns (string memory);

    function symbol() external view returns (string memory);

    function decimals() external view returns (uint8);

    function totalSupply() external view returns (uint256);

    function balanceOf(address owner) external view returns (uint256);

    function allowance(address owner, address spender) external view returns (uint256);

    function approve(address spender, uint256 value) external returns (bool);

    function transfer(address to, uint256 value) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 value
    ) external returns (bool);
}

// File: contracts/interfaces/IUniswapV2Factory.sol

pragma solidity >=0.5.0;

interface IUniswapV2Factory {
    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);

    function feeTo() external view returns (address);

    function feeToSetter() external view returns (address);

    function getPair(address tokenA, address tokenB) external view returns (address pair);

    function allPairs(uint256) external view returns (address pair);

    function allPairsLength() external view returns (uint256);

    function createPair(address tokenA, address tokenB) external returns (address pair);

    function setFeeTo(address) external;

    function setFeeToSetter(address) external;
}

// File: contracts/interfaces/IUniswapV2Callee.sol

pragma solidity >=0.5.0;

interface IUniswapV2Callee {
    function uniswapV2Call(
        address sender,
        uint256 amount0,
        uint256 amount1,
        bytes calldata data
    ) external;
}

// File: contracts/UniswapV2Pair.sol

pragma solidity 0.6.9;

contract UniswapV2Pair is UniswapV2ERC20 {
    using SafeMath for uint256;
    using UQ112x112 for uint224;

    uint256 public constant MINIMUM_LIQUIDITY = 10**3;
    bytes4 private constant SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));

    address public factory;
    address public token0;
    address public token1;

    uint112 private reserve0; // uses single storage slot, accessible via getReserves
    uint112 private reserve1; // uses single storage slot, accessible via getReserves
    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves

    uint256 public price0CumulativeLast;
    uint256 public price1CumulativeLast;
    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event

    uint256 private unlocked = 1;
    modifier lock() {
        require(unlocked == 1, "UniswapV2: LOCKED");
        unlocked = 0;
        _;
        unlocked = 1;
    }

    function getReserves()
        public
        view
        returns (
            uint112 _reserve0,
            uint112 _reserve1,
            uint32 _blockTimestampLast
        )
    {
        _reserve0 = reserve0;
        _reserve1 = reserve1;
        _blockTimestampLast = blockTimestampLast;
    }

    function _safeTransfer(
        address token,
        address to,
        uint256 value
    ) private {
        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
        require(
            success && (data.length == 0 || abi.decode(data, (bool))),
            "UniswapV2: TRANSFER_FAILED"
        );
    }

    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
    event Swap(
        address indexed sender,
        uint256 amount0In,
        uint256 amount1In,
        uint256 amount0Out,
        uint256 amount1Out,
        address indexed to
    );
    event Sync(uint112 reserve0, uint112 reserve1);

    constructor() public {
        factory = msg.sender;
    }

    // called once by the factory at time of deployment
    function initialize(address _token0, address _token1) external {
        require(msg.sender == factory, "UniswapV2: FORBIDDEN"); // sufficient check
        token0 = _token0;
        token1 = _token1;
    }

    // update reserves and, on the first call per block, price accumulators
    function _update(
        uint256 balance0,
        uint256 balance1,
        uint112 _reserve0,
        uint112 _reserve1
    ) private {
        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), "UniswapV2: OVERFLOW");
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            // * never overflows, and + overflow is desired
            price0CumulativeLast +=
                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *
                timeElapsed;
            price1CumulativeLast +=
                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *
                timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        blockTimestampLast = blockTimestamp;
        emit Sync(reserve0, reserve1);
    }

    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
        address feeTo = IUniswapV2Factory(factory).feeTo();
        feeOn = feeTo != address(0);
        uint256 _kLast = kLast; // gas savings
        if (feeOn) {
            if (_kLast != 0) {
                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));
                uint256 rootKLast = Math.sqrt(_kLast);
                if (rootK > rootKLast) {
                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));
                    uint256 denominator = rootK.mul(5).add(rootKLast);
                    uint256 liquidity = numerator / denominator;
                    if (liquidity > 0) _mint(feeTo, liquidity);
                }
            }
        } else if (_kLast != 0) {
            kLast = 0;
        }
    }

    // this low-level function should be called from a contract which performs important safety checks
    function mint(address to) external lock returns (uint256 liquidity) {
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        uint256 balance0 = IERC20(token0).balanceOf(address(this));
        uint256 balance1 = IERC20(token1).balanceOf(address(this));
        uint256 amount0 = balance0.sub(_reserve0);
        uint256 amount1 = balance1.sub(_reserve1);

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        if (_totalSupply == 0) {
            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
        } else {
            liquidity = Math.min(
                amount0.mul(_totalSupply) / _reserve0,
                amount1.mul(_totalSupply) / _reserve1
            );
        }
        require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED");
        _mint(to, liquidity);

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Mint(msg.sender, amount0, amount1);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        uint256 balance0 = IERC20(_token0).balanceOf(address(this));
        uint256 balance1 = IERC20(_token1).balanceOf(address(this));
        uint256 liquidity = balanceOf[address(this)];

        bool feeOn = _mintFee(_reserve0, _reserve1);
        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
        require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED");
        _burn(address(this), liquidity);
        _safeTransfer(_token0, to, amount0);
        _safeTransfer(_token1, to, amount1);
        balance0 = IERC20(_token0).balanceOf(address(this));
        balance1 = IERC20(_token1).balanceOf(address(this));

        _update(balance0, balance1, _reserve0, _reserve1);
        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
        emit Burn(msg.sender, amount0, amount1, to);
    }

    // this low-level function should be called from a contract which performs important safety checks
    function swap(
        uint256 amount0Out,
        uint256 amount1Out,
        address to,
        bytes calldata data
    ) external lock {
        require(amount0Out > 0 || amount1Out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT");
        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings
        require(
            amount0Out < _reserve0 && amount1Out < _reserve1,
            "UniswapV2: INSUFFICIENT_LIQUIDITY"
        );

        uint256 balance0;
        uint256 balance1;
        {
            // scope for _token{0,1}, avoids stack too deep errors
            address _token0 = token0;
            address _token1 = token1;
            require(to != _token0 && to != _token1, "UniswapV2: INVALID_TO");
            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
            if (data.length > 0)
                IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
            balance0 = IERC20(_token0).balanceOf(address(this));
            balance1 = IERC20(_token1).balanceOf(address(this));
        }
        uint256 amount0In = balance0 > _reserve0 - amount0Out
            ? balance0 - (_reserve0 - amount0Out)
            : 0;
        uint256 amount1In = balance1 > _reserve1 - amount1Out
            ? balance1 - (_reserve1 - amount1Out)
            : 0;
        require(amount0In > 0 || amount1In > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT");
        {
            // scope for reserve{0,1}Adjusted, avoids stack too deep errors
            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
            require(
                balance0Adjusted.mul(balance1Adjusted) >=
                    uint256(_reserve0).mul(_reserve1).mul(1000**2),
                "UniswapV2: K"
            );
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }

    // force balances to match reserves
    function skim(address to) external lock {
        address _token0 = token0; // gas savings
        address _token1 = token1; // gas savings
        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
    }

    // force reserves to match balances
    function sync() external lock {
        _update(
            IERC20(token0).balanceOf(address(this)),
            IERC20(token1).balanceOf(address(this)),
            reserve0,
            reserve1
        );
    }
}

#+end_src
** helper/ChainlinkCOMPUSDCPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for COMP-USDC(decimals=6) price convert

contract ChainlinkCOMPUSDCPriceOracleProxy {
    address public chainlink = 0xdbd020CAeF83eFd542f4De03e3cF0C28A4428bd5;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() / 100;
    }
}

#+end_src
** helper/CloneFactory.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;

#+end_src
*** function
#+begin_src solidity

interface ICloneFactory {
    function clone(address prototype) external returns (address proxy);
}

// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/
// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167

contract CloneFactory is ICloneFactory {
    function clone(address prototype) external override returns (address proxy) {
        bytes20 targetBytes = bytes20(prototype);
        assembly {
            let clone := mload(0x40)
            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)
            mstore(add(clone, 0x14), targetBytes)
            mstore(
                add(clone, 0x28),
                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000
            )
            proxy := create(0, clone, 0x37)
        }
        return proxy;
    }
}

#+end_src
** helper/ConstOracle.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

contract ConstOracle {
    uint256 public tokenPrice;

    constructor(uint256 _price) public {
        tokenPrice = _price;
    }

    function getPrice() external view returns (uint256) {
        return tokenPrice;
    }
}

#+end_src
** helper/TestERC20.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;

import {SafeMath} from "../lib/SafeMath.sol";

#+end_src
*** function
#+begin_src solidity

contract TestERC20 {
    using SafeMath for uint256;

    string public name;
    uint8 public decimals;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) internal allowed;

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);

    constructor(string memory _name, uint8 _decimals) public {
        name = _name;
        decimals = _decimals;
    }

    function transfer(address to, uint256 amount) public returns (bool) {
        require(to != address(0), "TO_ADDRESS_IS_EMPTY");
        require(amount <= balances[msg.sender], "BALANCE_NOT_ENOUGH");

        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[to] = balances[to].add(amount);
        emit Transfer(msg.sender, to, amount);
        return true;
    }

    function balanceOf(address owner) public view returns (uint256 balance) {
        return balances[owner];
    }

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public returns (bool) {
        require(to != address(0), "TO_ADDRESS_IS_EMPTY");
        require(amount <= balances[from], "BALANCE_NOT_ENOUGH");
        require(amount <= allowed[from][msg.sender], "ALLOWANCE_NOT_ENOUGH");

        balances[from] = balances[from].sub(amount);
        balances[to] = balances[to].add(amount);
        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);
        emit Transfer(from, to, amount);
        return true;
    }

    function approve(address spender, uint256 amount) public returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return allowed[owner][spender];
    }

    function mint(address account, uint256 amount) external {
        balances[account] = balances[account].add(amount);
    }
}

#+end_src
** helper/ChainlinkSNXUSDPriceOracleProxy.sol
*** head
#+begin_src solidity

#+end_src
*** function
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for SNX-USDC(decimals=6) price convert

contract ChainlinkSNXUSDCPriceOracleProxy {
    address public chainlink = 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() / 100;
    }
}

#+end_src
** helper/MinimumOracle.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IMinimumOracle {
    function getPrice() external view returns (uint256);

    function setPrice(uint256 newPrice) external;

    function transferOwnership(address newOwner) external;
}


contract MinimumOracle {
    address public _OWNER_;
    uint256 public tokenPrice;

    // ============ Events ============

    event OwnershipTransfer(address indexed previousOwner, address indexed newOwner);

    // ============ Modifiers ============

    modifier onlyOwner() {
        require(msg.sender == _OWNER_, "NOT_OWNER");
        _;
    }

    // ============ Functions ============

    constructor() public {
        _OWNER_ = msg.sender;
        emit OwnershipTransfer(address(0), _OWNER_);
    }

    function transferOwnership(address newOwner) external onlyOwner {
        require(newOwner != address(0), "INVALID_OWNER");
        emit OwnershipTransfer(_OWNER_, newOwner);
        _OWNER_ = newOwner;
    }

    function setPrice(uint256 newPrice) external onlyOwner {
        tokenPrice = newPrice;
    }

    function getPrice() external view returns (uint256) {
        return tokenPrice;
    }
}

#+end_src
** helper/ChainlinkWBTCUSDCPriceOracleProxy.sol
*** head
#+begin_src solidity
/*

    Copyright 2020 DODO ZOO.
    SPDX-License-Identifier: Apache-2.0

*/

pragma solidity 0.6.9;
pragma experimental ABIEncoderV2;


#+end_src
*** function
#+begin_src solidity

interface IChainlink {
    function latestAnswer() external view returns (uint256);
}


// for WBTC(decimals=8)-USDC(decimals=6) price convert

contract ChainlinkWBTCUSDCPriceOracleProxy {
    address public chainlink = 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c;

    function getPrice() external view returns (uint256) {
        return IChainlink(chainlink).latestAnswer() * (10**8);
    }
}

#+end_src

* dodo report
 - graviton
#+ATTR_ORG: :width 500
[[../raw/raviton.png]]
 - pfolio
#+ATTR_ORG: :width 500
[[../raw/raviton-crop.png]]
 - dodo - draw!
 - dodo pair - draw or steal
 - dodo pricing
   + pricing
   + k flexibility
 - dodo proxy
 - dodo contract framework
 - pfolio contract framework
 - challenges
